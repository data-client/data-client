"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2022/08/03/validateRequired for quick validation","metadata":{"permalink":"/blog/2022/08/03/validateRequired for quick validation","source":"@site/blog/2022-08-03-validateRequired for quick validation.md","title":"validateRequired for quick validation","description":"validateRequired() will validate that required fields","date":"2022-08-03T00:00:00.000Z","formattedDate":"August 3, 2022","tags":[{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"},{"label":"validation","permalink":"/blog/tags/validation"},{"label":"data schemas","permalink":"/blog/tags/data-schemas"}],"readingTime":1.56,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"title":"validateRequired for quick validation","authors":["ntucker"],"tags":["rest-hooks","validation","data schemas"]},"nextItem":{"title":"Experimental useController()","permalink":"/blog/2021/08/29/Experimental-useController"}},"content":"[validateRequired()](https://resthooks.io/rest/api/validateRequired) will validate that required fields\\nare present; simplifying some common validation use cases.\\n[validateRequired()](https://resthooks.io/rest/api/validateRequired) is available in @rest-hooks/@5.1.0 or greater.\\n\\n```ts\\nclass CustomBaseEntity extends Entity {\\n  static validate(processedEntity) {\\n    return validateRequired(processedEntity, this.defaults) || super.validate(processedEntity);\\n  }\\n}\\n```\\n\\n\x3c!--truncate--\x3e\\n\\n### Motivation\\n\\nCurrently the https://resthooks.io/docs/getting-started/validation#partial-results case is a rather cumbersome endeavor; requiring users to maintain custom validation methods for each Resource/Entity they define. Furthermore, in some systems like GraphQL having partial results is quite common.\\n\\nWhat makes this more problematic is doing this incorrectly can lead to serious bugs, where data is missing when it is expected. For most cases the default fields provide information about which fields are expected. However, fields can be optional. Unfortunately in these cases, the default value isn\'t always something that is obvious like `null`. For instance [here, a user had an API that sometimes had a Date field](https://github.com/coinbase/rest-hooks/issues/492). However, the default case the date would be there so it made more sense to have an actual Date default.\\n\\nWhile we have made it easier to \'opt-out\' of these sorts of validations, it has become clear that doing this out of the box is not intuitive behavior.\\n\\n### Solution\\n\\nWe can add a simple helper to make defining these easy. Even better - if someone does not have optional fields, the `defaults` static member can be used to add this to a base class. This is great because it still allows opt-out, while having the default behavior more protective. And since the user explicitly added this to the base class the behavior should not be as surprising.\\n\\n```ts\\nclass CustomBaseEntity extends Entity {\\n  static validate(processedEntity) {\\n    return validateRequired(processedEntity, this.defaults) || super.validate(processedEntity);\\n  }\\n}\\n```\\n\\n```ts\\nclass FullAnalysis extends SummaryAnalysis {\\n  readonly graph: number[] = null;\\n  readonly lastRun?: Date = new Date(0);\\n\\n  static schema = {\\n    lastRun: Date,\\n  }\\n\\n  static validate(processedEntity) {\\n    return validateRequired(processedEntity, exclude(this.defaults, [\'lastRun\']));\\n  }\\n}\\n```"},{"id":"/2021/08/29/Experimental-useController","metadata":{"permalink":"/blog/2021/08/29/Experimental-useController","source":"@site/blog/2021-08-29-Experimental-useController.md","title":"Experimental useController()","description":"@rest-hooks/experimental is a new","date":"2021-08-29T00:00:00.000Z","formattedDate":"August 29, 2021","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"},{"label":"packages","permalink":"/blog/tags/packages"},{"label":"usecontroller","permalink":"/blog/tags/usecontroller"},{"label":"resource","permalink":"/blog/tags/resource"},{"label":"fetch","permalink":"/blog/tags/fetch"}],"readingTime":8.78,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"title":"Experimental useController()","authors":["ntucker"],"tags":["releases","rest-hooks","packages","usecontroller","resource","fetch"]},"prevItem":{"title":"validateRequired for quick validation","permalink":"/blog/2022/08/03/validateRequired for quick validation"},"nextItem":{"title":"Rest Hooks 4.2-4.5","permalink":"/blog/2020/02/18/Rest-Hooks-4.2-4.5"}},"content":"[@rest-hooks/experimental](https://www.npmjs.com/package/@rest-hooks/experimental) is a new\\npackage that allows us to quickly iterate on new designs by using them in production, which provides\\nfeedback in ways not possible at design and testing phase.\\n\\nThis package is **not** api stable; it does follow semver, so it will never reach 1.0.\\nHowever, it is tested with the same rigor we expect with Rest Hooks\\nas we use it in production. It is recommend to use this for providing feedback or playing with designs,\\nunless you are willing to put in extra work to make migrations. Detailed migration guides will only be\\nprovided upon upstreaming to the mainline packages.\\n\\nToday this package comes with two new features:\\n\\n**[useController()](./2021-08-29-Experimental-useController.md#usecontroller)**\\n\\n```ts\\nconst { fetch, invalidate, resetEntireStore } = useController();\\nfetch(MyResource.detail(), { id });\\n```\\n\\n**[Resource.list().paginated()](./2021-08-29-Experimental-useController.md#static-listpaginated)**\\n\\n```ts\\nclass NewsResource extends Resource {\\n  static listPage<T extends typeof NewsResource>(this: T) {\\n    return this.list().paginated(({ cursor, ...rest }) => [rest]);\\n  }\\n}\\n```\\n\\n\x3c!--truncate--\x3e\\n\\n## useController()\\n\\n:::tip Update\\n\\nAs of 6.1 [useController()](https://resthooks.io/docs/api/useController) is now upstreamed into\\nRest Hooks core packages\\n\\n:::\\n\\n### Usage\\n\\n```tsx\\nimport { useController } from \'@rest-hooks/experimental\';\\n\\nfunction MyComponent({ id }) {\\n  const { fetch, invalidate, resetEntireStore } = useController();\\n\\n  const handleRefresh = useCallback(\\n    async e => {\\n      await fetch(MyResource.detail(), { id });\\n    },\\n    [fetch, id],\\n  );\\n\\n  const handleSuspend = useCallback(\\n    async e => {\\n      await invalidate(MyResource.detail(), { id });\\n    },\\n    [invalidate, id],\\n  );\\n\\n  const handleLogout = useCallback(\\n    async e => {\\n      resetEntireStore();\\n    },\\n    [resetEntireStore],\\n  );\\n}\\n```\\n\\n[PR](https://github.com/coinbase/rest-hooks/pull/1048)\\n\\n### Motivation\\n\\n- Consolidate, simplify hooks\\n- Consistent interface between managers and hooks\\n- Global referential equality available everywhere (managers and updaters)\\n- Simplify and consolidate TTL and error concepts\\n- Less code in hooks = less work on rendering leaf nodes\\n- Icing on cake: ez migration to EndpointInterface and flexible args support for hooks\\n- Future breaking changes can allow ez migration with version strings sent to `useController({version: \'v2\'})`\\n\\n### One hook, many endpoints\\n\\nThe rules of hooks are very restrictive, so the less hooks you have to call, the more flexible. This also benefits render performance. In many cases you might want to fetch many different endpoints. What\'s worse is if you don\'t know which endpoints you might want to fetch upfront. With old design you\'d have to hook up every _possible_ one. This really destroys fetch-as-render pattern, as you want to be able to prefetch based on possible routes.\\n\\n#### Before\\n\\n```tsx\\nconst createUser = useFetcher(User.create());\\nconst refreshUsers = useFetcher(User.list());\\n\\nreturn (\\n  <form onSubmit={() => createUser({}, userPayload)}>\\n    <button onClick={() => refreshUsers({})}>Refresh list</button>\\n  </form>\\n);\\n```\\n\\n#### After\\n\\n```tsx\\nconst { fetch } = useController();\\n\\nreturn (\\n  <form onSubmit={() => fetch(User.create(), {}, userPayload)}>\\n    <button onClick={() => fetch(User.list(), {})}>Refresh list</button>\\n  </form>\\n);\\n```\\n\\n### Completely flexible, variable arguments\\n\\nThe concept of params + body for arguments was introduced to try to provide the most flexible approach in a world where type enforcement wasn\'t that flexible. With TypeScript 4\'s variadic tuples, it\'s now possible to strongly type arbitrary arguments to a function in a _generic_ way. Furthermore, stumbling upon package.json\'s typeVersions, rest hooks can now publish multiple type versions to be compatible with different versions of typescript. This allows us to eagerly adopt TypeScript 4 features, while providing a usable TypeScript 3 experience.\\n\\nSome common annoyances with the current parameter limitations are single-variable arguments like detail endpoints with an id, as well as no-argument case like a list endpoint or create endpoint.\\n\\n```tsx\\nconst { fetch } = useController();\\n\\nreturn (\\n  <form onSubmit={() => fetch(User.create(), userPayload)}>\\n    <button onClick={() => fetch(User.list())}>Refresh list</button>\\n  </form>\\n);\\n```\\n\\nWe\'ll also eventually bring this to the \'read\' hooks like so:\\n\\n```tsx\\n// notice username is just a string, rather than object\\nconst user = useResource(User.detail(), username);\\n// here we don\'t need arguments\\nconst posts = useResource(Post.list());\\n// but list() has it being optional, which means this also works:\\nconst goodPosts = useResource(Post.list(), { good: true });\\n// postId is a number in this case\\nconst thePost = useResource(Post.detail(), postId);\\n```\\n\\n### Endpoint.update\\n\\nBy normalizing [Entities](https://resthooks.io/docs/api/Entity), Rest Hooks guarantees data integrity and consistency even down to the referential equality level. However, there are still some cases where side effects result in changes to the actual results themselves. The most common reason for this is creation of new entities. While \'creation\' is almost universally the cause for this (as deletion is handled more simply by delete schemas), the structure of data and where created elements go is not universal.\\n\\n:::tip\\n\\n**Start using this now!** Though this is the only way to use the new Controller.fetch,\\nendpoints with `update` work with the old [useFetcher()](https://resthooks.io/docs/api/useFetcher) hook as well.\\n\\n:::\\n\\n#### Before\\n\\nPreviously this was enabled by an optional third argument to the fetch [UpdateParams](https://resthooks.io/docs/api/useFetcher#updateparams-destendpoint-destparams-updatefunction) enabling programmatic changes that are also strictly type enforced to ensure the data integrity of the Rest Hooks store.\\n\\n```typescript\\nconst createUser = new Endpoint(postToUserFunction, {\\n  schema: User,\\n});\\n\\nconst createUser = useFetcher(createUser);\\n\\ncreateUser({}, { id: 1 }, [\\n  [\\n    userList,\\n    {},\\n    (newUserID: string, userIDs: string[] | undefined) => [\\n      ...(userIDs || []),\\n      newUserID,\\n    ],\\n  ],\\n]);\\n```\\n\\nWhile simple, this design had several shortcomings\\n\\n- Only operates on the normalized results, often arrays of strings\\n  - This is non-intuitive as this doesn\'t relate directly to the data\'s form and requires understanding of internals\\n  - Code is confusing with two ordered args and necessary default handling\\n- Is provided as an argument to the fetch rather than endpoint\\n  - Makes variable arguments impossible, and hard to reason about\\n  - Makes pattern reuse still require explicit wiring\\n  - Was thought to be more flexible than in \'fetchshape\', as it has access to local variables in its event handler. However, Endpoints\'s can easily use `.extend()` to contextually override so this feature is moot.\\n  - Encourages antipatterns like writing hooks for specific endpoints\\n\\n#### After\\n\\n- Move to Endpoint\\n- builder pattern to make updater definition easy\\n  - typeahead\\n  - strong type enforcement\\n  - much more readable than a size 3 tuple\\n\\nSimplest case:\\n\\n```ts title=\\"userEndpoint.ts\\"\\nconst createUser = new Endpoint(postToUserFunction, {\\n  schema: User,\\n  update: (newUserId: string) => ({\\n    [userList.key()]: (users = []) => [newUserId, ...users],\\n  }),\\n});\\n```\\n\\nMore updates:\\n\\n```typescript title=\\"Component.tsx\\"\\nconst allusers = useResource(userList);\\nconst adminUsers = useResource(userList, { admin: true });\\n```\\n\\nThe endpoint below ensures the new user shows up immediately in the usages above.\\n\\n```ts title=\\"userEndpoint.ts\\"\\nconst createUser = new Endpoint(postToUserFunction, {\\n  schema: User,\\n  update: (newUserId, newUser)  => {\\n    const updates = {\\n      [userList.key()]: (users = []) => [newUserId, ...users],\\n    ];\\n    if (newUser.isAdmin) {\\n      updates[userList.key({ admin: true })] = (users = []) => [newUserId, ...users];\\n    }\\n    return updates;\\n  },\\n});\\n```\\n\\nThis is usage with a [Resource](https://resthooks.io/docs/api/Resource)\\n\\n```typescript title=\\"TodoResource.ts\\"\\nimport { Resource } from \'@rest-hooks/rest\';\\n\\nexport default class TodoResource extends Resource {\\n  readonly id: number = 0;\\n  readonly userId: number = 0;\\n  readonly title: string = \'\';\\n  readonly completed: boolean = false;\\n\\n  pk() {\\n    return `${this.id}`;\\n  }\\n\\n  static urlRoot = \'https://jsonplaceholder.typicode.com/todos\';\\n\\n  static create<T extends typeof Resource>(this: T) {\\n    const todoList = this.list();\\n    return super.create().extend({\\n      schema: this,\\n      // highlight-start\\n      update: (newResourceId: string) => ({\\n        [todoList.key({})]: (resourceIds: string[] = []) => [\\n          ...resourceIds,\\n          newResourceId,\\n        ],\\n      }),\\n      // highlight-end\\n    });\\n  }\\n}\\n```\\n\\n### Resolution order\\n\\nThis makes little difference in React 18 since renders are batched; however in React < 18, this means that code after promise resolution will be executed before react renders - allowing actions that need to take place as a result of successful fetch. For example navigating off a deleted page after delete.\\n\\n```typescript\\nconst handleDelete = useCallback(\\n  async e => {\\n    await fetch(MyResource.delete(), { id });\\n    history.push(\'/\');\\n  },\\n  [fetch, id],\\n);\\n```\\n\\n:::warning\\n\\nIt\'s now recommended to wrap all fetches in act when testing like so:\\n\\n```ts\\nawait act(async () => {\\n  await result.current.fetch(ComplexResource.detail(), {\\n    id: \'5\',\\n  });\\n});\\n```\\n\\n:::\\n\\n[PR](https://github.com/coinbase/rest-hooks/pull/1046)\\n\\n### What\'s Next\\n\\nTentative plans look something like this:\\n\\n```ts\\nconst controller = useController();\\n\\n// actions\\ncontroller.fetch(UserResource.detail(), { id }); // sideEffects means no throttle, otherwise throttle\\ncontroller.receive(payload, UserResource.detail(), { id });\\ncontroller.invalidate(UserResource.detail(), { id });\\ncontroller.resetEntireStore();\\ncontroller.subscribe(UserResource.detail(), { id });\\ncontroller.unsubscribe(UserResource.detail(), { id });\\n// posisble new\\ncontroller.abort(UserResource.detail(), { id }); // only aborts if in flight\\n// note: to force fetch of sideEffect: undefined - call abort first\\n// this should enable good offline/online managers\\n\\n// retrieval\\nconst state = useContext(StateContext);\\nconst [value, expiresAt] = controller.getResponse(\\n  state,\\n  UserResource.detail(),\\n  { id },\\n);\\nconst error = controller.getError(state, UserResource.detail(), { id });\\n```\\n\\n## Resource changes\\n\\n### static list().paginated()\\n\\n#### Motivation\\n\\n\x3c!--\\nDoes this solve a bug? Enable a new use-case? Improve an existing behavior? Concrete examples are helpful here.\\n--\x3e\\n\\nPagination is a common scenario, that would benefit from minimal specification.\\n\\n#### Solution\\n\\n\x3c!--\\nWhat is the solution here from a high level. What are the key technical decisions and why were they made?\\n--\x3e\\n\\nBy default we rely on finding a list within the schema. The only remaining thing is figuring out how to extract the \'cursor\' args to update the main list. Therefore, a function to do just that should be provided by the user like so.\\n\\n```ts\\nclass NewsResource extends Resource {\\n  static listPage<T extends typeof NewsResource>(this: T) {\\n    return this.list().paginated(({ cursor, ...rest }) => [rest]);\\n  }\\n}\\n```\\n\\n```tsx\\nimport { useResource } from \'rest-hooks\';\\nimport NewsResource from \'resources/NewsResource\';\\n\\nfunction NewsList() {\\n  const { results, cursor } = useResource(NewsResource.list(), {});\\n  const curRef = useRef(cursor);\\n  curRef.current = cursor;\\n  const fetch = useFetcher();\\n  const getNextPage = useCallback(\\n    () => fetch(NewsResource.listPage(), { cursor: curRef.current }),\\n    [],\\n  );\\n\\n  return (\\n    <Pagination onPaginate={getNextPage} nextCursor={cursor}>\\n      <NewsList data={results} />\\n    </Pagination>\\n  );\\n}\\n```\\n\\n[PR](https://github.com/coinbase/rest-hooks/pull/868)\\n\\n### New Hiearchy\\n\\nNot every Resource has the same endpoints. It may have additional methods to CRUD, or\\nit could only support some operations. Furthermore, the exact nature and typings of endpoints\\ncould vary widely making it hard to define a good base class, while also providing very specific types.\\n\\nThat\'s why there is a new `BaseResource` that includes everything Resource had, but with\\nabsolutely no endpoints. Instead it comes with an extensible \'abstract endpoint\' BaseResource.endpoint()\\nfor side-effect free endpoints, as well as BaseResource.endpointMutate().\\n\\n`Resource` is still provided, by simplying extending one of these endpoints like so\\n\\n```typescript\\nabstract class Resource extends BaseResource {\\n  /** Endpoint to get a single entity */\\n  static detail<T extends typeof Resource>(\\n    this: T,\\n  ): RestEndpoint<\\n    (this: RestEndpoint, params: any) => Promise<any>,\\n    SchemaDetail<AbstractInstanceType<T>>,\\n    undefined\\n  > {\\n    const endpoint = this.endpoint();\\n    return this.memo(\'#detail\', () =>\\n      endpoint.extend({\\n        schema: this,\\n      }),\\n    );\\n  }\\n  // etc\\n}\\n```\\n\\nThis should make it much easier to get started quickly, while allowing for a powerful yet flexible\\noptions in `BaseResource`. We expect most medium-to-large applications to mostly use this class.\\n\\n[PR](https://github.com/coinbase/rest-hooks/pull/841)"},{"id":"/2020/02/18/Rest-Hooks-4.2-4.5","metadata":{"permalink":"/blog/2020/02/18/Rest-Hooks-4.2-4.5","source":"@site/blog/2020-02-18-Rest-Hooks-4.2-4.5.md","title":"Rest Hooks 4.2-4.5","description":"A lot of exciting features have been developed recently, resulting in many feature releases.","date":"2020-02-18T00:00:00.000Z","formattedDate":"February 18, 2020","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":0.705,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"title":"Rest Hooks 4.2-4.5","authors":["ntucker"],"tags":["releases","rest-hooks"]},"prevItem":{"title":"Experimental useController()","permalink":"/blog/2021/08/29/Experimental-useController"},"nextItem":{"title":"Rest Hooks 4.1 Released","permalink":"/blog/2020/01/06/Rest-Hooks-4.1-Released"}},"content":"A lot of exciting features have been developed recently, resulting in many feature releases.\\nWe\'ve been hard a work integrating them into Coinbase\'s various products, so I skipped a few\\nrelease announcements. The biggest focus has been performance features - highlighted by\\nadding true [optimistic updates](https://resthooks.io/docs/4.5/guides/optimistic-updates).\\n\\n\x3c!--truncate--\x3e\\n\\n### 4.2:\\n\\n[Indexes](https://github.com/coinbase/rest-hooks/issues/237)\\n\\n[Indexes](https://resthooks.io/docs/4.5/api/Index) allow lookup by alternate fields other than the primary key\\n\\n[Full set of 4.1 release commits](https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.1.0)\\n\\n### 4.3:\\n\\n[Optimistic updates](https://github.com/coinbase/rest-hooks/issues/246)\\n[Keep referential equality in list views](https://github.com/coinbase/rest-hooks/issues/251)\\n\\n### 4.4\\n\\n- SetShapeParams\\n- ParamsFromShape\\n- Export EntitySchema and EntityInstance\\n- Fixed react native listUrl bug\\n\\n### 4.5\\n\\n- Include all FetchOptions in subscribe action (https://github.com/coinbase/rest-hooks/issues/265)\\n- Support non JSON (aka binary) fetches (https://github.com/coinbase/rest-hooks/issues/267)\\n\\nInternal Breaking:\\nChanging middlewares results in a new dispatch that properly wraps those middlewares. Technically this is\\na fix, but if you relied on the old behavior be careful!"},{"id":"/2020/01/06/Rest-Hooks-4.1-Released","metadata":{"permalink":"/blog/2020/01/06/Rest-Hooks-4.1-Released","source":"@site/blog/2020-01-06-Rest-Hooks-4.1-Released.md","title":"Rest Hooks 4.1 Released","description":"4.1 comes with a more granular data definition hierarchy that will make it easier to","date":"2020-01-06T00:00:00.000Z","formattedDate":"January 6, 2020","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":0.705,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"title":"Rest Hooks 4.1 Released","authors":["ntucker"],"tags":["releases","rest-hooks"]},"prevItem":{"title":"Rest Hooks 4.2-4.5","permalink":"/blog/2020/02/18/Rest-Hooks-4.2-4.5"},"nextItem":{"title":"Rest Hooks 4.0 Released","permalink":"/blog/2019/12/24/Rest-Hooks-4.0-Released"}},"content":"4.1 comes with a more granular data definition hierarchy that will make it easier to\\nwrite more API definitions. This marked by the introduction of a new member known\\nas [Entity](/docs/4.1/api/Entity). `Entity` only needs a `pk()` and `get key()`, as well\\nas member declarations to integrate fully.\\n\\n### Entity\\n\\n- Useful for nested entities that don\'t have endpoints like LatestPrice.\\n- Useful for non-REST style APIs like GraphQL.\\n- Simplifies defining nested entities.\\n\\n\x3c!--truncate--\x3e\\n\\n### New hierarchy:\\n\\n```\\n SimpleRecord\\n      |\\n   Entity\\n      |\\nSimpleResource\\n      |\\n   Resource\\n```\\n\\n### Deprecations:\\n\\n- Resource.getKey() -> Resource.key\\n- Resource.getEntitySchema() -> Resource.asSchema()\\n- Entity.define() -> override Entity.schema\\n\\n### Changes:\\n\\n- Normalizr: top level key sent to getId is undefined not null\\n- pk() now takes additional parent, and key optional args\\n- pk() no longer accepts number return value (run .toString())\\n\\n[Full set of 4.1 release commits](https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.1.0)"},{"id":"/2019/12/24/Rest-Hooks-4.0-Released","metadata":{"permalink":"/blog/2019/12/24/Rest-Hooks-4.0-Released","source":"@site/blog/2019-12-24-Rest-Hooks-4.0-Released.md","title":"Rest Hooks 4.0 Released","description":"4.0 marks the end of the migration to the new useCache() and useResource() implementations first","date":"2019-12-24T00:00:00.000Z","formattedDate":"December 24, 2019","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":3.365,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"authors":["ntucker"],"tags":["releases","rest-hooks"],"title":"Rest Hooks 4.0 Released"},"prevItem":{"title":"Rest Hooks 4.1 Released","permalink":"/blog/2020/01/06/Rest-Hooks-4.1-Released"},"nextItem":{"title":"Rest Hooks 2.2 Released","permalink":"/blog/2019/10/28/Rest-Hooks-2.2-Released"}},"content":"4.0 marks the end of the migration to the new useCache() and useResource() implementations first\\nintroduced in 2.2. It also comes with a few other exciting features like a rewritten fetch based\\non the actual browser [fetch API](https://developer.mozilla.org/en-US/docs/4.0/Web/API/Fetch_API).\\nRead below for more details and a [migration guide](#migration-guide).\\n\\n\x3c!--truncate--\x3e\\n\\n## Drop legacy\\n\\nThis marks the final stage of the rewritten selector hooks with useCacheLegacy() and useResourceLegacy() both\\nbeing completely removed.\\nThese legacy versions removed in [#170](https://github.com/coinbase/rest-hooks/pull/170/files) are wrappers\\naround the new versions. Because of this if you want to continue using those selectors you can simply\\ncopy the code removed in [#170](https://github.com/coinbase/rest-hooks/pull/170/files) into your own\\napplication.\\n\\n## Using fetch() out of the box\\n\\n[Superagent](http://visionmedia.github.io/superagent/) has a nice API using the [Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern), as well as working server-side out of the box which made it a great default fetch implementation.\\nHowever, it has not received much love recently and over time more functionality has been added to\\nthe [fetch](https://developer.mozilla.org/en-US/docs/4.0/Web/API/Fetch_API) standard. Furthermore,\\ndevelopers have become increasingly familiar and used to it over other solutions.\\n\\nFor these reasons, we the default fetch implementation in [Resource](https://resthooks.io/docs/4.0/api/Resource) now uses fetch. As such,\\nif you are targetting old (read: IE) browsers or want to run your code in node (for unit tests or server side rendering),\\nyou\'ll need to add a [fetch polyfill](https://www.npmjs.com/package/whatwg-fetch). [whatwg-ftech](https://www.npmjs.com/package/whatwg-fetch)\\nis a great choice as it works both in node and in old browsers.\\n\\nFor those looking to continue using superagent, the old implementation is provided as an example [custom\\nfetch function](https://resthooks.io/docs/4.0/guides/custom-networking#superagent).\\n\\nAlong with this redesign comes some useful new ways of extending fetch for custom hooks.\\nInstead of `fetchPlugin`, there is a now a `fetchOptionsPlugin` which can be used to set\\nthe [fetch options](https://developer.mozilla.org/en-US/docs/4.0/Web/API/WindowOrWorkerGlobalScope/fetch) like adding headers.\\n\\n[fetchResponse()](https://resthooks.io/docs/4.0/api/resource#static-fetchresponsemethod-get--post--put--patch--delete--options-url-string-body-readonlyobject--string--promiseresponse)\\nis exposed which does the bulk of the fetching besides reading the data itself. This can be useful when\\nbuilding custom fetch shapes that need [access to things like headers](https://resthooks.io/docs/4.0/guides/network-transform#using-http-headers).\\nto build their response.\\n\\n## New supplemental libraries\\n\\nTwo new libraries were introduced in the last two months. These are both compatible with v3 and v4 of Rest Hooks.\\n\\n### [@rest-hooks/test](https://www.npmjs.com/package/@rest-hooks/test)\\n\\nPreviously, [testing utilities](https://resthooks.io/docs/4.0/guides/unit-testing-hooks) had been included in\\nrest-hooks package directly. These were pulled out into their own library and are no longer\\nincluded in v4 of Rest Hooks.\\n\\n### [@rest-hooks/legacy](https://www.npmjs.com/package/@rest-hooks/legacy)\\n\\nLegacy is a new package that included a hook similar to [useResource()](https://resthooks.io/docs/4.0/api/useresource), but that doesn\'t use Suspense.\\nIn practice this can be useful even when Suspense is used, as certain scenarios having stateful indicators\\nfor loading and error states can actually be more ergonomic. This is also essential to integrate currently\\nwith any Server Side Rendering.\\n\\nPreviously [useStatefulResource()](https://resthooks.io/docs/4.0/guides/no-suspense) had been provided as\\nexample code in the docs. However, since it was not tested it would often grow incompatible as underlying\\nchanges were made to Rest Hooks itself.\\n\\nNow it\'s just an install and import away.\\n\\n## Drop IE support in ES6 module\\n\\nSupporting Internet Explorer can be annoying. For many it is not even a requirement for their apps,\\nand so including library code with compatibility adapters can make the code bloated and even slower.\\n\\nFor this reason, those using a bundler that recognizes ES6 modules like webpack or parcel will load\\na somewhat [modern target](https://github.com/coinbase/rest-hooks/blob/rest-hooks%404.0.0/package.json#L25).\\n\\nIf you plan on supporting IE, you\'ll need to include transpiling Rest Hooks as part of your build process.\\nNote that Create React App already does this, so no work is needed in that case.\\n\\n## Migration Guide\\n\\n- Transpile Rest Hooks if IE is to be supported\\n- Remove useCacheLegacy() and useResourceLegacy()\\n- rest-hooks/test -> @rest-hooks/test\\n- fetchPlugin -> fetchOptionsPlugin, which builds on [fetch options](https://developer.mozilla.org/en-US/docs/4.0/Web/API/WindowOrWorkerGlobalScope/fetch)\\n- No more SuperagentResource export\\n- url() and listUrl() params are no longer optional (TypeScript)\\n- Remove generic signatures to any Resource.fetch() overrides\\n\\n## Final notes\\n\\nPlease try out the new release and [give feedback](https://github.com/coinbase/rest-hooks/issues)\\nif there are any issues or if things are working great! We\'ve got a lot of great new features\\ncoming down the pipeline and we hope to see your contributions as well. \ud83d\ude0a\\n\\n[Full set of 4.0 release commits](https://github.com/coinbase/rest-hooks/releases/tag/rest-hooks%404.0.0)"},{"id":"/2019/10/28/Rest-Hooks-2.2-Released","metadata":{"permalink":"/blog/2019/10/28/Rest-Hooks-2.2-Released","source":"@site/blog/2019-10-28-Rest-Hooks-2.2-Released.md","title":"Rest Hooks 2.2 Released","description":"2.2 comes with the eagerly awaited programmable optimistic updates. This enables two very important use cases:","date":"2019-10-28T00:00:00.000Z","formattedDate":"October 28, 2019","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":3.965,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"authors":["ntucker"],"tags":["releases","rest-hooks"],"title":"Rest Hooks 2.2 Released"},"prevItem":{"title":"Rest Hooks 4.0 Released","permalink":"/blog/2019/12/24/Rest-Hooks-4.0-Released"},"nextItem":{"title":"Rest Hooks 2.1 Released","permalink":"/blog/2019/08/07/Rest-Hooks-2.1-Released"}},"content":"2.2 comes with the eagerly awaited programmable optimistic updates. This enables two very important use cases:\\noptimistic update on create and infinite pagination.\\n\\nThe bigger part of this release is introducing two new hooks that enable an incremental migration path to\\n3.0 planned changes. [useCacheNew()](https://resthooks.io/docs/2.2/api/useCacheNew) and [useResourceNew()](https://resthooks.io/docs/2.2/api/useresourcenew) are added in this release, allowing incremental adoption of the new selection logic\\nthat will become the default in 3.0. More details below.\\n\\n\x3c!--truncate--\x3e\\n\\n## Optimistic update on create\\n\\nMutation fetches can often change more than just the entities in their response. For example,\\nissuing a create often means a subsequent request for a list of that resource will include the newly\\ncreated entity. Previously the workaround for this case would be to issue a fetch immediately after\\nthe mutation request. This is not ideal as it causes unnecessary network traffic, server load, and most\\nimportantly a slower user experience.\\n\\nHowever, since updates like these can be extremely varied and implementation-dependant, providing a solution\\nthat is protocol agnostic requires careful tuning. Inverting control can also be dangerous as\\na small bug in user-code can destroy the entire cache structure.\\n\\nIntroducing [updateParams](https://resthooks.io/docs/2.2/api/useFetcher#updateparams-destshape-destparams-updatefunction)\\na new third argument to the imperative fetch function.\\n\\nEach tuple in the array represents a result entry to update. The first two members of the tuple represent\\nthat result, while the third is a function defining how to update it with the results of the fetch call.\\nTypeScript is invaluable here, as the very strict types ensure the function does not cause any cache state invariants\\nto be violated.\\n\\n```typescript\\nconst createArticle = useFetcher(ArticleResource.createShape());\\n\\ncreateArticle({ id: 1 }, {}, [\\n  [\\n    ArticleResource.listShape(),\\n    {},\\n    (newArticle, articles) => [...articles, newArticle],\\n  ],\\n]);\\n```\\n\\n### Pagination\\n\\nThis can also be used to support [pagination](/docs/2.2/guides/infinite-scrolling-pagination). Every time a new page is called, the results of that\\npage can be aggregated on one result list. Here\'s the rough idea (this code hasn\'t been tested):\\n\\n```typescript\\nclass PaginatedArticleResource extends Resource {\\n  readonly id: number | null = null;\\n  readonly title: string = \'\';\\n  readonly content: string = \'\';\\n  readonly author: number | null = null;\\n  readonly tags: string[] = [];\\n\\n  pk() {\\n    return this.id;\\n  }\\n\\n  static urlRoot = \'http://test.com/article/\';\\n\\n  static listShape<T extends typeof Resource>(this: T) {\\n    return {\\n      ...super.listShape(),\\n      schema: { results: [this.getEntitySchema()] },\\n    };\\n  }\\n}\\n\\nfunction mergeArticles(\\n  newPage: { results: string[] },\\n  articles: { results?: string[] },\\n): { results: string[] } {\\n  return [...(articles.results || []), ...newPage.results];\\n}\\n\\nfunction useNextPageFetcher() {\\n  const getNextPage = useFetcher(ArticleResource.listShape());\\n  return useCallback(() => {\\n    return getNextPage({}, { cursor: 2 }, [\\n      [ArticleResource.listShape(), {}, mergeArticles],\\n    ]);\\n  }, [getNextPage]);\\n}\\n```\\n\\n[Add optimistic update on create + configurable optimistic updates](https://github.com/coinbase/rest-hooks/pull/153)\\n\\n## useResourceNew() and useCacheNew()\\n\\nPreviously for \u2018convenience\u2019 Rest Hooks\u2019 selectors would automatically \u2018dive\u2019 into results - directly returning the first entity or list of entities it found. This seemed convenient but had the assumption that there would 1) always be an entity in a schema 2) be only one top-level entity. This is a pretty big assumption to make, and violates the principal of protocol agnosticism. Furthermore, this somewhat arbitrary behavior is not obvious and easily results in confusion to new users. Since the legacy selector behavior can easily be composed on top of selectors\\nreturning the entire results, we have decided to move to a less opinionated version for the two selector hooks - `useCache()` and `useResource()`.\\n\\nTo make the transition easy, there are three phases. The first is in 2.2, which will introduce an opt-in to the new behavior by introducing\\n[useResourceNew()](https://resthooks.io/docs/2.2/api/useresourcenew) and [useCacheNew()](https://resthooks.io/docs/2.2/api/useCacheNew). Upgrading to\\n2.2 allows incremental adoption of the new behavior one component at a time. Then in 3.0, the current `useResource()` and `useCache()` will be renamed to `useResourceLegacy()` and `useCacheLegacy()` respectively. The new hooks will then take their place. This makes upgrading a simple rename as well, providing an additional time window of incremental adoption. However, at that point these hooks should be considered deprecrated. Finally, in the next minor/major version, the legacy hooks will be removed altogether.\\n\\n[Add useResourceNew() and useCacheNew()](https://github.com/coinbase/rest-hooks/pull/135)\\n\\n## useResetter()\\n\\n[useResetter()](https://resthooks.io/docs/2.2/api/useResetter) is a simple hook that makes clearing the entire cache imperatively quite simple. This can be useful in cases such as a user changing authentication state by login/logout.\\n\\n[Add useResetter() which returns a function that can clear entire cache](https://github.com/coinbase/rest-hooks/pull/148)\\n\\n## Improved Union and Values support\\n\\nAdditional tests and edge cases using Union and Value types have been added ensuring maximum schema flexibility.\\n\\n[Fully support Union and Values schemas in types and useDenormalized()](https://github.com/coinbase/rest-hooks/pull/135)\\n\\n## Final notes\\n\\nPlease try out the new release and [give feedback](https://github.com/coinbase/rest-hooks/issues)\\nif there are any issues or if things are working great! We\'ve got a lot of great new features\\ncoming down the pipeline and we hope to see your contributions as well. \ud83d\ude0a\\n\\n[Full set of 2.2 release commits](https://github.com/coinbase/rest-hooks/releases/tag/2.2.0)"},{"id":"/2019/08/07/Rest-Hooks-2.1-Released","metadata":{"permalink":"/blog/2019/08/07/Rest-Hooks-2.1-Released","source":"@site/blog/2019-08-07-Rest-Hooks-2.1-Released.md","title":"Rest Hooks 2.1 Released","description":"New Features","date":"2019-08-07T00:00:00.000Z","formattedDate":"August 7, 2019","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":2.69,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"authors":["ntucker"],"tags":["releases","rest-hooks"],"title":"Rest Hooks 2.1 Released"},"prevItem":{"title":"Rest Hooks 2.2 Released","permalink":"/blog/2019/10/28/Rest-Hooks-2.2-Released"},"nextItem":{"title":"Announcing Rest Hooks 2.0","permalink":"/blog/2019/07/13/Announcing-Rest-Hooks-2.0"}},"content":"## New Features\\n\\n### Reduced bundle size with custom networking library\\n\\nResource comes with a default `fetch()` implementation to make getting started easy.\\nIt uses [superagent](http://visionmedia.github.io/superagent/) as the networking library\\ndue to its server-side support as well as nice interface via the [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern).\\nHowever, this comes at the cost of 6kb gziped added to the bundle. For those who want\\nto [use another networking library](https://resthooks.io/docs/2.2/guides/custom-networking) this is quite a cost to pay for a library that itself\\nis well under 10kb gzip.\\n\\nTo solve this problem there is a new exported called `SimpleResource`. This provides\\nall the Resource behavior without the `fetch()` implementation. If you\'re customizing\\n`fetch()` or want to customize `fetch()`, simply [follow the instructions](https://resthooks.io/docs/2.2/guides/custom-networking) to use\\nSimpleResource as your base class now. With tree-shaking this will leave [superagent](http://visionmedia.github.io/superagent/)\\nout of your bundle and save a cool 6kb gzip.\\n\\n[Enable customizing networking library reducing bundle size #113](https://github.com/coinbase/rest-hooks/pull/113)\\n\\n\x3c!--truncate--\x3e\\n\\n### RPCAction, PurgeAction\\n\\nRPCAction, PurgeAction types join ReceiveAction and FetchAction as exportes from Rest Hooks.\\nInternally Rest Hooks dispatches actions (plain objects) that describe what Rest Hooks should do.\\nThe structure of these actions is typed and previously only some of those types were actually\\nexported. Now you can get access to all of them. This is most useful for building your own [custom\\nmanagers](https://resthooks.io/docs/2.2/api/Manager).\\n\\n[Export new types RPCAction, PurgeAction #119](https://github.com/coinbase/rest-hooks/pull/119)\\n\\n\\n## Improved Debugging\\n\\nSometimes the backend can fail and return bad responses - even without an HTTP error code.\\nIt would behoove any fetching library to gracefully handle those cases and inform the user what\\nhappened.\\n\\nPreviously there was a check for this very case - but it was only included in development mode.\\nHaving certain bug checking code only exist in development mode makes sense for errors that\\nwould exist and be caught in the client code. However, for issues independant of client (like\\nservers) this is an unreasonable restriction.\\n\\nTo solve this, the default `fetch()` implementation in `Resource` has been updated to\\ncheck for valid responses even in production. Its checking logic has also been improved.\\nAdditionally the internal action dispatching types have been updated to not allow void\\nresponses for anything besides a PurgeAction. This is important to enforce voids are not\\npassed around as they have no meaning as the result of a fetch. This leads the way to [further\\ntype refinements that enforce this as the FetchShape.fetch()](https://github.com/coinbase/rest-hooks/issues/120)\\nlevel as to ensure user implementations provide those same guarantees.\\n\\nNow even in production - if the API soft errors by returning an invalid response without\\nan error status code you will get a \\"JSON expected but not returned from API\\" error response.\\n\\n[Handle null fetch response even in production #119](https://github.com/coinbase/rest-hooks/pull/119)\\n\\n## Type refinements\\n\\n`String` is considered a valid payload to be sent in requests, so it has been added to the union along\\nwith `object`. This makes API really as flexible as it should be.\\n\\n[Allow string type for body (payload) parameters ](https://github.com/coinbase/rest-hooks/pull/116)\\n\\n\\n## Final notes\\n\\nPlease try out the new release and [give feedback](https://github.com/coinbase/rest-hooks/issues)\\nif there are any issues or if things are working great! We\'ve got a lot of great new features\\ncoming down the pipeline and we hope to see your contributions as well. \ud83d\ude0a\\n\\n[Full set of 2.1 release commits](https://github.com/coinbase/rest-hooks/releases/tag/2.1.0)"},{"id":"/2019/07/13/Announcing-Rest-Hooks-2.0","metadata":{"permalink":"/blog/2019/07/13/Announcing-Rest-Hooks-2.0","source":"@site/blog/2019-07-13-Announcing-Rest-Hooks-2.0.md","title":"Announcing Rest Hooks 2.0","description":"We use SemVer for Rest Hooks - so 2.0 represents some breaking changes. To minimize disruption","date":"2019-07-13T00:00:00.000Z","formattedDate":"July 13, 2019","tags":[{"label":"releases","permalink":"/blog/tags/releases"},{"label":"rest-hooks","permalink":"/blog/tags/rest-hooks"}],"readingTime":5.485,"hasTruncateMarker":true,"authors":[{"name":"Nathaniel Tucker","title":"Creator of Rest Hooks","url":"https://github.com/ntucker","imageURL":"https://github.com/ntucker.png","key":"ntucker"}],"frontMatter":{"authors":["ntucker"],"tags":["releases","rest-hooks"],"title":"Announcing Rest Hooks 2.0"},"prevItem":{"title":"Rest Hooks 2.1 Released","permalink":"/blog/2019/08/07/Rest-Hooks-2.1-Released"}},"content":"We use [SemVer](https://semver.org/) for Rest Hooks - so 2.0 represents some breaking changes. To minimize disruption\\nwe have been carefully considering these changes and awaiting community feedback to be confident\\nthese are the right changes to make.\\n\\nWhile some of these changes are simple renames to make the library more intuitive - some represent\\nimportant progress to empowering the next chapter of Rest Hooks.\\n\\nSee https://github.com/coinbase/rest-hooks/releases/tag/2.0.0 for a complete list of changes\\n\\n\x3c!--truncate--\x3e\\n\\n## Breaking changes\\n\\nRest Hooks 2.0 mostly represents breaking changes. While some of these provide new functionality\\nor capabilities, purely additive features will come in subsequent releases.\\n\\n### Renaming\\n\\n#### RestProvider -> CacheProvider\\n\\nThe core provider has been renamed appropriately to represent what it actually does - manage\\nthe cache. Since Rest Hooks is **protocol agnostic** by design it was not only misleading as name\\nbut also didn\'t sufficiently express what the provider is actually _providing_.\\n\\n#### RequestShape -> FetchShape\\n\\n[FetchShape](/docs/2.2/api/FetchShape) is the core interface that enables Rest Hooks to be both\\n**declarative**, **performant** and **protocol agnostic**. The previous `Request` terminology\\nonly represented one-side of the entire request/response pattern in fetch. This did not comprehensively\\nencapsulate the entirety of what it provided - thus we changed the name to `FetchShape` to capture\\nthe full cycle of behavior - from request all the way to handling the response that it provides.\\n\\n#### Resource `FetchShape` generators\\n\\nAlong the same lines, the provided static methods in [Resource](/docs/2.2/api/resource) that return `FetchShapes`\\nneed to accurately describe their return value. As such, the suffix has changed from `Request` to `Shape`. Also,\\nthe request for getting a singular entity - typically using a lookup id - has had its prefix changed\\nfrom `single` to `detail` to better reflect common `REST` terminology.\\n\\n- singleRequest() -> detailShape()\\n- listRequest() -> listShape()\\n- createRequest() -> createShape()\\n- updateRequest() -> updateShape()\\n- partialUpdateRequest() -> partialUpdateShape()\\n- deleteRequest() -> deleteShape()\\n\\n#### Schema types\\n\\nPreviously there were two generic used to distinguish between `Schema`s that return a single item and many to\\nmark the expected return values of `detailShape()` and `listShape()`. Their names have been changed\\nto be consistent with the new naming. `SchemaBase` is now `SchemaDetail` and `SchemaArray` is now\\n`SchemaList`.\\n\\n### Extensibility\\n\\nA core tenant of Rest Hooks\' design is to be flexible to match diverse use cases. Along those\\nlines, some key improvements were made to enable easier extensibility and customization that will\\nempower the next wave of applications using Rest Hooks.\\n\\n#### CacheProvider and Managers\\n\\nThe [Manager](/docs/2.2/api/Manager) abstraction has existed since the beginning of Rest Hooks. The first Manager - [NetworkManager](/docs/2.2/api/NetworkManager)\\norchestrated the complex world of fetching. It provided performance optimizations like fetch deduplication\\nwhile providing Suspense promise resolution free of race conditions. This enabled the consistent bug-free behavior\\nof Rest Hooks while maintaining its minimal bundle footprint. Later the [SubscriptionManager](/docs/2.2/api/SubscriptionManager) was added\\nto enable keeping resources fresh.\\n\\nHowever, it quickly became clear that this was only the beginning. To enable the next generation of\\nManagers, [CacheProvider](/docs/2.2/api/CacheProvider) now takes an [array of managers](/docs/2.2/api/CacheProvider#managers-manager)\\nas a prop. As an undocumented behavior, the NetworkManager and SubscriptionManager\\ncould previously be passed as arguments to customize their configuration. Instead\\nyou can now override their defaults by sending both managers. Or build your own Managers\\nto be used as well.\\n\\n#### Protocol Agnostic\\n\\nInitially, FetchShape included a member to get the url (`getUrl()`). This was used to both\\nprovide a lookup key for the results of a request as well as generate the url to send\\nto `fetch()` using an object of params like `{ id: 5 }`. This made it easy to override\\njust the url portion of a shape for custom endpoints.\\n\\nHowever, for protocols that don\'t base their requests on url like GraphQL this was a bit\\nawkward. Additionally, manipulating the request/response based on fetch params [became\\ncumbersome when the fetch method had to parse the url](https://github.com/coinbase/rest-hooks/issues/87)\\ninstead of just access those params itself.\\n\\n- [getUrl() -> getFetchKey() + fetch()](/docs/2.2/guides/endpoints#rpc)\\n  - If you were setting getUrl() before, you\'ll need to also override the [FetchShape.fetch()](/docs/2.2/api/FetchShape#fetchparams-param-body-payload-promise-any). getFetchKey() is only used as a lookup\\n  key in the results table cache. [FetchShape.fetch()](/docs/2.2/api/FetchShape#fetchparams-param-body-payload-promise-any)\\n  is responsible for constructing the actual url.\\n\\n- fetch(url: string, body: Body) -> fetch(params: Params, body: Body)\\n\\n#### Hook composition\\n\\nOne of the biggest benefits of hooks is enabling composition of behavior via isolation of\\nconcerns. Even the highest level hooks in Rest Hooks have always been simply compositions of\\nother lower level hooks. However, without clear use cases of reuse - these lower level hooks\\nsometimes crossed appropriate abstraction boundaries.\\n\\nOne of these cases is the `useError()` hook, which now returns an error if one is found or\\nundefined otherwise. Previously it had been throwing the error itself, which made it awkward\\nto use outside the context of Error Boundaries\\n(e.g., [useStatefulResource](/docs/2.2/guides/no-suspense#usestatefulresourcetsx)).\\n\\n### Featherweight bundles\\n\\nKeeping Rest Hooks bundle footprint small has been a conscious effort - enabled mostly\\nby clean modular design. Sometimes this has to be balanced with maximum compatibility.\\nKeeping this in mind, Rest Hooks will now leave polyfill loading up to the user. Instead\\nof importing the polyfills it needs from core-js directly, it will assume they are loaded.\\n**This means when using Rest Hooks 2.0 with the intent of IE compatibility - you will need\\nto ensure you are loading the appropriate polyfills yourself.**\\n\\nLeaving polyfills in the control of the application builder seems like the best practice\\nfor libraries. This also means an application can potentially only load polyfills if they\\nare needed.\\n\\n## Migration guide\\n\\nTo summarize:\\n\\n- RestProvider -> CacheProvider\\n- RequestShape -> FetchShape\\n- singleRequest() -> detailShape()\\n- listRequest() -> listShape()\\n- createRequest() -> createShape()\\n- updateRequest() -> updateShape()\\n- partialUpdateRequest() -> partialUpdateShape()\\n- deleteRequest() -> deleteShape()\\n- `<CacheProvider manager={myNetworkManager} subscriptionManager={mySubcriptionManager}>` -> `<CacheProvider managers={[myNetworkManager, mySubscriptionManager]}>`\\n- [FetchShape.getUrl() -> FetchShape.getFetchKey() + FetchShape.fetch()](/docs/2.2/guides/endpoints#rpc)\\n- FetchShape.fetch(url: string, body: Body) -> FetchShape.fetch(params: Params, body: Body)\\n- SchemaBase -> SchemaDetail; SchemaArray -> SchemaList\\n- useError() returns error instead of throwing\\n- Polyfills are not included automatically\\n\\n## What\'s next\\n\\nWhile an important milestone for Rest Hooks, work is far from over. We have some exciting\\nfeatures planned to be released soon. Here\'s a sneak peak of the \'soon\' lineup:\\n\\n- Garbage collection\\n- [Optimistic query update on create](https://github.com/coinbase/rest-hooks/issues/96)\\n- Automatic query batching\\n- Caching in Service Workers (PWA)\\n- Server Side Rendering guide\\n- Concurrent mode test suite\\n\\nWe\'re also experimenting with a CLI to generate [Resource](/docs/2.2/api/resource) stubs from OpenAPI\\nschemas.\\n\\nIf any of these ideas excite you, or you have ideas of your own for Rest Hooks, we encourage you\\nto share your feedback by [creating an issue](https://github.com/coinbase/rest-hooks/issues/new/choose)\\nor [contributing code](https://github.com/coinbase/rest-hooks/compare)."}]}')}}]);