(self.webpackChunk=self.webpackChunk||[]).push([[46324],{42714:n=>{n.exports="type AbstractInstanceType<T> = T extends {\n    prototype: infer U;\n} ? U : never;\ntype DenormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Denormalize<S[K]> : S[K];\n};\ntype DenormalizeNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? DenormalizeNullable<S[K]> : S[K];\n};\ntype NormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Normalize<S[K]> : S[K];\n};\ntype NormalizedNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? NormalizeNullable<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n    fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ntype DenormalizeNullableNestedSchema<S extends NestedSchemaClass> = keyof S['schema'] extends never ? S['prototype'] : string extends keyof S['schema'] ? S['prototype'] : S['prototype'] & {\n    [K in keyof S['schema']]: DenormalizeNullable<S['schema'][K]>;\n};\ntype DenormalizeReturnType<T> = T extends (input: any, unvisit: any) => [infer R, any, any] ? R : never;\ntype NormalizeReturnType<T> = T extends (...args: any) => infer R ? R : never;\ntype Denormalize<S> = S extends EntityInterface<infer U> ? U : S extends RecordClass ? AbstractInstanceType<S> : S extends SchemaClass ? DenormalizeReturnType<S['denormalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize<F>[] : S extends {\n    [K: string]: any;\n} ? DenormalizeObject<S> : S;\ntype DenormalizeNullable<S> = S extends EntityInterface<any> ? DenormalizeNullableNestedSchema<S> | undefined : S extends RecordClass ? DenormalizeNullableNestedSchema<S> : S extends SchemaClass ? DenormalizeReturnType<S['_denormalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? DenormalizeNullableObject<S> : S;\ntype Normalize<S> = S extends EntityInterface ? string : S extends RecordClass ? NormalizeObject<S['schema']> : S extends SchemaClass ? NormalizeReturnType<S['normalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Normalize<F>[] : S extends {\n    [K: string]: any;\n} ? NormalizeObject<S> : S;\ntype NormalizeNullable<S> = S extends EntityInterface ? string | undefined : S extends RecordClass ? NormalizedNullableObject<S['schema']> : S extends SchemaClass ? NormalizeReturnType<S['_normalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Normalize<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? NormalizedNullableObject<S> : S;\ninterface EntityMap<T = any> {\n    readonly [k: string]: EntityInterface<T>;\n}\n\n/**\n * Marks entity as deleted.\n * @see https://resthooks.io/rest/api/Delete\n */\ndeclare class Delete<E extends EntityInterface & {\n    process: any;\n}> implements SchemaClass$1 {\n    private _entity;\n    constructor(entity: E);\n    get key(): string;\n    normalize(input: any, parent: any, key: string | undefined, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): string | undefined;\n    infer(args: any, indexes: any, recurse: any): any;\n    denormalize(id: string, unvisit: UnvisitFunction): [denormalized: AbstractInstanceType<E>, found: boolean, suspend: boolean];\n    _denormalizeNullable(): [\n        AbstractInstanceType<E> | undefined,\n        boolean,\n        false\n    ];\n    _normalizeNullable(): string | undefined;\n    merge(existing: any, incoming: any): any;\n    useIncoming(existingMeta: {\n        date: number;\n        fetchedAt: number;\n    }, incomingMeta: {\n        date: number;\n        fetchedAt: number;\n    }, existing: any, incoming: any): boolean;\n}\n\n/**\n * Represents arrays\n * @see https://resthooks.io/rest/api/Array\n */\ndeclare class Array$1<S extends Schema = Schema> implements SchemaClass$1 {\n  constructor(\n    definition: S,\n    schemaAttribute?: S extends EntityMap<infer T>\n      ? keyof T | SchemaFunction<keyof S>\n      : undefined,\n  );\n\n  define(definition: Schema): void;\n  readonly isSingleSchema: S extends EntityMap ? false : true;\n  readonly schema: S;\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): (S extends EntityMap ? UnionResult<S> : Normalize<S>)[];\n\n  _normalizeNullable():\n    | (S extends EntityMap ? UnionResult<S> : Normalize<S>)[]\n    | undefined;\n\n  denormalize(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [\n    denormalized: (S extends EntityMap<infer T> ? T : Denormalize<S>)[],\n    found: boolean,\n    suspend: boolean,\n  ];\n\n  _denormalizeNullable(): [\n    (S extends EntityMap<infer T> ? T : Denormalize<S>)[] | undefined,\n    false,\n    boolean,\n  ];\n\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\n\n/**\n * Retrieves all entities in cache\n *\n * @see https://resthooks.io/rest/api/AllSchema\n */\ndeclare class All<\n  S extends EntityMap | EntityInterface = EntityMap | EntityInterface,\n> implements SchemaClass$1\n{\n  constructor(\n    definition: S,\n    schemaAttribute?: S extends EntityMap<infer T>\n      ? keyof T | SchemaFunction<keyof S>\n      : undefined,\n  );\n\n  define(definition: Schema): void;\n  readonly isSingleSchema: S extends EntityMap ? false : true;\n  readonly schema: S;\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): (S extends EntityMap ? UnionResult<S> : Normalize<S>)[];\n\n  _normalizeNullable():\n    | (S extends EntityMap ? UnionResult<S> : Normalize<S>)[]\n    | undefined;\n\n  denormalize(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [\n    denormalized: (S extends EntityMap<infer T> ? T : Denormalize<S>)[],\n    found: boolean,\n    suspend: boolean,\n  ];\n\n  _denormalizeNullable(): [\n    (S extends EntityMap<infer T> ? T : Denormalize<S>)[] | undefined,\n    false,\n    boolean,\n  ];\n\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n    entities: EntityTable,\n  ): any;\n}\n\n/**\n * Represents objects with statically known members\n * @see https://resthooks.io/rest/api/Object\n */\ndeclare class Object$1<O extends Record<string, any> = Record<string, Schema>>\n  implements SchemaClass$1\n{\n  constructor(definition: O);\n  define(definition: Schema): void;\n  readonly schema: O;\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): NormalizeObject<O>;\n\n  _normalizeNullable(): NormalizedNullableObject<O>;\n\n  denormalize(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [denormalized: DenormalizeObject<O>, found: boolean, suspend: boolean];\n\n  _denormalizeNullable(): [DenormalizeNullableObject<O>, false, boolean];\n\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\n\n/**\n * Represents polymorphic values.\n * @see https://resthooks.io/rest/api/Union\n */\ndeclare class Union<Choices extends EntityMap = any> implements SchemaClass$1 {\n  constructor(\n    definition: Choices,\n    schemaAttribute:\n      | keyof AbstractInstanceType<Choices[keyof Choices]>\n      | SchemaFunction<keyof Choices>,\n  );\n\n  define(definition: Schema): void;\n  inferSchema: SchemaAttributeFunction<Choices[keyof Choices]>;\n  getSchemaAttribute: SchemaFunction<keyof Choices>;\n  readonly schema: Choices;\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): UnionResult<Choices>;\n\n  _normalizeNullable(): UnionResult<Choices> | undefined;\n\n  denormalize(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [\n    denormalized: AbstractInstanceType<Choices[keyof Choices]>,\n    found: boolean,\n    suspend: boolean,\n  ];\n\n  _denormalizeNullable(): [\n    AbstractInstanceType<Choices[keyof Choices]> | undefined,\n    false,\n    boolean,\n  ];\n\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\n\n/**\n * Represents variably sized objects\n * @see https://resthooks.io/rest/api/Values\n */\ndeclare class Values<Choices extends Schema = any> implements SchemaClass$1 {\n  constructor(\n    definition: Choices,\n    schemaAttribute?: Choices extends EntityMap<infer T>\n      ? keyof T | SchemaFunction<keyof Choices>\n      : undefined,\n  );\n\n  define(definition: Schema): void;\n  readonly isSingleSchema: Choices extends EntityMap ? false : true;\n  inferSchema: SchemaAttributeFunction<\n    Choices extends EntityMap ? Choices[keyof Choices] : Choices\n  >;\n\n  getSchemaAttribute: Choices extends EntityMap\n    ? SchemaFunction<keyof Choices>\n    : false;\n\n  readonly schema: Choices;\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): Record<\n    string,\n    Choices extends EntityMap ? UnionResult<Choices> : Normalize<Choices>\n  >;\n\n  _normalizeNullable():\n    | Record<\n        string,\n        Choices extends EntityMap\n          ? UnionResult<Choices>\n          : NormalizeNullable<Choices>\n      >\n    | undefined;\n\n  denormalize(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [\n    denormalized: Record<\n      string,\n      Choices extends EntityMap<infer T> ? T : Denormalize<Choices>\n    >,\n    found: boolean,\n    suspend: boolean,\n  ];\n\n  _denormalizeNullable(): [\n    Record<\n      string,\n      Choices extends EntityMap<infer T>\n        ? T | undefined\n        : DenormalizeNullable<Choices>\n    >,\n    false,\n    boolean,\n  ];\n\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\n\ntype StrategyFunction<T> = (value: any, parent: any, key: string) => T;\ntype SchemaFunction<K = string> = (\n  value: any,\n  parent: any,\n  key: string,\n) => K;\ntype MergeFunction = (entityA: any, entityB: any) => any;\ntype SchemaAttributeFunction<S extends Schema> = (\n  value: any,\n  parent: any,\n  key: string,\n) => S;\n\ntype UnionResult<Choices extends EntityMap> = {\n  id: string;\n  schema: keyof Choices;\n};\ninterface SchemaClass$1<T = any, N = T | undefined>\n  extends SchemaSimple<T> {\n  // this is not an actual member, but is needed for the recursive NormalizeNullable<> type algo\n  _normalizeNullable(): any;\n  // this is not an actual member, but is needed for the recursive DenormalizeNullable<> type algo\n  _denormalizeNullable(): [N, boolean, boolean];\n}\n\ntype schema_d_Delete<E extends EntityInterface & {\n    process: any;\n}> = Delete<E>;\ndeclare const schema_d_Delete: typeof Delete;\ntype schema_d_EntityMap<T = any> = EntityMap<T>;\ntype schema_d_UnvisitFunction = UnvisitFunction;\ntype schema_d_All<S extends EntityMap | EntityInterface = EntityMap | EntityInterface> = All<S>;\ndeclare const schema_d_All: typeof All;\ntype schema_d_Union<Choices extends EntityMap = any> = Union<Choices>;\ndeclare const schema_d_Union: typeof Union;\ntype schema_d_Values<Choices extends Schema = any> = Values<Choices>;\ndeclare const schema_d_Values: typeof Values;\ntype schema_d_StrategyFunction<T> = StrategyFunction<T>;\ntype schema_d_SchemaFunction<K = string> = SchemaFunction<K>;\ntype schema_d_MergeFunction = MergeFunction;\ntype schema_d_SchemaAttributeFunction<S extends Schema> = SchemaAttributeFunction<S>;\ntype schema_d_UnionResult<Choices extends EntityMap> = UnionResult<Choices>;\ntype schema_d_EntityInterface<T = any> = EntityInterface<T>;\ndeclare namespace schema_d {\n  export {\n    schema_d_Delete as Delete,\n    schema_d_EntityMap as EntityMap,\n    schema_d_UnvisitFunction as UnvisitFunction,\n    Array$1 as Array,\n    schema_d_All as All,\n    Object$1 as Object,\n    schema_d_Union as Union,\n    schema_d_Values as Values,\n    schema_d_StrategyFunction as StrategyFunction,\n    schema_d_SchemaFunction as SchemaFunction,\n    schema_d_MergeFunction as MergeFunction,\n    schema_d_SchemaAttributeFunction as SchemaAttributeFunction,\n    schema_d_UnionResult as UnionResult,\n    SchemaClass$1 as SchemaClass,\n    schema_d_EntityInterface as EntityInterface,\n  };\n}\n\ninterface NetworkError$1 extends Error {\n    status: number;\n    response?: Response;\n}\ninterface UnknownError extends Error {\n    status?: unknown;\n    response?: unknown;\n}\ntype ErrorTypes = NetworkError$1 | UnknownError;\n\ninterface SnapshotInterface {\n    getResponse: <E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => {\n        data: DenormalizeNullable<E['schema']>;\n        expiryStatus: ExpiryStatusInterface;\n        expiresAt: number;\n    };\n    getError: <E extends Pick<EndpointInterface, 'key'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => ErrorTypes | undefined;\n    readonly fetchedAt: number;\n}\ntype ExpiryStatusInterface = 1 | 2 | 3;\n\n/** Get the Params type for a given Shape */\ntype EndpointParam<E> = E extends (first: infer A, ...rest: any) => any ? A : E extends {\n    key: (first: infer A, ...rest: any) => any;\n} ? A : never;\n/** What the function's promise resolves to */\ntype ResolveType<E extends (...args: any) => any> = ReturnType<E> extends Promise<infer R> ? R : never;\ntype PartialArray<A> = A extends [] ? [] : A extends [infer F] ? [F] | [] : A extends [infer F, ...infer Rest] ? [F] | [F, ...PartialArray<Rest>] : A extends (infer T)[] ? T[] : never;\n\ntype FetchFunction<A extends readonly any[] = any, R = any> = (...args: A) => Promise<R>;\n/** @deprecated */\ntype SchemaDetail<T> = EntityInterface<T> | {\n    [K: string]: any;\n} | SchemaClass$1;\n/** @deprecated */\ntype SchemaList<T> = EntityInterface<T>[] | {\n    [K: string]: any;\n} | Schema[] | SchemaClass$1;\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n    /** Default data expiry length, will fall back to NetworkManager default if not defined */\n    readonly dataExpiryLength?: number;\n    /** Default error expiry length, will fall back to NetworkManager default if not defined */\n    readonly errorExpiryLength?: number;\n    /** Poll with at least this frequency in miliseconds */\n    readonly pollFrequency?: number;\n    /** Marks cached resources as invalid if they are stale */\n    readonly invalidIfStale?: boolean;\n    /** Enables optimistic updates for this request - uses return value as assumed network response\n     * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n     */\n    optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n    /** Enables optimistic updates for this request - uses return value as assumed network response */\n    getOptimisticResponse?(snap: SnapshotInterface, ...args: Parameters<F>): ResolveType<F>;\n    /** Determines whether to throw or fallback to */\n    errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n    /** User-land extra data to send */\n    readonly extra?: any;\n}\n\ntype Schema = null | string | {\n    [K: string]: any;\n} | Schema[] | SchemaSimple | Serializable;\ntype Serializable<T extends {\n    toJSON(): string;\n} = {\n    toJSON(): string;\n}> = {\n    prototype: T;\n};\ninterface SchemaSimple<T = any> {\n    normalize(input: any, parent: any, key: any, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    denormalize(input: {}, unvisit: UnvisitFunction): [denormalized: T, found: boolean, suspend: boolean];\n    infer(args: readonly any[], indexes: NormalizedIndex, recurse: (...args: any) => any, entities: EntityTable): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n    _normalizeNullable(): any;\n    _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n    pk(params: any, parent?: any, key?: string): string | undefined;\n    readonly key: string;\n    merge(existing: any, incoming: any): any;\n    expiresAt?(meta: any, input: any): number;\n    useIncoming?(existingMeta: any, incomingMeta: any, existing: any, incoming: any): boolean;\n    indexes?: any;\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface UnvisitFunction {\n    (input: any, schema: any): [any, boolean, boolean];\n    og?: UnvisitFunction;\n    setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n    readonly [entityKey: string]: {\n        readonly [indexName: string]: {\n            readonly [lookup: string]: string;\n        };\n    };\n}\ninterface EntityTable {\n    [entityKey: string]: {\n        [pk: string]: unknown;\n    } | undefined;\n}\n/** Defines a networking endpoint */\ninterface EndpointInterface<F extends FetchFunction = FetchFunction, S extends Schema | undefined = Schema | undefined, M extends true | undefined = true | undefined> extends EndpointExtraOptions<F> {\n    (...args: Parameters<F>): ReturnType<F>;\n    key(...args: Parameters<F>): string;\n    readonly sideEffect?: M;\n    readonly schema?: S;\n}\n/** For retrieval requests */\ntype ReadEndpoint<F extends FetchFunction = FetchFunction, S extends Schema | undefined = Schema | undefined> = EndpointInterface<F, S, undefined>;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\ninterface EndpointOptions<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = undefined,\n  M extends true | undefined = undefined,\n> extends EndpointExtraOptions<F> {\n  key?: (...args: Parameters<F>) => string;\n  sideEffect?: M;\n  schema?: S;\n  [k: string]: any;\n}\n\ninterface EndpointExtendOptions<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointOptions<F, S, M> {\n  fetch?: FetchFunction;\n}\n\ntype KeyofEndpointInstance = keyof EndpointInstance<FetchFunction>;\n\ntype ExtendedEndpoint<\n  O extends EndpointExtendOptions<F>,\n  E extends EndpointInstance<\n    FetchFunction,\n    Schema | undefined,\n    true | undefined\n  >,\n  F extends FetchFunction,\n> = EndpointInstance<\n  'fetch' extends keyof O ? Exclude<O['fetch'], undefined> : E['fetch'],\n  'schema' extends keyof O ? O['schema'] : E['schema'],\n  'sideEffect' extends keyof O ? O['sideEffect'] : E['sideEffect']\n> &\n  Omit<O, KeyofEndpointInstance> &\n  Omit<E, KeyofEndpointInstance>;\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstance<\n  F extends (...args: any) => Promise<any> = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInstanceInterface<F, S, M> {\n  extend<\n    E extends EndpointInstance<\n      (...args: any) => Promise<any>,\n      Schema | undefined,\n      true | undefined\n    >,\n    O extends EndpointExtendOptions<F> &\n      Partial<Omit<E, keyof EndpointInstance<FetchFunction>>> &\n      Record<string, unknown>,\n  >(\n    this: E,\n    options: Readonly<O>,\n  ): ExtendedEndpoint<typeof options, E, F>;\n}\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstanceInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInterface<F, S, M> {\n  constructor: EndpointConstructor;\n\n  /**\n   * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n   * @param thisArg The object to be used as the this object.\n   * @param argArray A set of arguments to be passed to the function.\n   */\n  apply<E extends FetchFunction>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    argArray?: Parameters<E>,\n  ): ReturnType<E>;\n\n  /**\n   * Calls a method of an object, substituting another object for the current object.\n   * @param thisArg The object to be used as the current object.\n   * @param argArray A list of arguments to be passed to the method.\n   */\n  call<E extends FetchFunction>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...argArray: Parameters<E>\n  ): ReturnType<E>;\n\n  /**\n   * For a given function, creates a bound function that has the same body as the original function.\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n   * @param thisArg An object to which the this keyword can refer inside the new function.\n   * @param argArray A list of arguments to be passed to the new function.\n   */\n  bind<E extends FetchFunction, P extends PartialArray<Parameters<E>>>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...args: readonly [...P]\n  ): EndpointInstance<\n    (...args: readonly [...RemoveArray<Parameters<E>, P>]) => ReturnType<E>,\n    S,\n    M\n  > &\n    Omit<E, keyof EndpointInstance<FetchFunction>>;\n\n  /** Returns a string representation of a function. */\n  toString(): string;\n\n  prototype: any;\n  readonly length: number;\n\n  // Non-standard extensions\n  arguments: any;\n  caller: F;\n\n  key(...args: Parameters<F>): string;\n\n  readonly sideEffect: M;\n\n  readonly schema: S;\n\n  fetch: F;\n\n  /** The following is for compatibility with FetchShape */\n  /** @deprecated */\n  readonly type: M extends undefined\n    ? 'read'\n    : IfAny<M, any, IfTypeScriptLooseNull<'read', 'mutate'>>;\n\n  /** @deprecated */\n  getFetchKey(...args: OnlyFirst<Parameters<F>>): string;\n  /** @deprecated */\n  options?: EndpointExtraOptions<F>;\n}\n\ninterface EndpointConstructor {\n  new <\n    F extends (\n      this: EndpointInstance<FetchFunction> & E,\n      params?: any,\n      body?: any,\n    ) => Promise<any>,\n    S extends Schema | undefined = undefined,\n    M extends true | undefined = undefined,\n    E extends Record<string, any> = {},\n  >(\n    fetchFunction: F,\n    options?: EndpointOptions<F, S, M> & E,\n  ): EndpointInstance<F, S, M> & E;\n  readonly prototype: Function;\n}\ndeclare let Endpoint: EndpointConstructor;\n\n\ninterface ExtendableEndpointConstructor {\n  new <\n    F extends (\n      this: EndpointInstanceInterface<FetchFunction> & E,\n      params?: any,\n      body?: any,\n    ) => Promise<any>,\n    S extends Schema | undefined = undefined,\n    M extends true | undefined = undefined,\n    E extends Record<string, any> = {},\n  >(\n    RestFetch: F,\n    options?: Readonly<EndpointOptions<F, S, M>> & E,\n  ): EndpointInstanceInterface<F, S, M> & E;\n  readonly prototype: Function;\n}\ndeclare let ExtendableEndpoint: ExtendableEndpointConstructor;\n\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\ntype IfTypeScriptLooseNull<Y, N> = 1 | undefined extends 1 ? Y : N;\n\ntype OnlyFirst<A extends unknown[]> = A extends [] ? [] : [A[0]];\n\ntype RemoveArray<Orig extends any[], Rem extends any[]> = Rem extends [\n  any,\n  ...infer RestRem,\n]\n  ? Orig extends [any, ...infer RestOrig]\n    ? RemoveArray<RestOrig, RestRem>\n    : never\n  : Orig;\n\n/**\n * Represents data that should be deduped by specifying a primary key.\n * @see https://resthooks.io/docs/api/Entity\n */\ndeclare abstract class Entity {\n    static toJSON(): {\n        name: string;\n        schema: {\n            [k: string]: Schema;\n        };\n        key: string;\n    };\n    /** Defines nested entities */\n    static schema: {\n        [k: string]: Schema;\n    };\n    /**\n     * A unique identifier for each Entity\n     *\n     * @param [parent] When normalizing, the object which included the entity\n     * @param [key] When normalizing, the key where this entity was found\n     */\n    abstract pk(parent?: any, key?: string): string | undefined;\n    /** Returns the globally unique identifier for the static Entity */\n    static get key(): string;\n    /** Defines indexes to enable lookup by */\n    static indexes?: readonly string[];\n    /** Control how automatic schema validation is handled\n     *\n     * `undefined`: Defaults - throw error in worst offense\n     * 'warn': only ever warn\n     * 'silent': Don't bother with processing at all\n     *\n     * Note: this only applies to non-nested members.\n     */\n    protected static automaticValidation?: 'warn' | 'silent';\n    /**\n     * A unique identifier for each Entity\n     *\n     * @param [value] POJO of the entity or subset used\n     * @param [parent] When normalizing, the object which included the entity\n     * @param [key] When normalizing, the key where this entity was found\n     */\n    static pk<T extends typeof Entity>(this: T, value: Partial<AbstractInstanceType<T>>, parent?: any, key?: string): string | undefined;\n    /** Return true to merge incoming data; false keeps existing entity */\n    static useIncoming(existingMeta: {\n        date: number;\n        fetchedAt: number;\n    }, incomingMeta: {\n        date: number;\n        fetchedAt: number;\n    }, existing: any, incoming: any): boolean;\n    /** Creates new instance copying over defined values of arguments */\n    static merge(existing: any, incoming: any): any;\n    /** Factory method to convert from Plain JS Objects.\n     *\n     * @param [props] Plain Object of properties to assign.\n     * @param [parent] When normalizing, the object which included the record\n     * @param [key] When normalizing, the key where this record was found\n     */\n    static fromJS<T extends typeof Entity>(this: T, props?: Partial<AbstractInstanceType<T>>): AbstractInstanceType<T>;\n    /** Do any transformations when first receiving input */\n    static process(input: any, parent: any, key: string | undefined): any;\n    static normalize(input: any, parent: any, key: string | undefined, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    protected static validate(processedEntity: any): string | undefined;\n    static infer(args: readonly any[], indexes: NormalizedIndex, recurse: any): any;\n    static expiresAt(meta: {\n        expiresAt: number;\n        date: number;\n        fetchedAt: number;\n    }, input: any): number;\n    static denormalize<T extends typeof Entity>(this: T, input: any, unvisit: UnvisitFunction): [denormalized: AbstractInstanceType<T>, found: boolean, suspend: boolean];\n    private static __defaults;\n    /** All instance defaults set */\n    protected static get defaults(): any;\n    /** Used by denormalize to set nested members */\n    protected static set(entity: any, key: string, value: any): void;\n}\n\ndeclare function validateRequired(processedEntity: any, requiredDefaults: Record<string, unknown>): string | undefined;\n\ndeclare const DELETED: unique symbol;\n\n/**\n * Performant lookups by secondary indexes\n * @see https://resthooks.io/docs/api/Index\n */\ndeclare class Index<S extends Schema, P = Readonly<IndexParams<S>>> {\n    schema: S;\n    constructor(schema: S, key?: (params: P) => string);\n    key(params?: P): string;\n    /** The following is for compatibility with FetchShape */\n    getFetchKey: (params: P) => string;\n}\ntype ArrayElement<ArrayType extends unknown[] | readonly unknown[]> = ArrayType[number];\ntype IndexParams<S extends Schema> = S extends {\n    indexes: readonly string[];\n} ? {\n    [K in Extract<ArrayElement<S['indexes']>, keyof AbstractInstanceType<S>>]?: AbstractInstanceType<S>[K];\n} : Readonly<object>;\n\n/**\n * Programmatic cache reading\n * @see https://resthooks.io/rest/api/Query\n */\ndeclare class Query<S extends SchemaSimple, P extends any[] = []> {\n    schema: S;\n    process: (entries: Denormalize<S>, ...args: P) => Denormalize<S>;\n    readonly sideEffect: undefined;\n    constructor(schema: S, process?: (entries: Denormalize<S>, ...args: P) => Denormalize<S>);\n    key(...args: P): string;\n    protected createQuerySchema(schema: SchemaSimple): any;\n}\n\ndeclare class AbortOptimistic extends Error {\n}\n\ntype OnlyOptional<S extends string> = S extends `${infer K}?` ? K : never;\ntype OnlyRequired<S extends string> = S extends `${string}?` ? never : S;\n/** Computes the union of keys for a path string */\ntype PathKeys<S extends string> = string extends S ? string : S extends `${infer A}\\\\:${infer B}` ? PathKeys<A> | PathKeys<B> : S extends `${infer A}\\\\?${infer B}` ? PathKeys<A> | PathKeys<B> : PathSplits<S>;\ntype PathSplits<S extends string> = S extends `${string}:${infer K}/${infer R}` ? PathSplits<`:${K}`> | PathSplits<R> : S extends `${string}:${infer K}:${infer R}` ? PathSplits<`:${K}`> | PathSplits<`:${R}`> : S extends `${string}:${infer K}` ? K : never;\n/** Parameters for a given path */\ntype PathArgs<S extends string> = PathKeys<S> extends never ? unknown : KeysToArgs<PathKeys<S>>;\ntype KeysToArgs<Key extends string> = {\n    [K in Key as OnlyOptional<K>]?: string | number;\n} & {\n    [K in Key as OnlyRequired<K>]: string | number;\n};\ntype PathArgsAndSearch<S extends string> = OnlyRequired<PathKeys<S>> extends never ? Record<string, number | string | boolean> | undefined : {\n    [K in PathKeys<S> as OnlyRequired<K>]: string | number;\n} & Record<string, number | string>;\n/** Removes the last :token */\ntype ShortenPath<S extends string> = string extends S ? string : S extends `${infer B}:${infer R}` ? TrimColon<`${B}:${ShortenPath<R>}`> : '';\ntype TrimColon<S extends string> = string extends S ? string : S extends `${infer R}:` ? R : S;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\ninterface RestInstance<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = any,\n  M extends true | undefined = true | undefined,\n> extends EndpointInstanceInterface<F, S, M> {\n  /** Pattern to construct url based on Url Parameters\n   * @see https://resthooks.io/rest/api/RestEndpoint#path\n   */\n  readonly path: string;\n  /** Prepended to all urls\n   * @see https://resthooks.io/rest/api/RestEndpoint#urlPrefix\n   */\n  readonly urlPrefix: string;\n  readonly requestInit: RequestInit;\n  readonly method: string;\n  readonly signal: AbortSignal | undefined;\n\n  /* fetch lifecycles */\n  /* before-fetch */\n  url(...args: Parameters<F>): string;\n  /** @see https://resthooks.io/rest/api/RestEndpoint#getRequestInit */\n  getRequestInit(\n    this: any,\n    body?: RequestInit['body'] | Record<string, unknown>,\n  ): RequestInit;\n  /** @see https://resthooks.io/rest/api/RestEndpoint#getHeaders */\n  getHeaders(headers: HeadersInit): HeadersInit;\n  /* after-fetch */\n  /** @see https://resthooks.io/rest/api/RestEndpoint#fetchResponse */\n  fetchResponse(input: RequestInfo, init: RequestInit): Promise<Response>;\n  /** @see https://resthooks.io/rest/api/RestEndpoint#parseResponse */\n  parseResponse(response: Response): Promise<any>;\n  /** @see https://resthooks.io/rest/api/RestEndpoint#process */\n  process(value: any, ...args: Parameters<F>): ResolveType<F>;\n\n  /* extenders */\n  paginated<\n    E extends RestInstance<FetchFunction, Schema | undefined, undefined>,\n    A extends any[],\n  >(\n    this: E,\n    removeCursor: (...args: A) => readonly [...Parameters<E>],\n  ): PaginationEndpoint<E, A>;\n  extend<E extends RestInstance, O extends PartialRestGenerics | {}>(\n    this: E,\n    options: Readonly<RestEndpointExtendOptions<O, E, F> & O>,\n  ): RestExtendedEndpoint<O, E>;\n}\n\ntype RestEndpointExtendOptions<\n  O extends PartialRestGenerics | {},\n  E extends RestInstance,\n  F extends FetchFunction,\n> = RestEndpointOptions<OptionsToFunction<O, E, F>> &\n  Partial<Omit<E, keyof RestInstance>>;\n\ntype OptionsToFunction<\n  O extends PartialRestGenerics,\n  E extends RestInstance,\n  F extends FetchFunction,\n> = 'path' extends keyof O\n  ? RestType<\n      'searchParams' extends keyof O\n        ? O['searchParams'] & PathArgs<Exclude<O['path'], undefined>>\n        : PathArgs<Exclude<O['path'], undefined>>,\n      'body' extends keyof O ? O['body'] : undefined,\n      'schema' extends keyof O ? O['schema'] : E['schema'],\n      'method' extends keyof O ? MethodToSide<O['method']> : E['sideEffect'],\n      O['process'] extends {} ? ReturnType<O['process']> : ResolveType<F>\n    >\n  : 'body' extends keyof O\n  ? RestType<\n      UrlParamsFromFunction<Parameters<E>>,\n      O['body'],\n      'schema' extends keyof O ? O['schema'] : E['schema'],\n      'method' extends keyof O ? MethodToSide<O['method']> : E['sideEffect'],\n      O['process'] extends {} ? ReturnType<O['process']> : ResolveType<F>\n    >\n  : F;\ntype UrlParamsFromFunction<Args extends any[]> = 1 extends keyof Args\n  ? Args[0]\n  : undefined;\n\ntype RestExtendedEndpoint<\n  O extends PartialRestGenerics,\n  E extends RestInstance,\n> = OptionsToFunction<\n  O,\n  E,\n  RestInstance<\n    (\n      ...args: Parameters<E>\n    ) => O['process'] extends {}\n      ? Promise<ReturnType<O['process']>>\n      : ReturnType<E>,\n    'schema' extends keyof O ? O['schema'] : E['schema'],\n    'method' extends keyof O ? MethodToSide<O['method']> : E['sideEffect']\n  >\n> &\n  Omit<O, KeyofRestEndpoint | 'body' | 'searchParams'> &\n  Omit<E, KeyofRestEndpoint>;\n\ninterface PartialRestGenerics {\n  readonly path?: string;\n  readonly schema?: Schema | undefined;\n  readonly method?: string;\n  /** Only used for types */\n  readonly body?: any;\n  /** Only used for types */\n  readonly searchParams?: any;\n  /** @see https://resthooks.io/rest/api/RestEndpoint#process */\n  process?(value: any, ...args: any): any;\n}\ninterface RestGenerics extends PartialRestGenerics {\n  readonly path: string;\n}\n\ntype PaginationEndpoint<\n  E extends RestInstance,\n  A extends any[],\n> = RestInstance<\n  ParamFetchNoBody<A[0], ResolveType<E>>,\n  E['schema'],\n  E['sideEffect']\n>;\n\ntype BodyDefault<O extends RestGenerics> = 'body' extends keyof O\n  ? O['body']\n  : O['method'] extends 'POST' | 'PUT' | 'PATCH'\n  ? Record<string, unknown> | FormData\n  : undefined;\n\ninterface RestEndpointOptions<F extends FetchFunction = FetchFunction>\n  extends EndpointExtraOptions<F> {\n  fetch?: F;\n  urlPrefix?: string;\n  requestInit?: RequestInit;\n  key?(...args: Parameters<F>): string;\n  sideEffect?: true | undefined;\n  name?: string;\n  signal?: AbortSignal;\n  url?(...args: Parameters<F>): string;\n  getHeaders?(headers: HeadersInit): HeadersInit;\n  getRequestInit?(body: any): RequestInit;\n  fetchResponse?(input: RequestInfo, init: RequestInit): Promise<any>;\n  parseResponse?(response: Response): Promise<any>;\n  update?(...args: any): any;\n}\n\ntype RestEndpointConstructorOptions<O extends RestGenerics = any> =\n  RestEndpointOptions<\n    RestFetch<\n      'searchParams' extends keyof O\n        ? O['searchParams'] & PathArgs<O['path']>\n        : PathArgs<O['path']>,\n      BodyDefault<O>,\n      O['process'] extends {}\n        ? ReturnType<O['process']>\n        : any /*Denormalize<O['schema']>*/\n    >\n  >;\n\ninterface RestEndpointConstructor {\n  new <O extends RestGenerics = any>({\n    method,\n    sideEffect,\n    name,\n    ...options\n  }: Readonly<RestEndpointConstructorOptions<O> & O>): RestInstance<\n    RestFetch<\n      'searchParams' extends keyof O\n        ? O['searchParams'] & PathArgs<O['path']>\n        : PathArgs<O['path']>,\n      BodyDefault<O>,\n      O['process'] extends {}\n        ? ReturnType<O['process']>\n        : any /*Denormalize<O['schema']>*/\n    >,\n    O['schema'] extends Schema | undefined ? O['schema'] : undefined,\n    MethodToSide<O['method']>\n  >;\n  readonly prototype: RestInstance;\n}\n/** Simplifies endpoint definitions that follow REST patterns\n *\n * @see https://resthooks.io/rest/api/RestEndpoint\n */\ndeclare let RestEndpoint: RestEndpointConstructor;\n\n\ntype MethodToSide<M> = M extends string\n  ? M extends 'GET'\n    ? undefined\n    : true\n  : undefined;\n\n/** RestEndpoint types simplified */\ntype RestType<\n  UrlParams = any,\n  Body = any,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n  R = any,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n> = Body extends {}\n  ? RestTypeWithBody<UrlParams, S, M, Body, R>\n  : RestTypeNoBody<UrlParams, S, M, R>;\n\ntype RestTypeWithBody<\n  UrlParams = any,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n  Body extends BodyInit | Record<string, any> = any,\n  R = any /*Denormalize<S>*/,\n> = RestInstance<ParamFetchWithBody<UrlParams, Body, R>, S, M>;\n\ntype RestTypeNoBody<\n  UrlParams = any,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n  R = any /*Denormalize<S>*/,\n> = RestInstance<ParamFetchNoBody<UrlParams, R>, S, M>;\n\n/** Simple parameters, and body fetch functions */\ntype RestFetch<\n  UrlParams,\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Body = {},\n  Resolve = any,\n> = Body extends Record<string, unknown>\n  ? ParamFetchWithBody<UrlParams, Body, Resolve>\n  : ParamFetchNoBody<UrlParams, Resolve>;\n\ntype ParamFetchWithBody<\n  P,\n  B extends {} = {},\n  R = any,\n> = keyof P extends undefined\n  ? (this: EndpointInstanceInterface, body: B) => Promise<R>\n  : undefined extends P\n  ? (this: EndpointInstanceInterface, body: B) => Promise<R>\n  : (this: EndpointInstanceInterface, params: P, body: B) => Promise<R>;\n\ntype ParamFetchNoBody<P, R = any> = /*string extends keyof P\n  ? (this: EndpointInstanceInterface, params?: P) => Promise<R>\n  :*/ P extends undefined\n  ? (this: EndpointInstanceInterface) => Promise<R>\n  : undefined extends P\n  ? (this: EndpointInstanceInterface) => Promise<R>\n  : (this: EndpointInstanceInterface, params: P) => Promise<R>;\n\ntype KeyofRestEndpoint = keyof RestInstance;\n\ntype FetchMutate<\n  A extends readonly any[] =  // eslint-disable-next-line @typescript-eslint/ban-types\n    | [any, {}]\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    | [{}],\n  R = any,\n> = (this: RestInstance, ...args: A) => Promise<R>;\n\ntype FetchGet<A extends readonly any[] = [any], R = any> = (\n  this: RestInstance,\n  ...args: A\n) => Promise<R>;\n\ntype GetEndpoint<\n  UrlParams = any,\n  S extends Schema | undefined = Schema | undefined,\n> = RestTypeNoBody<UrlParams, S, undefined>;\n\ntype MutateEndpoint<\n  UrlParams = any,\n  Body extends BodyInit | Record<string, any> = any,\n  S extends Schema | undefined = Schema | undefined,\n> = RestTypeWithBody<UrlParams, S, true, Body>;\n\ntype Defaults<O, D> = {\n  [K in keyof O | keyof D]: K extends keyof O\n    ? Exclude<O[K], undefined>\n    : D[Extract<K, keyof D>];\n};\n\n/** Creates collection of Endpoints for common operations on a given data/schema.\n *\n * @see https://resthooks.io/rest/api/createResource\n */\ndeclare function createResource<U extends string, S extends Schema>({ path, schema, Endpoint, ...extraOptions }: {\n    readonly path: U;\n    readonly schema: S;\n    readonly Endpoint?: typeof RestEndpoint;\n    urlPrefix?: string;\n} & EndpointExtraOptions): Resource<U, S>;\ninterface Resource<U extends string, S extends Schema> {\n    /** Get a singular item\n     *\n     * @see https://resthooks.io/rest/api/createResource#get\n     */\n    get: GetEndpoint<PathArgs<U>, S>;\n    /** Get a list of item\n     *\n     * @see https://resthooks.io/rest/api/createResource#getlist\n     */\n    getList: GetEndpoint<PathArgsAndSearch<ShortenPath<U>>, S[]>;\n    /** Create a new item (POST)\n     *\n     * @see https://resthooks.io/rest/api/createResource#create\n     */\n    create: MutateEndpoint<PathArgs<ShortenPath<U>>, Partial<Denormalize<S>>, S>;\n    /** Update an item (PUT)\n     *\n     * @see https://resthooks.io/rest/api/createResource#update\n     */\n    update: MutateEndpoint<PathArgs<U>, Partial<Denormalize<S>>, S>;\n    /** Update an item (PATCH)\n     *\n     * @see https://resthooks.io/rest/api/createResource#partialupdate\n     */\n    partialUpdate: MutateEndpoint<PathArgs<U>, Partial<Denormalize<S>>, S>;\n    /** Delete an item (DELETE)\n     *\n     * @see https://resthooks.io/rest/api/createResource#delete\n     */\n    delete: RestTypeNoBody<PathArgs<U>, S extends EntityInterface & {\n        process: any;\n    } ? Delete<S> : S, undefined, Partial<PathArgs<U>>>;\n}\n\ninterface HookableEndpointInterface extends EndpointInterface {\n    extend(...args: any): HookableEndpointInterface;\n}\n/** Turns a collection of Endpoints (Resource) into a collection of hooks.\n * This is useful for Endpoints that need hooks to prepare their fetch requests.\n *\n * @see https://resthooks.io/rest/api/hookifyResource\n */\ndeclare function hookifyResource<R extends Record<string, HookableEndpointInterface>>(resource: R, useRequestInit: () => RequestInit): HookResource<R>;\ntype HookResource<R extends Record<string, HookableEndpointInterface>> = {\n    [K in Extract<keyof R, string> as `use${Capitalize<K>}`]: () => R[K];\n};\n\n/** An error with a Rest Endpoint fetch\n *\n * @see https://resthooks.io/rest/api/NetworkError\n */\ndeclare class NetworkError extends Error {\n    status: number;\n    response: Response;\n    name: string;\n    constructor(response: Response);\n}\n\ndeclare function paginationUpdate<E extends {\n    schema: Schema;\n    key: any;\n} & ((...args: any) => Promise<any>), A extends any[]>(endpoint: E, removeCursor: (...args: A) => readonly [...Parameters<typeof endpoint>]): (newPage: any, ...args: A) => {\n    [x: number]: (existing: any) => any;\n};\n\nexport { AbortOptimistic, AbstractInstanceType, ArrayElement, DELETED, Defaults, Denormalize, DenormalizeNullable, Endpoint, EndpointExtendOptions, EndpointExtraOptions, EndpointInstance, EndpointInstanceInterface, EndpointInterface, EndpointOptions, EndpointParam, Entity, ErrorTypes, ExpiryStatusInterface, ExtendableEndpoint, FetchFunction, FetchGet, FetchMutate, GetEndpoint, HookResource, HookableEndpointInterface, Index, IndexParams, KeyofEndpointInstance, KeyofRestEndpoint, MutateEndpoint, NetworkError, Normalize, NormalizeNullable, PathArgs, PathKeys, Query, ReadEndpoint, ResolveType, Resource, RestEndpoint, RestEndpointConstructorOptions, RestFetch, RestGenerics, RestType, Schema, SchemaDetail, SchemaList, ShortenPath, SnapshotInterface, UnknownError, createResource, hookifyResource, paginationUpdate, schema_d as schema, validateRequired };\n"}}]);