(self.webpackChunk=self.webpackChunk||[]).push([[97359],{61019:e=>{e.exports="import * as _rest_hooks_core from '@rest-hooks/core';\nimport { Manager, State as State$1, Controller, NetworkError as NetworkError$1, ActionTypes, DenormalizeCache, legacyActions, __INTERNAL__, createReducer, applyManager } from '@rest-hooks/core';\nexport { AbstractInstanceType, ActionTypes, Controller, DefaultConnectionListener, Denormalize, DenormalizeNullable, DevToolsManager, Dispatch, EndpointExtraOptions, EndpointInterface, ExpiryStatus, FetchAction, FetchFunction, InvalidateAction, LogoutManager, Manager, Middleware, MiddlewareAPI, NetworkError, NetworkManager, Normalize, NormalizeNullable, PK, PollingSubscription, ReceiveAction, ReceiveTypes, ResetAction, ResolveType, Schema, State, SubscribeAction, SubscriptionManager, UnknownError, UnsubscribeAction, UpdateFunction, actionTypes } from '@rest-hooks/core';\nimport React$1, { Context } from 'react';\n\ndeclare const _default$1: React$1.NamedExoticComponent<{\n    children: React$1.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\ninterface ProviderProps {\n    children: React$1.ReactNode;\n    managers: Manager[];\n    initialState: State$1<unknown>;\n    Controller: typeof Controller;\n}\n/**\n * Manages state, providing all context needed to use the hooks.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({ children, managers, initialState, Controller, }: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n    var defaultProps: {\n        managers: Manager<_rest_hooks_core.CombinedActionTypes>[];\n        initialState: State$1<unknown>;\n        Controller: typeof Controller;\n    };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\n/**\n * Handles loading and error conditions of Suspense\n * @see https://resthooks.io/docs/api/AsyncBoundary\n */\ndeclare function AsyncBoundary({ children, errorComponent, fallback, }: {\n    children: React$1.ReactNode;\n    fallback?: React$1.ReactNode;\n    errorComponent?: React$1.ComponentType<{\n        error: NetworkError$1;\n    }>;\n}): JSX.Element;\ndeclare const _default: React$1.MemoExoticComponent<typeof AsyncBoundary>;\n//# sourceMappingURL=AsyncBoundary.d.ts.map\n\ninterface Props<E extends NetworkError$1> {\n    children: React$1.ReactNode;\n    fallbackComponent: React$1.ComponentType<{\n        error: E;\n    }>;\n}\ninterface State<E extends NetworkError$1> {\n    error?: E;\n}\n/**\n * Handles any networking errors from suspense\n * @see https://resthooks.io/docs/api/NetworkErrorBoundary\n */\ndeclare class NetworkErrorBoundary<E extends NetworkError$1> extends React$1.Component<Props<E>, State<E>> {\n    static defaultProps: {\n        fallbackComponent: ({ error }: {\n            error: NetworkError$1;\n        }) => JSX.Element;\n    };\n    static getDerivedStateFromError(error: NetworkError$1 | any): {\n        error: NetworkError$1;\n    };\n    state: State<E>;\n    render(): JSX.Element;\n}\n\ntype Schema = null | string | {\n    [K: string]: any;\n} | Schema[] | SchemaSimple | Serializable;\ntype Serializable<T extends {\n    toJSON(): string;\n} = {\n    toJSON(): string;\n}> = {\n    prototype: T;\n};\ninterface SchemaSimple<T = any> {\n    normalize(input: any, parent: any, key: any, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    denormalize(input: {}, unvisit: UnvisitFunction): [denormalized: T, found: boolean, suspend: boolean];\n    infer(args: readonly any[], indexes: NormalizedIndex, recurse: (...args: any) => any, entities: EntityTable): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n    _normalizeNullable(): any;\n    _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n    pk(params: any, parent?: any, key?: string): string | undefined;\n    readonly key: string;\n    merge(existing: any, incoming: any): any;\n    expiresAt?(meta: any, input: any): number;\n    useIncoming?(existingMeta: any, incomingMeta: any, existing: any, incoming: any): boolean;\n    indexes?: any;\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface UnvisitFunction {\n    (input: any, schema: any): [any, boolean, boolean];\n    og?: UnvisitFunction;\n    setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n    readonly [entityKey: string]: {\n        readonly [indexName: string]: {\n            readonly [lookup: string]: string;\n        };\n    };\n}\ninterface EntityTable {\n    [entityKey: string]: {\n        [pk: string]: unknown;\n    } | undefined;\n}\n\ntype AbstractInstanceType<T> = T extends {\n    prototype: infer U;\n} ? U : never;\ntype DenormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ntype DenormalizeNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n    fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ntype DenormalizeNullableNestedSchema<S extends NestedSchemaClass> = keyof S['schema'] extends never ? S['prototype'] : string extends keyof S['schema'] ? S['prototype'] : S['prototype'];\ntype DenormalizeReturnType<T> = T extends (input: any, unvisit: any) => [infer R, any, any] ? R : never;\ntype Denormalize$1<S> = S extends EntityInterface<infer U> ? U : S extends RecordClass ? AbstractInstanceType<S> : S extends SchemaClass ? DenormalizeReturnType<S['denormalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] : S extends {\n    [K: string]: any;\n} ? DenormalizeObject<S> : S;\ntype DenormalizeNullable$1<S> = S extends EntityInterface<any> ? DenormalizeNullableNestedSchema<S> | undefined : S extends RecordClass ? DenormalizeNullableNestedSchema<S> : S extends SchemaClass ? DenormalizeReturnType<S['_denormalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? DenormalizeNullableObject<S> : S;\n\ninterface NetworkError extends Error {\n    status: number;\n    response?: Response;\n}\ninterface UnknownError extends Error {\n    status?: unknown;\n    response?: unknown;\n}\ntype ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ntype ResolveType<E extends (...args: any) => any> = ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ntype InferReturn<F extends FetchFunction, S extends Schema | undefined> = S extends undefined ? ReturnType<F> : ReturnType<F> extends unknown ? Promise<Denormalize$1<S>> : ReturnType<F>;\n\ntype ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n    getResponse: <E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => {\n        data: any;\n        expiryStatus: ExpiryStatusInterface;\n        expiresAt: number;\n    };\n    getError: <E extends Pick<EndpointInterface, 'key'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => ErrorTypes$1 | undefined;\n    readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<F extends FetchFunction = FetchFunction, S extends Schema | undefined = Schema | undefined, M extends true | undefined = true | undefined> extends EndpointExtraOptions<F> {\n    (...args: Parameters<F>): InferReturn<F, S>;\n    key(...args: Parameters<F>): string;\n    readonly sideEffect?: M;\n    readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n    /** Default data expiry length, will fall back to NetworkManager default if not defined */\n    readonly dataExpiryLength?: number;\n    /** Default error expiry length, will fall back to NetworkManager default if not defined */\n    readonly errorExpiryLength?: number;\n    /** Poll with at least this frequency in miliseconds */\n    readonly pollFrequency?: number;\n    /** Marks cached resources as invalid if they are stale */\n    readonly invalidIfStale?: boolean;\n    /** Enables optimistic updates for this request - uses return value as assumed network response\n     * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n     */\n    optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n    /** Enables optimistic updates for this request - uses return value as assumed network response */\n    getOptimisticResponse?(snap: SnapshotInterface, ...args: Parameters<F>): ResolveType<F>;\n    /** Determines whether to throw or fallback to */\n    errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n    /** User-land extra data to send */\n    readonly extra?: any;\n}\n\ntype FetchFunction<A extends readonly any[] = any, R = any> = (...args: A) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ntype Denormalize<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? Denormalize$1<S> : Denormalize$1<Extract<S, EntityInterface[]>> : Denormalize$1<Extract<S, EntityInterface>>;\ntype DenormalizeNullable<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? DenormalizeNullable$1<S> : DenormalizeNullable$1<Extract<S, EntityInterface[]>> : DenormalizeNullable$1<Extract<S, EntityInterface>>;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): Args extends [null] ? E['schema'] extends Exclude<Schema, null> ? DenormalizeNullable<E['schema']> : undefined : E['schema'] extends Exclude<Schema, null> ? Denormalize<E['schema']> : ResolveType<E>;\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<E extends Pick<EndpointInterface<FetchFunction, Schema | undefined, undefined>, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>] | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends undefined ? E extends (...args: any) => any ? ResolveType<E> | undefined : any : DenormalizeNullable<E['schema']>;\n\ntype ErrorTypes = NetworkError | UnknownError;\ntype UseErrorReturn<P> = P extends [null] ? undefined : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<E extends Pick<EndpointInterface, 'key'>, Args extends readonly [...Parameters<E['key']>] | readonly [null]>(endpoint: E, ...args: Args): UseErrorReturn<Args>;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): void;\n\ntype CondNull<P, A, B> = P extends null ? A : B;\ntype StatefulReturn<S extends Schema | undefined, P> = CondNull<P, {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n}, {\n    data: Denormalize<S>;\n    loading: false;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: true;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: ErrorTypes$1;\n}>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/api/useDLE\n */\ndeclare function useDLE<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends undefined ? {\n    data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n    loading: boolean;\n    error: ErrorTypes$1 | undefined;\n} : StatefulReturn<E['schema'], Args[0]>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\n/**\n * Ensure an endpoint is available. Keeps it fresh once it is.\n *\n * useSuspense() + useSubscription()\n * @see https://resthooks.io/docs/api/useLive\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useLive<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): Args extends [null] ? E['schema'] extends Exclude<Schema, null> ? DenormalizeNullable<E['schema']> : undefined : E['schema'] extends Exclude<Schema, null> ? Denormalize<E['schema']> : ResolveType<E>;\n\ndeclare const StateContext: Context<State$1<unknown>>;\ndeclare const DispatchContext: Context<(value: ActionTypes) => Promise<void>>;\ndeclare const DenormalizeCacheContext: Context<DenormalizeCache>;\ndeclare const ControllerContext: Context<Controller<(value: _rest_hooks_core.CombinedActionTypes) => Promise<void>>>;\ninterface Store<S> {\n    subscribe(listener: () => void): () => void;\n    dispatch: React.Dispatch<ActionTypes>;\n    getState(): S;\n    uninitialized?: boolean;\n}\ndeclare const StoreContext: Context<Store<State$1<unknown>>>;\n\ndeclare const useCacheState: () => State$1<unknown>;\n//# sourceMappingURL=useCacheState.d.ts.map\n\ndeclare const createFetch: typeof legacyActions.createFetch;\ndeclare const createReceive: typeof legacyActions.createReceive;\ndeclare const createReceiveError: typeof legacyActions.createReceiveError;\ndeclare const initialState: _rest_hooks_core.State<unknown>;\ndeclare const DELETED: symbol;\ndeclare const inferResults: typeof __INTERNAL__.inferResults;\n\ndeclare const internal_d_createFetch: typeof createFetch;\ndeclare const internal_d_createReceive: typeof createReceive;\ndeclare const internal_d_createReceiveError: typeof createReceiveError;\ndeclare const internal_d_initialState: typeof initialState;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_createReducer: typeof createReducer;\ndeclare const internal_d_applyManager: typeof applyManager;\ndeclare const internal_d_useCacheState: typeof useCacheState;\ndeclare namespace internal_d {\n  export {\n    internal_d_createFetch as createFetch,\n    internal_d_createReceive as createReceive,\n    internal_d_createReceiveError as createReceiveError,\n    internal_d_initialState as initialState,\n    internal_d_DELETED as DELETED,\n    internal_d_inferResults as inferResults,\n    internal_d_createReducer as createReducer,\n    internal_d_applyManager as applyManager,\n    internal_d_useCacheState as useCacheState,\n  };\n}\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<R extends React$1.Reducer<any, any>>(dispatch: React$1.Dispatch<React$1.ReducerAction<R>>, state: React$1.ReducerState<R>): (action: React$1.ReducerAction<R>) => Promise<void>;\n\nexport { _default as AsyncBoundary, _default$1 as BackupBoundary, CacheProvider, ControllerContext, DenormalizeCacheContext, DispatchContext, NetworkErrorBoundary, StateContext, Store, StoreContext, internal_d as __INTERNAL__, useCache, useController, useDLE, useError, useFetch, useLive, usePromisifiedDispatch, useSubscription, useSuspense };\n"}}]);