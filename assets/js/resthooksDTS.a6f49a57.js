(self.webpackChunk=self.webpackChunk||[]).push([[78789],{52031:e=>{e.exports="import {\n  Manager,\n  State as State$1,\n  Controller,\n  NetworkError as NetworkError$2,\n  ActionTypes,\n  DenormalizeCache,\n  legacyActions,\n  __INTERNAL__,\n  Schema as Schema$2,\n  EndpointExtraOptions as EndpointExtraOptions$2,\n  UpdateFunction,\n  Denormalize as Denormalize$3,\n  EndpointInterface as EndpointInterface$2,\n  FetchFunction as FetchFunction$2,\n  DenormalizeNullable as DenormalizeNullable$3,\n  ResolveType as ResolveType$2,\n  UnknownError as UnknownError$2,\n  createReducer as createReducer$1,\n  applyManager as applyManager$1,\n  ExpiryStatus,\n} from '@rest-hooks/core';\nexport {\n  AbstractInstanceType,\n  ActionTypes,\n  Controller,\n  DefaultConnectionListener,\n  Denormalize,\n  DenormalizeNullable,\n  DevToolsManager,\n  Dispatch,\n  EndpointExtraOptions,\n  EndpointInterface,\n  ExpiryStatus,\n  FetchAction,\n  FetchFunction,\n  InvalidateAction,\n  Manager,\n  Middleware,\n  MiddlewareAPI,\n  NetworkError,\n  NetworkManager,\n  Normalize,\n  NormalizeNullable,\n  PK,\n  PollingSubscription,\n  ReceiveAction,\n  ReceiveTypes,\n  ResetAction,\n  ResolveType,\n  Schema,\n  State,\n  SubscribeAction,\n  SubscriptionManager,\n  UnknownError,\n  UnsubscribeAction,\n  UpdateFunction,\n  actionTypes,\n} from '@rest-hooks/core';\nimport React$1, { Context } from 'react';\n\ndeclare type AbstractInstanceType$1<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject$1<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema$1 ? Denormalize$2<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject$1<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema$1 ? DenormalizeNullable$2<S[K]> : S[K];\n};\ninterface NestedSchemaClass$1<T = any> {\n  schema: Record<string, Schema$1>;\n  prototype: T;\n}\ninterface RecordClass$1<T = any> extends NestedSchemaClass$1<T> {\n  fromJS: (...args: any) => AbstractInstanceType$1<T>;\n}\ndeclare type DenormalizeNullableNestedSchema$1<S extends NestedSchemaClass$1> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'] & {\n        [K in keyof S['schema']]: DenormalizeNullable$2<S['schema'][K]>;\n      };\ndeclare type DenormalizeReturnType$1<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type Denormalize$2<S> = S extends EntityInterface$1<infer U>\n  ? U\n  : S extends RecordClass$1\n  ? AbstractInstanceType$1<S>\n  : S extends SchemaClass$1\n  ? DenormalizeReturnType$1<S['denormalize']>\n  : S extends Serializable$1<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$2<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject$1<S>\n  : S;\ndeclare type DenormalizeNullable$2<S> = S extends EntityInterface$1<any>\n  ? DenormalizeNullableNestedSchema$1<S> | undefined\n  : S extends RecordClass$1\n  ? DenormalizeNullableNestedSchema$1<S>\n  : S extends SchemaClass$1\n  ? DenormalizeReturnType$1<S['_denormalizeNullable']>\n  : S extends Serializable$1<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$2<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject$1<S>\n  : S;\n\n/** Get the Params type for a given Shape */\ndeclare type EndpointParam<E> = E extends (first: infer A, ...rest: any) => any\n  ? A\n  : E extends {\n      key: (first: infer A, ...rest: any) => any;\n    }\n  ? A\n  : never;\n/** What the function's promise resolves to */\ndeclare type ResolveType$1<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\ndeclare type PartialArray<A> = A extends []\n  ? []\n  : A extends [infer F]\n  ? [F] | []\n  : A extends [infer F, ...infer Rest]\n  ? [F] | [F, ...PartialArray<Rest>]\n  : A extends (infer T)[]\n  ? T[]\n  : never;\n\ninterface NetworkError$1 extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError$1 extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes$2 = NetworkError$1 | UnknownError$1;\n\ninterface SnapshotInterface$1 {\n  getResponse: <\n    E extends Pick<EndpointInterface$1, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: DenormalizeNullable$2<E['schema']>;\n    expiryStatus: ExpiryStatusInterface$1;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface$1, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes$2 | undefined;\n  readonly fetchedAt: number;\n}\ndeclare type ExpiryStatusInterface$1 = 1 | 2 | 3;\n\ndeclare type FetchFunction$1<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\ninterface EndpointExtraOptions$1<F extends FetchFunction$1 = FetchFunction$1> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType$1<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface$1,\n    ...args: Parameters<F>\n  ): ResolveType$1<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\n\ndeclare type Schema$1 =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema$1[]\n  | SchemaSimple$1\n  | Serializable$1;\ndeclare type Serializable$1<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple$1<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: {},\n    unvisit: UnvisitFunction$1,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex$1,\n    recurse: (...args: any) => any,\n    entities: EntityTable$1,\n  ): any;\n}\ninterface SchemaClass$1<T = any, N = T | undefined> extends SchemaSimple$1<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface$1<T = any> extends SchemaSimple$1 {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema$1>;\n  prototype: T;\n}\ninterface UnvisitFunction$1 {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction$1;\n  setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex$1 {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n}\ninterface EntityTable$1 {\n  [entityKey: string]:\n    | {\n        [pk: string]: unknown;\n      }\n    | undefined;\n}\n/** Defines a networking endpoint */\ninterface EndpointInterface$1<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions$1<F> {\n  (...args: Parameters<F>): ReturnType<F>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\n/** To change values on the server */\ninterface MutateEndpoint<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n> extends EndpointInterface$1<F, S, true> {\n  sideEffect: true;\n}\n/** For retrieval requests */\ndeclare type ReadEndpoint<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n> = EndpointInterface$1<F, S, undefined>;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\ninterface EndpointOptions<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = undefined,\n  M extends true | undefined = undefined,\n> extends EndpointExtraOptions$1<F> {\n  key?: (...args: Parameters<F>) => string;\n  sideEffect?: M;\n  schema?: S;\n  [k: string]: any;\n}\n\ninterface EndpointExtendOptions<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointOptions<F, S, M> {\n  fetch?: FetchFunction$1;\n}\n\ntype KeyofEndpointInstance = keyof EndpointInstance<FetchFunction$1>;\n\ntype ExtendedEndpoint<\n  O extends EndpointExtendOptions<F>,\n  E extends EndpointInstance<\n    FetchFunction$1,\n    Schema$1 | undefined,\n    true | undefined\n  >,\n  F extends FetchFunction$1,\n> = EndpointInstance<\n  'fetch' extends keyof O ? Exclude<O['fetch'], undefined> : E['fetch'],\n  'schema' extends keyof O ? O['schema'] : E['schema'],\n  'sideEffect' extends keyof O ? O['sideEffect'] : E['sideEffect']\n> &\n  Omit<O, KeyofEndpointInstance> &\n  Omit<E, KeyofEndpointInstance>;\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstance<\n  F extends (...args: any) => Promise<any> = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInstanceInterface<F, S, M> {\n  extend<\n    E extends EndpointInstance<\n      (...args: any) => Promise<any>,\n      Schema$1 | undefined,\n      true | undefined\n    >,\n    O extends EndpointExtendOptions<F> &\n      Partial<Omit<E, keyof EndpointInstance<FetchFunction$1>>> &\n      Record<string, unknown>,\n  >(\n    this: E,\n    options: Readonly<O>,\n  ): ExtendedEndpoint<typeof options, E, F>;\n}\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstanceInterface<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInterface$1<F, S, M> {\n  constructor: EndpointConstructor;\n\n  /**\n   * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n   * @param thisArg The object to be used as the this object.\n   * @param argArray A set of arguments to be passed to the function.\n   */\n  apply<E extends FetchFunction$1>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    argArray?: Parameters<E>,\n  ): ReturnType<E>;\n\n  /**\n   * Calls a method of an object, substituting another object for the current object.\n   * @param thisArg The object to be used as the current object.\n   * @param argArray A list of arguments to be passed to the method.\n   */\n  call<E extends FetchFunction$1>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...argArray: Parameters<E>\n  ): ReturnType<E>;\n\n  /**\n   * For a given function, creates a bound function that has the same body as the original function.\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n   * @param thisArg An object to which the this keyword can refer inside the new function.\n   * @param argArray A list of arguments to be passed to the new function.\n   */\n  bind<E extends FetchFunction$1, P extends PartialArray<Parameters<E>>>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...args: readonly [...P]\n  ): EndpointInstance<\n    (...args: readonly [...RemoveArray<Parameters<E>, P>]) => ReturnType<E>,\n    S,\n    M\n  > &\n    Omit<E, keyof EndpointInstance<FetchFunction$1>>;\n\n  /** Returns a string representation of a function. */\n  toString(): string;\n\n  prototype: any;\n  readonly length: number;\n\n  // Non-standard extensions\n  arguments: any;\n  caller: F;\n\n  key(...args: Parameters<F>): string;\n\n  readonly sideEffect: M;\n\n  readonly schema: S;\n\n  fetch: F;\n\n  /** The following is for compatibility with FetchShape */\n  /** @deprecated */\n  readonly type: M extends undefined\n    ? 'read'\n    : IfAny<M, any, IfTypeScriptLooseNull<'read', 'mutate'>>;\n\n  /** @deprecated */\n  getFetchKey(...args: OnlyFirst<Parameters<F>>): string;\n  /** @deprecated */\n  options?: EndpointExtraOptions$1<F>;\n}\n\ninterface EndpointConstructor {\n  new <\n    F extends (\n      this: EndpointInstance<FetchFunction$1> & E,\n      params?: any,\n      body?: any,\n    ) => Promise<any>,\n    S extends Schema$1 | undefined = undefined,\n    M extends true | undefined = undefined,\n    E extends Record<string, any> = {},\n  >(\n    fetchFunction: F,\n    options?: EndpointOptions<F, S, M> & E,\n  ): EndpointInstance<F, S, M> & E;\n  readonly prototype: Function;\n}\ndeclare let Endpoint: EndpointConstructor;\n\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\ntype IfTypeScriptLooseNull<Y, N> = 1 | undefined extends 1 ? Y : N;\n\ntype OnlyFirst<A extends unknown[]> = A extends [] ? [] : [A[0]];\n\ntype RemoveArray<Orig extends any[], Rem extends any[]> = Rem extends [\n  any,\n  ...infer RestRem,\n]\n  ? Orig extends [any, ...infer RestOrig]\n    ? RemoveArray<RestOrig, RestRem>\n    : never\n  : Orig;\n\n/**\n * Performant lookups by secondary indexes\n * @see https://resthooks.io/docs/api/Index\n */\ndeclare class Index<S extends Schema$1, P = Readonly<IndexParams<S>>> {\n  schema: S;\n  constructor(schema: S, key?: (params: P) => string);\n  key(params?: P): string;\n  /** The following is for compatibility with FetchShape */\n  getFetchKey: (params: P) => string;\n}\ndeclare type ArrayElement<ArrayType extends unknown[] | readonly unknown[]> =\n  ArrayType[number];\ndeclare type IndexParams<S extends Schema$1> = S extends {\n  indexes: readonly string[];\n}\n  ? {\n      [K in Extract<\n        ArrayElement<S['indexes']>,\n        keyof AbstractInstanceType$1<S>\n      >]?: AbstractInstanceType$1<S>[K];\n    }\n  : Readonly<object>;\n\ninterface ProviderProps {\n  children: React$1.ReactNode;\n  managers: Manager[];\n  initialState: State$1<unknown>;\n  Controller: typeof Controller;\n}\n/**\n * Manages state, providing all context needed to use the hooks.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({\n  children,\n  managers,\n  initialState,\n  Controller,\n}: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n  var defaultProps: {\n    managers: Manager[];\n    initialState: State$1<unknown>;\n    Controller: typeof Controller;\n  };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\ndeclare const _default$1: React$1.NamedExoticComponent<{\n  children: React$1.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\n/**\n * Handles loading and error conditions of Suspense\n * @see https://resthooks.io/docs/api/AsyncBoundary\n */\ndeclare function AsyncBoundary({\n  children,\n  errorComponent,\n  fallback,\n}: {\n  children: React$1.ReactNode;\n  fallback?: React$1.ReactNode;\n  errorComponent?: React$1.ComponentType<{\n    error: NetworkError$2;\n  }>;\n}): JSX.Element;\ndeclare const _default: React$1.MemoExoticComponent<typeof AsyncBoundary>;\n//# sourceMappingURL=AsyncBoundary.d.ts.map\n\ninterface Props<E extends NetworkError$2> {\n  children: React$1.ReactNode;\n  fallbackComponent: React$1.ComponentType<{\n    error: E;\n  }>;\n}\ninterface State<E extends NetworkError$2> {\n  error?: E;\n}\n/**\n * Handles any networking errors from suspense\n * @see https://resthooks.io/docs/api/NetworkErrorBoundary\n */\ndeclare class NetworkErrorBoundary<\n  E extends NetworkError$2,\n> extends React$1.Component<Props<E>, State<E>> {\n  static defaultProps: {\n    fallbackComponent: ({ error }: { error: NetworkError$2 }) => JSX.Element;\n  };\n\n  static getDerivedStateFromError(error: NetworkError$2 | any): {\n    error: NetworkError$2;\n  };\n\n  state: State<E>;\n  render(): JSX.Element;\n}\n\ndeclare type Schema =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema[]\n  | SchemaSimple\n  | Serializable;\ndeclare type Serializable<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n    entities: EntityTable,\n  ): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface UnvisitFunction {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction;\n  setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n}\ninterface EntityTable {\n  [entityKey: string]:\n    | {\n        [pk: string]: unknown;\n      }\n    | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n  fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U>\n  ? U\n  : S extends RecordClass\n  ? AbstractInstanceType<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['denormalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject<S>\n  : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any>\n  ? DenormalizeNullableNestedSchema<S> | undefined\n  : S extends RecordClass\n  ? DenormalizeNullableNestedSchema<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['_denormalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject<S>\n  : S;\n\ninterface NetworkError extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<\n  F extends FetchFunction,\n  S extends Schema | undefined,\n> = S extends undefined\n  ? ReturnType<F>\n  : ReturnType<F> extends unknown\n  ? Promise<Denormalize$1<S>>\n  : ReturnType<F>;\n\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n  getResponse: <\n    E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: any;\n    expiryStatus: ExpiryStatusInterface;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes$1 | undefined;\n  readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions<F> {\n  (...args: Parameters<F>): InferReturn<F, S>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface,\n    ...args: Parameters<F>\n  ): ResolveType<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Denormalize$1<S>\n    : Denormalize$1<Extract<S, EntityInterface[]>>\n  : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? DenormalizeNullable$1<S>\n    : DenormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : DenormalizeNullable$1<Extract<S, EntityInterface>>;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): Args extends [null]\n  ? E['schema'] extends Exclude<Schema, null>\n    ? DenormalizeNullable<E['schema']>\n    : undefined\n  : E['schema'] extends Exclude<Schema, null>\n  ? Denormalize<E['schema']>\n  : ResolveType<E>;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\ndeclare type CondNull$1<P, A, B> = P extends null ? A : B;\ndeclare type StatefulReturn<S extends Schema | undefined, P> = CondNull$1<\n  P,\n  {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n  },\n  | {\n      data: Denormalize<S>;\n      loading: false;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: true;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: false;\n      error: ErrorTypes$1;\n    }\n>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/api/useDLE\n */\ndeclare function useDLE<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends undefined\n  ? {\n      data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n      loading: boolean;\n      error: ErrorTypes$1 | undefined;\n    }\n  : StatefulReturn<E['schema'], Args[0]>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\ndeclare const StateContext: Context<State$1<unknown>>;\ndeclare const DispatchContext: Context<(value: ActionTypes) => Promise<void>>;\ndeclare const DenormalizeCacheContext: Context<DenormalizeCache>;\ndeclare const ControllerContext: Context<Controller>;\ninterface Store<S> {\n  subscribe(listener: () => void): () => void;\n  dispatch: React.Dispatch<ActionTypes>;\n  getState(): S;\n  uninitialized?: boolean;\n}\ndeclare const StoreContext: Context<Store<State$1<unknown>>>;\n\ndeclare const createFetch$1: typeof legacyActions.createFetch;\ndeclare const createReceive$1: typeof legacyActions.createReceive;\ndeclare const createReceiveError$1: typeof legacyActions.createReceiveError;\ndeclare const inferResults$1: typeof __INTERNAL__.inferResults;\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<R extends React$1.Reducer<any, any>>(\n  dispatch: React$1.Dispatch<React$1.ReducerAction<R>>,\n  state: React$1.ReducerState<R>,\n): (action: React$1.ReducerAction<R>) => Promise<void>;\n\n/** Defines the shape of a network request */\ninterface FetchShape<\n  S extends Schema$2 | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response = any,\n> {\n  readonly type: 'read' | 'mutate' | 'delete';\n  fetch(params: Params, body?: Body): Promise<Response>;\n  getFetchKey(params: Params): string;\n  readonly schema: S;\n  readonly options?: EndpointExtraOptions$2;\n}\n/** To change values on the server */\ninterface MutateShape<\n  S extends Schema$2 | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, Body, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, body: Body): Promise<Response>;\n}\n/** Removes entities */\ninterface DeleteShape<\n  S extends Schema$2 | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, ...args: any): Promise<Response>;\n}\n/** For retrieval requests */\ninterface ReadShape<\n  S extends Schema$2 | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'read';\n  fetch(params: Params): Promise<Response>;\n}\n\n/** Sets a FetchShape's Param type.\n * Useful to constrain acceptable params (second arg) in hooks like useResource().\n *\n * @param [Shape] FetchShape to act upon\n * @param [Params] what to set the Params to\n */\ndeclare type SetShapeParams<\n  Shape extends FetchShape<any, any, any>,\n  Params extends Readonly<object>,\n> = {\n  [K in keyof Shape]: Shape[K];\n} & (Shape['fetch'] extends (first: any, ...rest: infer Args) => infer Return\n  ? {\n      fetch: (first: Params, ...rest: Args) => Return;\n    }\n  : never);\n/** Get the Params type for a given Shape */\ndeclare type ParamsFromShape<S> = S extends {\n  fetch: (first: infer A, ...rest: any) => any;\n}\n  ? A\n  : S extends {\n      getFetchKey: (first: infer A, ...rest: any) => any;\n    }\n  ? A\n  : never;\n/** Get the Schema type for a given Shape */\ndeclare type SchemaFromShape<\n  F extends FetchShape<Schema$2 | undefined, any, any>,\n> = F['schema'];\n/** Get the Body type for a given Shape */\ndeclare type BodyFromShape<F extends FetchShape<any, any, any>> = Parameters<\n  F['fetch']\n>[1];\ndeclare type OptimisticUpdateParams<\n  SourceSchema extends Schema$2 | undefined,\n  DestShape extends FetchShape<any, any, any>,\n> = [\n  DestShape,\n  ParamsFromShape<DestShape>,\n  UpdateFunction<SourceSchema, SchemaFromShape<DestShape>>,\n];\ndeclare type ReturnFromShape<S extends FetchShape<any, any, any>> = ReturnType<\n  S['fetch']\n> extends unknown\n  ? Promise<Denormalize$3<S['schema']>>\n  : ReturnType<S['fetch']>;\n\ndeclare function makeCacheProvider(\n  managers: Manager[],\n  initialState?: State$1<unknown>,\n): (props: { children: React$1.ReactNode }) => JSX.Element;\n\ndeclare type DeepPartialWithUnknown<T> = {\n  [K in keyof T]?: T[K] extends unknown\n    ? any\n    : T[K] extends object\n    ? DeepPartialWithUnknown<T[K]>\n    : T[K];\n};\ndeclare const makeExternalCacheProvider: (\n  managers: Manager[],\n  initialState?: DeepPartialWithUnknown<State$1<any>>,\n) => ({ children }: { children: React$1.ReactNode }) => JSX.Element;\n//# sourceMappingURL=makeExternalCacheProvider.d.ts.map\n\n/**\n * Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetcher<\n  Shape extends FetchShape<Schema$2, Readonly<object>, any>,\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  throttle?: boolean,\n): <\n  UpdateParams extends OptimisticUpdateParams<\n    SchemaFromShape<Shape>,\n    FetchShape<any, any, any>\n  >[],\n>(\n  a: Parameters<Shape['fetch']>[0],\n  b?: Parameters<Shape['fetch']>[1],\n  updateParams?: UpdateParams | undefined,\n) => ReturnFromShape<typeof fetchShape>;\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<\n  E extends\n    | Pick<\n        EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined>,\n        'key' | 'schema' | 'invalidIfStale'\n      >\n    | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends {}\n  ? DenormalizeNullable$3<E['schema']>\n  : E extends (...args: any) => any\n  ? ResolveType$2<E> | undefined\n  : any;\n\n/**\n * Request a resource if it is not in cache.\\\n * @see https://resthooks.io/docs/api/useRetrieve\n */\ndeclare function useRetrieve<Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n  params: ParamsFromShape<Shape> | null,\n  triggerFetch?: boolean,\n  entitiesExpireAt?: number,\n): any;\n\ndeclare type ResourceReturn<\n  P,\n  S extends {\n    fetch: any;\n    schema: any;\n  },\n> = CondNull<\n  P,\n  S['schema'] extends undefined\n    ? ResolveType$2<S['fetch']> | undefined\n    : DenormalizeNullable$3<S['schema']>,\n  S['schema'] extends undefined\n    ? ResolveType$2<S['fetch']>\n    : Denormalize$3<S['schema']>\n>;\ndeclare type CondNull<P, A, B> = P extends null ? A : B;\n/**\n * Ensure a resource is available.\n * Suspends until it is.\n *\n * `useResource` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useresource\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n>(v1: readonly [S1, P1]): [ResourceReturn<P1, S1>];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>];\ndeclare function useResource<\n  S extends ReadShape<any, any>,\n  P extends ParamsFromShape<S> | null,\n>(fetchShape: S, params: P): ResourceReturn<P, S>;\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>, ResourceReturn<P3, S3>];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n  S15 extends ReadShape<any, any>,\n  P15 extends ParamsFromShape<S15> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n  v15: readonly [S15, P15],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n  ResourceReturn<P15, S15>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n  S15 extends ReadShape<any, any>,\n  P15 extends ParamsFromShape<S15> | null,\n  S16 extends ReadShape<any, any>,\n  P16 extends ParamsFromShape<S16> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n  v15: readonly [S15, P15],\n  v16: readonly [S16, P16],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n  ResourceReturn<P15, S15>,\n  ResourceReturn<P16, S16>,\n];\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<\n  E extends\n    | EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined>\n    | ReadShape<any, any>,\n  Args extends\n    | (E extends (...args: any) => any\n        ? readonly [...Parameters<E>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(endpoint: E, ...args: Args): void;\n\n/**\n * Gets meta for a fetch key.\n * @see https://resthooks.io/docs/api/useMeta\n */\ndeclare function useMeta<\n  E extends\n    | Pick<EndpointInterface$2<FetchFunction$2>, 'key'>\n    | Pick<FetchShape<any, any>, 'getFetchKey'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(endpoint: E, ...args: Args): StateMeta | null;\ndeclare type StateMeta<R = any> = State$1<R>['meta'][string];\n\ndeclare type ErrorTypes = NetworkError$2 | UnknownError$2;\ndeclare type UseErrorReturn<P> = P extends [null]\n  ? undefined\n  : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<\n  E extends\n    | Pick<\n        EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined>,\n        'key' | 'schema' | 'invalidIfStale'\n      >\n    | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(endpoint: E, ...args: Args): UseErrorReturn<typeof args>;\n\n/** Returns whether the data at this url is fresh or stale\n * @deprecated use https://resthooks.io/docs/api/Controller#getResponse\n */\ndeclare function useExpiresAt<\n  Shape extends Pick<ReadShape<any, any>, 'getFetchKey' | 'options'>,\n>(\n  fetchShape: Shape,\n  params: ParamsFromShape<Shape> | null,\n  entitiesExpireAt?: number,\n): number;\n\n/**\n * Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidator<Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n): (params: ParamsFromShape<Shape> | null) => void;\n\n/**\n * Returns a function to completely clear the cache of all entries\n * @deprecated use https://resthooks.io/docs/api/Controller#resetEntireStore\n */\ndeclare function useResetter(): () => void;\n\n/** Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetchDispatcher(throttle?: boolean): <\n  Shape extends FetchShape<Schema$2, Readonly<object>, any>,\n  UpdateParams extends OptimisticUpdateParams<\n    SchemaFromShape<Shape>,\n    FetchShape<any, any, any>\n  >[],\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  params: ParamsFromShape<Shape>,\n  body: BodyFromShape<Shape>,\n  updateParams?: UpdateParams | undefined,\n) => ReturnFromShape<typeof fetchShape>;\n\n/** Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidateDispatcher(): <Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n  params: ParamsFromShape<Shape>,\n) => void;\n\n/** @deprecated use https://resthooks.io/docs/api/Controller#getResponse */\ndeclare function hasUsableData(\n  fetchShape: Pick<FetchShape<any>, 'options'>,\n  cacheReady: boolean,\n  deleted: boolean,\n  invalidated?: boolean,\n): boolean;\n\ndeclare const createFetch: typeof createFetch$1;\ndeclare const createReceive: typeof createReceive$1;\ndeclare const createReceiveError: typeof createReceiveError$1;\ndeclare const initialState: State$1<unknown>;\ndeclare const DELETED: symbol;\ndeclare const inferResults: typeof inferResults$1;\ndeclare const createReducer: typeof createReducer$1;\ndeclare const applyManager: typeof applyManager$1;\ndeclare const useCacheState: () => State$1<unknown>;\n\ndeclare const internal_d_createFetch: typeof createFetch;\ndeclare const internal_d_createReceive: typeof createReceive;\ndeclare const internal_d_createReceiveError: typeof createReceiveError;\ndeclare const internal_d_initialState: typeof initialState;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_createReducer: typeof createReducer;\ndeclare const internal_d_applyManager: typeof applyManager;\ndeclare const internal_d_useCacheState: typeof useCacheState;\ndeclare const internal_d_StateContext: typeof StateContext;\ndeclare const internal_d_DispatchContext: typeof DispatchContext;\ndeclare const internal_d_hasUsableData: typeof hasUsableData;\ndeclare namespace internal_d {\n  export {\n    internal_d_createFetch as createFetch,\n    internal_d_createReceive as createReceive,\n    internal_d_createReceiveError as createReceiveError,\n    internal_d_initialState as initialState,\n    internal_d_DELETED as DELETED,\n    internal_d_inferResults as inferResults,\n    internal_d_createReducer as createReducer,\n    internal_d_applyManager as applyManager,\n    internal_d_useCacheState as useCacheState,\n    internal_d_StateContext as StateContext,\n    internal_d_DispatchContext as DispatchContext,\n    internal_d_hasUsableData as hasUsableData,\n  };\n}\n\n/**\n * @deprecated use https://resthooks.io/docs/api/Controller#getResponse directly instead\n *\n * Selects the denormalized form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n *\n * @returns [denormalizedValue, ready]\n */\ndeclare function useDenormalized<\n  Shape extends Pick<\n    ReadShape<Schema$2 | undefined, any>,\n    'getFetchKey' | 'schema' | 'options'\n  >,\n>(\n  shape: Shape,\n  params: ParamsFromShape<Shape> | null,\n  state: State$1<any>,\n  /** @deprecated */\n  denormalizeCache?: any,\n): {\n  data: DenormalizeNullable$3<Shape['schema']>;\n  expiryStatus: ExpiryStatus;\n  expiresAt: number;\n};\n\nexport {\n  ArrayElement,\n  _default as AsyncBoundary,\n  _default$1 as BackupBoundary,\n  CacheProvider,\n  ControllerContext,\n  DeleteShape,\n  DenormalizeCacheContext,\n  DispatchContext,\n  Endpoint,\n  EndpointParam,\n  EndpointExtraOptions$1 as FetchOptions,\n  FetchShape,\n  Index,\n  IndexParams,\n  MutateEndpoint,\n  MutateShape,\n  NetworkErrorBoundary,\n  ParamsFromShape,\n  ReadEndpoint,\n  ReadShape,\n  SetShapeParams,\n  StateContext,\n  Store,\n  StoreContext,\n  internal_d as __INTERNAL__,\n  hasUsableData,\n  makeCacheProvider,\n  makeExternalCacheProvider,\n  useCache,\n  useController,\n  useDLE,\n  useDenormalized,\n  useError,\n  useExpiresAt,\n  useFetch,\n  useFetchDispatcher,\n  useFetcher,\n  useInvalidateDispatcher,\n  useInvalidator,\n  useMeta,\n  usePromisifiedDispatch,\n  useResetter,\n  useResource,\n  useRetrieve,\n  useSubscription,\n  useSuspense,\n};\n"}}]);