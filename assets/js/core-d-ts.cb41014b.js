(self.webpackChunk=self.webpackChunk||[]).push([[30007],{90734:e=>{e.exports="/// <reference types=\"react\" />\nimport * as React$1 from 'react';\nimport React__default from 'react';\nimport { ErrorFluxStandardActionWithPayloadAndMeta, FSA, FSAWithPayloadAndMeta, FSAWithMeta } from 'flux-standard-action';\n\ndeclare type Schema = null | string | {\n    [K: string]: any;\n} | Schema[] | SchemaSimple | Serializable;\ndeclare type Serializable<T extends {\n    toJSON(): string;\n} = {\n    toJSON(): string;\n}> = {\n    prototype: T;\n};\ninterface SchemaSimple<T = any> {\n    normalize(input: any, parent: any, key: any, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    denormalize(input: {}, unvisit: UnvisitFunction): [denormalized: T, found: boolean, suspend: boolean];\n    infer(args: readonly any[], indexes: NormalizedIndex, recurse: (...args: any) => any): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n    _normalizeNullable(): any;\n    _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n    pk(params: any, parent?: any, key?: string): string | undefined;\n    readonly key: string;\n    merge(existing: any, incoming: any): any;\n    expiresAt?(meta: any, input: any): number;\n    useIncoming?(existingMeta: any, incomingMeta: any, existing: any, incoming: any): boolean;\n    indexes?: any;\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface UnvisitFunction {\n    (input: any, schema: any): [any, boolean, boolean];\n    og?: UnvisitFunction;\n    setLocal?: (entity: any) => void;\n}\ndeclare type NormalizedIndex = {\n    readonly [entityKey: string]: {\n        readonly [indexName: string]: {\n            readonly [lookup: string]: string;\n        };\n    };\n};\n\n/** Link in a chain */\ndeclare class Link<K extends object, V> {\n    children: WeakMap<K, Link<K, V>>;\n    value?: V;\n}\n/** Maps from a list of objects (referentially) to any value\n *\n * If *any* members of the list get claned up, so does that key/value pair get removed.\n */\ndeclare class WeakListMap<K extends object, V> {\n    readonly first: WeakMap<K, Link<K, V>>;\n    delete(key: K[]): boolean;\n    get(key: K[]): V | undefined;\n    has(key: K[]): boolean;\n    set(key: K[], value: V): WeakListMap<K, V>;\n    protected traverse(key: K[]): Link<K, V> | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n    prototype: infer U;\n} ? U : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ndeclare type NormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Normalize$1<S[K]> : S[K];\n};\ndeclare type NormalizedNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? NormalizeNullable<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n    fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ninterface DenormalizeCache {\n    entities: {\n        [key: string]: {\n            [pk: string]: WeakListMap<object, EntityInterface>;\n        };\n    };\n    results: {\n        [key: string]: WeakListMap<object, any>;\n    };\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> = keyof S['schema'] extends never ? S['prototype'] : string extends keyof S['schema'] ? S['prototype'] : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (input: any, unvisit: any) => [infer R, any, any] ? R : never;\ndeclare type NormalizeReturnType<T> = T extends (...args: any) => infer R ? R : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U> ? U : S extends RecordClass ? AbstractInstanceType<S> : S extends SchemaClass ? DenormalizeReturnType<S['denormalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] : S extends {\n    [K: string]: any;\n} ? DenormalizeObject<S> : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any> ? DenormalizeNullableNestedSchema<S> | undefined : S extends RecordClass ? DenormalizeNullableNestedSchema<S> : S extends SchemaClass ? DenormalizeReturnType<S['_denormalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? DenormalizeNullableObject<S> : S;\ndeclare type Normalize$1<S> = S extends EntityInterface ? string : S extends RecordClass ? NormalizeObject<S['schema']> : S extends SchemaClass ? NormalizeReturnType<S['normalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Normalize$1<F>[] : S extends {\n    [K: string]: any;\n} ? NormalizeObject<S> : S;\ndeclare type NormalizeNullable<S> = S extends EntityInterface ? string | undefined : S extends RecordClass ? NormalizedNullableObject<S['schema']> : S extends SchemaClass ? NormalizeReturnType<S['_normalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Normalize$1<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? NormalizedNullableObject<S> : S;\n\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\ndeclare function inferResults<S extends Schema>(schema: S, args: any[], indexes: NormalizedIndex): NormalizeNullable<S>;\n\ndeclare const DELETED: unique symbol;\n\ninterface NetworkError extends Error {\n    status: number;\n    response?: Response;\n}\ninterface UnknownError extends Error {\n    status?: unknown;\n    response?: unknown;\n}\ndeclare type ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> = ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<F extends FetchFunction, S extends Schema | undefined> = S extends undefined ? ReturnType<F> : ReturnType<F> extends unknown ? Promise<Denormalize$1<S>> : ReturnType<F>;\n\ndeclare const enum ExpiryStatus {\n    Invalid = 1,\n    InvalidIfStale = 2,\n    Valid = 3\n}\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n    getResponse: <E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => {\n        data: DenormalizeNullable$1<E['schema']>;\n        expiryStatus: ExpiryStatusInterface;\n        expiresAt: number;\n    };\n    getError: <E extends Pick<EndpointInterface, 'key'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => ErrorTypes$1 | undefined;\n    readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<F extends FetchFunction = FetchFunction, S extends Schema | undefined = Schema | undefined, M extends true | undefined = true | undefined> extends EndpointExtraOptions<F> {\n    (...args: Parameters<F>): InferReturn<F, S>;\n    key(...args: Parameters<F>): string;\n    readonly sideEffect?: M;\n    readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n    /** Default data expiry length, will fall back to NetworkManager default if not defined */\n    readonly dataExpiryLength?: number;\n    /** Default error expiry length, will fall back to NetworkManager default if not defined */\n    readonly errorExpiryLength?: number;\n    /** Poll with at least this frequency in miliseconds */\n    readonly pollFrequency?: number;\n    /** Marks cached resources as invalid if they are stale */\n    readonly invalidIfStale?: boolean;\n    /** Enables optimistic updates for this request - uses return value as assumed network response\n     * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n     */\n    optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n    /** Enables optimistic updates for this request - uses return value as assumed network response */\n    getOptimisticResponse?(snap: SnapshotInterface, ...args: Parameters<F>): ResolveType<F>;\n    /** Determines whether to throw or fallback to */\n    errorPolicy?(error: any): 'soft' | undefined;\n    /** User-land extra data to send */\n    readonly extra?: any;\n}\ndeclare type UpdateFunction<SourceSchema extends Schema | undefined, DestSchema extends Schema> = (sourceResults: Normalize$1<SourceSchema>, destResults: Normalize$1<DestSchema> | undefined) => Normalize$1<DestSchema>;\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (...args: A) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? Denormalize$1<S> : Denormalize$1<Extract<S, EntityInterface[]>> : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? DenormalizeNullable$1<S> : DenormalizeNullable$1<Extract<S, EntityInterface[]>> : DenormalizeNullable$1<Extract<S, EntityInterface>>;\ndeclare type Normalize<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? Normalize$1<S> : Normalize$1<Extract<S, EntityInterface[]>> : Normalize$1<Extract<S, EntityInterface>>;\n\ndeclare const RIC: (cb: (...args: any[]) => void, options: any) => void;\n\ndeclare const _default: React__default.NamedExoticComponent<{\n    children: React__default.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\n//# sourceMappingURL=internal.d.ts.map\n\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_RIC: typeof RIC;\ndeclare namespace internal_d {\n  export {\n    internal_d_inferResults as inferResults,\n    internal_d_DELETED as DELETED,\n    internal_d_RIC as RIC,\n    _default as BackupBoundary,\n  };\n}\n\ninterface MiddlewareAPI$1<R extends React__default.Reducer<any, any> = React__default.Reducer<any, any>> {\n    getState: () => React__default.ReducerState<R>;\n    dispatch: Dispatch<R>;\n}\ndeclare type Dispatch<R extends React__default.Reducer<any, any>> = (action: React__default.ReducerAction<R>) => Promise<void>;\ndeclare type Middleware$1 = <R extends React__default.Reducer<any, any>>({ dispatch, }: MiddlewareAPI$1<R>) => (next: Dispatch<R>) => Dispatch<R>;\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<R extends React__default.Reducer<any, any>>(dispatch: React__default.Dispatch<React__default.ReducerAction<R>>, state: React__default.ReducerState<R>): (action: React__default.ReducerAction<R>) => Promise<void>;\n\ndeclare type ErrorableFSAWithPayloadAndMeta<Type extends string = string, Payload = undefined, Meta = undefined, CustomError extends Error = Error> = ErrorFluxStandardActionWithPayloadAndMeta<Type, CustomError, Meta> | NoErrorFluxStandardActionWithPayloadAndMeta<Type, Payload, Meta>;\ninterface NoErrorFluxStandardAction<Type extends string = string, Payload = undefined, Meta = undefined> extends FSA<Type, Payload, Meta> {\n    error?: false;\n}\n/**\n * A Flux Standard action with a required payload property.\n */\ninterface NoErrorFluxStandardActionWithPayload<Type extends string = string, Payload = undefined, Meta = undefined> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n    /**\n     * The required `payload` property MAY be any type of value.\n     * It represents the payload of the action.\n     * Any information about the action that is not the type or status of the action should be part of the `payload` field.\n     * By convention, if `error` is `true`, the `payload` SHOULD be an error object.\n     * This is akin to rejecting a promise with an error object.\n     */\n    payload: Payload;\n}\n/**\n * A Flux Standard action with a required metadata property.\n */\ninterface NoErrorFluxStandardActionWithMeta<Type extends string = string, Payload = undefined, Meta = undefined> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n    /**\n     * The required `meta` property MAY be any type of value.\n     * It is intended for any extra information that is not part of the payload.\n     */\n    meta: Meta;\n}\n/**\n * A Flux Standard action with required payload and metadata properties.\n */\ndeclare type NoErrorFluxStandardActionWithPayloadAndMeta<Type extends string = string, Payload = undefined, Meta = undefined> = NoErrorFluxStandardActionWithPayload<Type, Payload, Meta> & NoErrorFluxStandardActionWithMeta<Type, Payload, Meta>;\n\n/** Defines the shape of a network request */\ninterface FetchShape<S extends Schema | undefined, Params extends Readonly<object> = Readonly<object>, Body extends Readonly<object | string> | void | unknown = Readonly<object | string> | undefined, Response = any> {\n    readonly type: 'read' | 'mutate' | 'delete';\n    fetch(params: Params, body?: Body): Promise<Response>;\n    getFetchKey(params: Params): string;\n    readonly schema: S;\n    readonly options?: EndpointExtraOptions;\n}\n/** To change values on the server */\ninterface MutateShape<S extends Schema | undefined, Params extends Readonly<object> = Readonly<object>, Body extends Readonly<object | string> | void | unknown = Readonly<object | string> | undefined, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, Body, Response> {\n    readonly type: 'mutate';\n    fetch(params: Params, body: Body): Promise<Response>;\n}\n/** Removes entities */\ninterface DeleteShape<S extends Schema | undefined, Params extends Readonly<object> = Readonly<object>, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, undefined, Response> {\n    readonly type: 'mutate';\n    fetch(params: Params, ...args: any): Promise<Response>;\n}\n/** For retrieval requests */\ninterface ReadShape<S extends Schema | undefined, Params extends Readonly<object> = Readonly<object>, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, undefined, Response> {\n    readonly type: 'read';\n    fetch(params: Params): Promise<Response>;\n}\n\n/** Sets a FetchShape's Param type.\n * Useful to constrain acceptable params (second arg) in hooks like useResource().\n *\n * @param [Shape] FetchShape to act upon\n * @param [Params] what to set the Params to\n */\ndeclare type SetShapeParams<Shape extends FetchShape<any, any, any>, Params extends Readonly<object>> = {\n    [K in keyof Shape]: Shape[K];\n} & (Shape['fetch'] extends (first: any, ...rest: infer Args) => infer Return ? {\n    fetch: (first: Params, ...rest: Args) => Return;\n} : never);\n/** Get the Params type for a given Shape */\ndeclare type ParamsFromShape<S> = S extends {\n    fetch: (first: infer A, ...rest: any) => any;\n} ? A : S extends {\n    getFetchKey: (first: infer A, ...rest: any) => any;\n} ? A : never;\n/** Get the Schema type for a given Shape */\ndeclare type SchemaFromShape<F extends FetchShape<Schema | undefined, any, any>> = F['schema'];\n/** Get the Body type for a given Shape */\ndeclare type BodyFromShape<F extends FetchShape<any, any, any>> = Parameters<F['fetch']>[1];\ndeclare type OptimisticUpdateParams<SourceSchema extends Schema | undefined, DestShape extends FetchShape<any, any, any>> = [\n    DestShape,\n    ParamsFromShape<DestShape>,\n    UpdateFunction<SourceSchema, SchemaFromShape<DestShape>>\n];\ndeclare type ReturnFromShape<S extends FetchShape<any, any, any>> = ReturnType<S['fetch']> extends unknown ? Promise<Denormalize<S['schema']>> : ReturnType<S['fetch']>;\n\ndeclare const FETCH_TYPE: \"rest-hooks/fetch\";\ndeclare const RECEIVE_TYPE: \"rest-hooks/receive\";\ndeclare const OPTIMISTIC_TYPE: \"rest-hooks/optimistic\";\ndeclare const RESET_TYPE: \"rest-hooks/reset\";\ndeclare const SUBSCRIBE_TYPE: \"rest-hooks/subscribe\";\ndeclare const UNSUBSCRIBE_TYPE: \"rest-hook/unsubscribe\";\ndeclare const INVALIDATE_TYPE: \"rest-hooks/invalidate\";\ndeclare const GC_TYPE: \"rest-hooks/gc\";\n\ndeclare const actionTypes_d_FETCH_TYPE: typeof FETCH_TYPE;\ndeclare const actionTypes_d_RECEIVE_TYPE: typeof RECEIVE_TYPE;\ndeclare const actionTypes_d_OPTIMISTIC_TYPE: typeof OPTIMISTIC_TYPE;\ndeclare const actionTypes_d_RESET_TYPE: typeof RESET_TYPE;\ndeclare const actionTypes_d_SUBSCRIBE_TYPE: typeof SUBSCRIBE_TYPE;\ndeclare const actionTypes_d_UNSUBSCRIBE_TYPE: typeof UNSUBSCRIBE_TYPE;\ndeclare const actionTypes_d_INVALIDATE_TYPE: typeof INVALIDATE_TYPE;\ndeclare const actionTypes_d_GC_TYPE: typeof GC_TYPE;\ndeclare namespace actionTypes_d {\n  export {\n    actionTypes_d_FETCH_TYPE as FETCH_TYPE,\n    actionTypes_d_RECEIVE_TYPE as RECEIVE_TYPE,\n    actionTypes_d_OPTIMISTIC_TYPE as OPTIMISTIC_TYPE,\n    actionTypes_d_RESET_TYPE as RESET_TYPE,\n    actionTypes_d_SUBSCRIBE_TYPE as SUBSCRIBE_TYPE,\n    actionTypes_d_UNSUBSCRIBE_TYPE as UNSUBSCRIBE_TYPE,\n    actionTypes_d_INVALIDATE_TYPE as INVALIDATE_TYPE,\n    actionTypes_d_GC_TYPE as GC_TYPE,\n  };\n}\n\ndeclare type ResultEntry<E extends EndpointInterface> = E['schema'] extends undefined ? ResolveType<E> : Normalize<E>;\ndeclare type EndpointUpdateFunction<Source extends EndpointInterface, Updaters extends Record<string, any> = Record<string, any>> = (source: ResultEntry<Source>, ...args: Parameters<Source>) => {\n    [K in keyof Updaters]: (result: Updaters[K]) => Updaters[K];\n};\n\ndeclare type RHDispatch = (value: ActionTypes) => Promise<void>;\ninterface ConstructorProps {\n    dispatch?: RHDispatch;\n    globalCache?: DenormalizeCache;\n}\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/Controller\n */\ndeclare class Controller {\n    readonly dispatch: RHDispatch;\n    readonly globalCache: DenormalizeCache;\n    constructor({ dispatch, globalCache, }?: ConstructorProps);\n    /*************** Action Dispatchers ***************/\n    /**\n     * Fetches the endpoint with given args, updating the Rest Hooks cache with the response or error upon completion.\n     * @see https://resthooks.io/docs/api/Controller#fetch\n     */\n    fetch: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined> & {\n        update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    }>(endpoint: E, ...args_0: Parameters<E>) => ReturnType<E>;\n    /**\n     * Forces refetching and suspense on useResource with the same Endpoint and parameters.\n     * @see https://resthooks.io/docs/api/Controller#invalidate\n     */\n    invalidate: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined>>(endpoint: E, ...args: readonly [...Parameters<E>] | readonly [null]) => Promise<void>;\n    /**\n     * Resets the entire Rest Hooks cache. All inflight requests will not resolve.\n     * @see https://resthooks.io/docs/api/Controller#resetEntireStore\n     */\n    resetEntireStore: () => Promise<void>;\n    /**\n     * Stores response in cache for given Endpoint and args.\n     * @see https://resthooks.io/docs/api/Controller#receive\n     */\n    receive: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined> & {\n        update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    }>(endpoint: E, ...rest: readonly [...Parameters<E>, any]) => Promise<void>;\n    /**\n     * Stores the result of Endpoint and args as the error provided.\n     * @see https://resthooks.io/docs/api/Controller#receiveError\n     */\n    receiveError: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined> & {\n        update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    }>(endpoint: E, ...rest: readonly [...Parameters<E>, Error]) => Promise<void>;\n    /**\n     * Resolves an inflight fetch. `fetchedAt` should `fetch`'s `createdAt`\n     * @see https://resthooks.io/docs/api/Controller#resolve\n     */\n    resolve: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined> & {\n        update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    }>(endpoint: E, meta: {\n        args: readonly [...Parameters<E>];\n        response: Error;\n        fetchedAt: number;\n        error: true;\n    } | {\n        args: readonly [...Parameters<E>];\n        response: any;\n        fetchedAt: number;\n        error?: false | undefined;\n    }) => Promise<void>;\n    /**\n     * Marks a new subscription to a given Endpoint.\n     * @see https://resthooks.io/docs/api/Controller#subscribe\n     */\n    subscribe: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, undefined>>(endpoint: E, ...args: readonly [null] | readonly [...Parameters<E>]) => Promise<void>;\n    /**\n     * Marks completion of subscription to a given Endpoint.\n     * @see https://resthooks.io/docs/api/Controller#unsubscribe\n     */\n    unsubscribe: <E extends EndpointInterface<FetchFunction<any, any>, Schema | undefined, undefined>>(endpoint: E, ...args: readonly [null] | readonly [...Parameters<E>]) => Promise<void>;\n    /*************** More ***************/\n    snapshot: (state: State<unknown>, fetchedAt?: number) => SnapshotInterface;\n    getError: <E extends Pick<EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined>, \"key\">, Args extends readonly [null] | readonly [...Parameters<E[\"key\"]>]>(endpoint: E, ...rest: [...Args, State<unknown>]) => ErrorTypes$1 | undefined;\n    getResponse: <E extends Pick<EndpointInterface<FetchFunction<any, any>, Schema | undefined, true | undefined>, \"schema\" | \"key\" | \"invalidIfStale\">, Args extends readonly [null] | readonly [...Parameters<E[\"key\"]>]>(endpoint: E, ...rest: [...Args, State<unknown>]) => {\n        data: DenormalizeNullable<E[\"schema\"]>;\n        expiryStatus: ExpiryStatus;\n        expiresAt: number;\n    };\n    private getResults;\n}\n\ndeclare type ReceiveTypes = typeof RECEIVE_TYPE;\ndeclare type PK = string;\ninterface State<T> {\n    readonly entities: {\n        readonly [entityKey: string]: {\n            readonly [pk: string]: T;\n        } | undefined;\n    };\n    readonly indexes: NormalizedIndex;\n    readonly results: {\n        readonly [key: string]: unknown | PK[] | PK | undefined;\n    };\n    readonly meta: {\n        readonly [key: string]: {\n            readonly date: number;\n            readonly error?: ErrorTypes$1;\n            readonly expiresAt: number;\n            readonly prevExpiresAt?: number;\n            readonly invalidated?: boolean;\n            readonly errorPolicy?: 'soft' | undefined;\n        };\n    };\n    readonly entityMeta: {\n        readonly [entityKey: string]: {\n            readonly [pk: string]: {\n                readonly date: number;\n                readonly expiresAt: number;\n                readonly fetchedAt: number;\n            };\n        };\n    };\n    readonly optimistic: (ReceiveAction | OptimisticAction)[];\n    readonly lastReset: Date | number;\n}\ninterface ReceiveMeta<S extends Schema | undefined> {\n    schema?: S;\n    key: string;\n    args?: readonly any[];\n    updaters?: Record<string, UpdateFunction<S, any>>;\n    update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n    fetchedAt?: number;\n    date: number;\n    expiresAt: number;\n    errorPolicy?: (error: any) => 'soft' | undefined;\n}\ndeclare type ReceiveAction<Payload extends object | string | number | null = object | string | number | null, S extends Schema | undefined = any> = ErrorableFSAWithPayloadAndMeta<typeof RECEIVE_TYPE, Payload, ReceiveMeta<S>> & {\n    endpoint?: EndpointInterface;\n};\ndeclare type OptimisticAction<E extends EndpointInterface & {\n    update?: EndpointUpdateFunction<E>;\n} = EndpointInterface & {\n    update?: EndpointUpdateFunction<EndpointInterface>;\n}> = {\n    type: typeof OPTIMISTIC_TYPE;\n    meta: {\n        schema: E['schema'];\n        key: string;\n        args: readonly any[];\n        update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n        fetchedAt: number;\n        date: number;\n        expiresAt: number;\n        errorPolicy?: (error: any) => 'soft' | undefined;\n    };\n    endpoint: E;\n    error?: undefined;\n};\ninterface ResetAction {\n    type: typeof RESET_TYPE;\n    date: number | Date;\n}\ninterface FetchMeta<Payload extends object | string | number | null = object | string | number | null, S extends Schema | undefined = any> {\n    type: FetchShape<any, any>['type'];\n    schema?: S;\n    key: string;\n    args?: readonly any[];\n    updaters?: Record<string, UpdateFunction<S, any>>;\n    update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n    options?: EndpointExtraOptions;\n    throttle: boolean;\n    resolve: (value?: any | PromiseLike<any>) => void;\n    reject: (reason?: any) => void;\n    promise: PromiseLike<any>;\n    createdAt: number | Date;\n    optimisticResponse?: Payload;\n    nm?: boolean;\n}\ninterface FetchAction<Payload extends object | string | number | null = object | string | number | null, S extends Schema | undefined = any> extends FSAWithPayloadAndMeta<typeof FETCH_TYPE, () => Promise<Payload>, FetchMeta<any, any>> {\n    meta: FetchMeta<Payload, S>;\n    endpoint?: EndpointInterface;\n}\ninterface SubscribeAction extends FSAWithMeta<typeof SUBSCRIBE_TYPE, undefined, any> {\n    endpoint?: EndpointInterface;\n    meta: {\n        args?: readonly any[];\n        schema: Schema | undefined;\n        fetch: () => Promise<any>;\n        key: string;\n        options: EndpointExtraOptions | undefined;\n    };\n}\ninterface UnsubscribeAction extends FSAWithMeta<typeof UNSUBSCRIBE_TYPE, undefined, any> {\n    endpoint?: EndpointInterface;\n    meta: {\n        args?: readonly any[];\n        key: string;\n        options: EndpointExtraOptions | undefined;\n    };\n}\ninterface InvalidateAction extends FSAWithMeta<typeof INVALIDATE_TYPE, undefined, any> {\n    meta: {\n        key: string;\n    };\n}\ninterface GCAction {\n    type: typeof GC_TYPE;\n    entities: [string, string][];\n    results: string[];\n}\ndeclare type ResponseActions = ReceiveAction;\ndeclare type ActionTypes = FetchAction | OptimisticAction | ReceiveAction | SubscribeAction | UnsubscribeAction | InvalidateAction | ResetAction | GCAction;\ninterface Manager {\n    getMiddleware(): Middleware;\n    cleanup(): void;\n    init?: (state: State<any>) => void;\n}\ndeclare type Middleware = <R extends React.Reducer<any, any>>(options: MiddlewareAPI<R>) => (next: Dispatch<R>) => Dispatch<R>;\ninterface MiddlewareAPI<R extends React.Reducer<any, any> = React.Reducer<any, any>> {\n    getState: () => React.ReducerState<R>;\n    dispatch: Dispatch<R>;\n    controller: Controller;\n}\n\ndeclare class ResetError extends Error {\n    name: string;\n    constructor();\n}\n/** Handles all async network dispatches\n *\n * Dedupes concurrent requests by keeping track of all fetches in flight\n * and returning existing promises for requests already in flight.\n *\n * Interfaces with store via a redux-compatible middleware.\n */\ndeclare class NetworkManager implements Manager {\n    protected fetched: {\n        [k: string]: Promise<any>;\n    };\n    protected resolvers: {\n        [k: string]: (value?: any) => void;\n    };\n    protected rejectors: {\n        [k: string]: (value?: any) => void;\n    };\n    readonly dataExpiryLength: number;\n    readonly errorExpiryLength: number;\n    protected middleware: Middleware;\n    protected getState: () => State<unknown>;\n    cleanupDate?: number;\n    constructor(dataExpiryLength?: number, errorExpiryLength?: number);\n    /** Used by DevtoolsManager to determine whether to log an action */\n    skipLogging(action: ActionTypes): boolean;\n    /** On mount */\n    init(): void;\n    /** Ensures all promises are completed by rejecting remaining. */\n    cleanup(): void;\n    /** Clear all promise state */\n    protected clearAll(): void;\n    /** Clear promise state for a given key */\n    protected clear(key: string): void;\n    protected getLastReset(): number;\n    /** Called when middleware intercepts 'rest-hooks/fetch' action.\n     *\n     * Will then start a promise for a key and potentially start the network\n     * fetch.\n     *\n     * Uses throttle only when instructed by action meta. This is valuable\n     * for ensures mutation requests always go through.\n     */\n    protected handleFetch(action: FetchAction, dispatch: Dispatch<any>, controller: Controller): Promise<string | number | void | object | null>;\n    /** Called when middleware intercepts a receive action.\n     *\n     * Will resolve the promise associated with receive key.\n     */\n    protected handleReceive(action: ReceiveAction): void;\n    /** Attaches NetworkManager to store\n     *\n     * Intercepts 'rest-hooks/fetch' actions to start requests.\n     *\n     * Resolve/rejects a request when matching 'rest-hooks/receive' event\n     * is seen.\n     */\n    getMiddleware<T extends NetworkManager>(this: T): Middleware;\n    /** Ensures only one request for a given key is in flight at any time\n     *\n     * Uses key to either retrieve in-flight promise, or if not\n     * create a new promise and call fetch.\n     *\n     * Note: The new promise is not actually tied to fetch at all,\n     * but is resolved when the expected 'recieve' action is processed.\n     * This ensures promises are resolved only once their data is processed\n     * by the reducer.\n     */\n    protected throttle(key: string, fetch: () => Promise<any>): Promise<any>;\n}\n\ndeclare const initialState: State<unknown>;\ndeclare function createReducer(controller: Controller): (state: State<unknown> | undefined, action: ActionTypes) => State<unknown>;\n\n/**\n * @deprecated use createReducer instead\n */\ndeclare const reducer: (state: State<unknown> | undefined, action: ActionTypes) => State<unknown>;\n//# sourceMappingURL=reducerInstance.d.ts.map\n\ndeclare function applyManager(managers: Manager[], controller: Controller): Middleware$1[];\n\n/**\n * @deprecated use https://resthooks.io/docs/api/Controller#getResponse directly instead\n *\n * Selects the denormalized form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n *\n * @returns [denormalizedValue, ready]\n */\ndeclare function useDenormalized<Shape extends Pick<ReadShape<Schema | undefined, any>, 'getFetchKey' | 'schema' | 'options'>>(shape: Shape, params: ParamsFromShape<Shape> | null, state: State<any>, \n/** @deprecated */\ndenormalizeCache?: any): {\n    data: DenormalizeNullable<Shape['schema']>;\n    expiryStatus: ExpiryStatus;\n    expiresAt: number;\n};\n\ninterface ProviderProps {\n    children: React__default.ReactNode;\n    managers: Manager[];\n    initialState: State<unknown>;\n    Controller: typeof Controller;\n}\n/**\n * Controller managing state of the cache and coordinating network requests.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({ children, managers, initialState, Controller, }: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n    var defaultProps: {\n        managers: Manager[];\n        initialState: State<unknown>;\n        Controller: typeof Controller;\n    };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\n/**\n * Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetcher<Shape extends FetchShape<Schema, Readonly<object>, any>>(fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n}, throttle?: boolean): <UpdateParams extends OptimisticUpdateParams<SchemaFromShape<Shape>, FetchShape<any, any, any>>[]>(a: Parameters<Shape['fetch']>[0], b?: Parameters<Shape['fetch']>[1], updateParams?: UpdateParams | undefined) => ReturnFromShape<typeof fetchShape>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<E extends Pick<EndpointInterface<FetchFunction, Schema | undefined, undefined>, 'key' | 'schema' | 'invalidIfStale'> | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends {} ? DenormalizeNullable<E['schema']> : E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n\n/**\n * Request a resource if it is not in cache.\\\n * @see https://resthooks.io/docs/api/useRetrieve\n */\ndeclare function useRetrieve<Shape extends ReadShape<any, any>>(fetchShape: Shape, params: ParamsFromShape<Shape> | null, triggerFetch?: boolean, entitiesExpireAt?: number): any;\n\ndeclare type ResourceReturn<P, S extends {\n    fetch: any;\n    schema: any;\n}> = CondNull$1<P, S['schema'] extends undefined ? ResolveType<S['fetch']> | undefined : DenormalizeNullable<S['schema']>, S['schema'] extends undefined ? ResolveType<S['fetch']> : Denormalize<S['schema']>>;\ndeclare type CondNull$1<P, A, B> = P extends null ? A : B;\n/**\n * Ensure a resource is available.\n * Suspends until it is.\n *\n * `useResource` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useresource\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null>(v1: readonly [S1, P1]): [ResourceReturn<P1, S1>];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2]): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>];\ndeclare function useResource<S extends ReadShape<any, any>, P extends ParamsFromShape<S> | null>(fetchShape: S, params: P): ResourceReturn<P, S>;\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3]): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>, ResourceReturn<P3, S3>];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null, S15 extends ReadShape<any, any>, P15 extends ParamsFromShape<S15> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14], v15: readonly [S15, P15]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>,\n    ResourceReturn<P15, S15>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null, S15 extends ReadShape<any, any>, P15 extends ParamsFromShape<S15> | null, S16 extends ReadShape<any, any>, P16 extends ParamsFromShape<S16> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14], v15: readonly [S15, P15], v16: readonly [S16, P16]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>,\n    ResourceReturn<P15, S15>,\n    ResourceReturn<P16, S16>\n];\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined> | ReadShape<any, any>, Args extends (E extends (...args: any) => any ? readonly [...Parameters<E>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): void;\n\n/**\n * Gets meta for a fetch key.\n * @see https://resthooks.io/docs/api/useMeta\n */\ndeclare function useMeta<E extends Pick<EndpointInterface<FetchFunction>, 'key'> | Pick<FetchShape<any, any>, 'getFetchKey'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): {\n    readonly date: number;\n    readonly error?: ErrorTypes$1 | undefined;\n    readonly expiresAt: number;\n    readonly prevExpiresAt?: number | undefined;\n    readonly invalidated?: boolean | undefined;\n    readonly errorPolicy?: \"soft\" | undefined;\n} | null;\n\ndeclare type ErrorTypes = NetworkError | UnknownError;\ndeclare type UseErrorReturn<P> = P extends [null] ? undefined : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<E extends Pick<EndpointInterface<FetchFunction, Schema | undefined, undefined>, 'key' | 'schema' | 'invalidIfStale'> | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): UseErrorReturn<typeof args>;\n\n/**\n * Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidator<Shape extends ReadShape<any, any>>(fetchShape: Shape): (params: ParamsFromShape<Shape> | null) => void;\n\n/**\n * Returns a function to completely clear the cache of all entries\n * @deprecated use https://resthooks.io/docs/api/Controller#resetEntireStore\n */\ndeclare function useResetter(): () => void;\n\n/** Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetchDispatcher(throttle?: boolean): <Shape extends FetchShape<Schema, Readonly<object>, any>, UpdateParams extends OptimisticUpdateParams<SchemaFromShape<Shape>, FetchShape<any, any, any>>[]>(fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n}, params: ParamsFromShape<Shape>, body: BodyFromShape<Shape>, updateParams?: UpdateParams | undefined) => ReturnFromShape<typeof fetchShape>;\n\n/** Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidateDispatcher(): <Shape extends ReadShape<any, any>>(fetchShape: Shape, params: ParamsFromShape<Shape>) => void;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): Args extends [null] ? E['schema'] extends Exclude<Schema, null> ? DenormalizeNullable<E['schema']> : undefined : E['schema'] extends Exclude<Schema, null> ? Denormalize<E['schema']> : ResolveType<E>;\n\n/** @deprecated use https://resthooks.io/docs/api/Controller#getResponse */\ndeclare function hasUsableData(fetchShape: Pick<FetchShape<any>, 'options'>, cacheReady: boolean, deleted: boolean, invalidated?: boolean): boolean;\n\ndeclare type CondNull<P, A, B> = P extends null ? A : B;\ndeclare type StatefulReturn<S extends Schema | undefined, P> = CondNull<P, {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n}, {\n    data: Denormalize<S>;\n    loading: false;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: true;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: ErrorTypes$1;\n}>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/guides/no-suspense\n */\ndeclare function useDLE<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends undefined ? {\n    data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n    loading: boolean;\n    error: ErrorTypes$1 | undefined;\n} : StatefulReturn<E['schema'], Args[0]>;\n\ndeclare const StateContext: React$1.Context<State<unknown>>;\ndeclare const DispatchContext: React$1.Context<(value: ActionTypes) => Promise<void>>;\ndeclare const DenormalizeCacheContext: React$1.Context<DenormalizeCache>;\ndeclare const ControllerContext: React$1.Context<Controller>;\n\ninterface Options$2<Shape extends FetchShape<Schema | undefined, Readonly<object>, Readonly<object | string> | void>> {\n    params: ParamsFromShape<Shape>;\n    body?: BodyFromShape<Shape>;\n    throttle: boolean;\n    updateParams?: OptimisticUpdateParams<SchemaFromShape<Shape>, FetchShape<Schema | undefined, any, any>>[] | undefined;\n}\n/** Requesting a fetch to begin\n *\n * @param fetchShape\n * @param param1 { params, body, throttle, updateParams }\n */\ndeclare function createFetch<Shape extends FetchShape<Schema | undefined, Readonly<object>, Readonly<object | string> | void>>(fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n}, { params, body, throttle, updateParams }: Options$2<Shape>): FetchAction;\n\ninterface Options$1<Payload extends object | string | number | null = object | string | number | null, S extends Schema | undefined = any> extends Pick<FetchAction<Payload, S>['meta'], 'schema' | 'key' | 'type' | 'updaters' | 'update' | 'args'> {\n    dataExpiryLength: NonNullable<EndpointExtraOptions['dataExpiryLength']>;\n    fetchedAt?: number;\n}\n/** Update state with data\n *\n * @param data\n * @param param1 { schema, key, type, updaters, dataExpiryLength }\n */\ndeclare function createReceive<Payload extends object | string | number | null = object | string | number | null, S extends Schema | undefined = any>(data: Payload, { schema, key, args, updaters, fetchedAt, update, dataExpiryLength, }: Options$1<Payload, S>): ReceiveAction<Payload, S>;\n\ninterface Options<S extends Schema | undefined = any> extends Pick<FetchAction<any, S>['meta'], 'schema' | 'key' | 'options'> {\n    errorExpiryLength: NonNullable<EndpointExtraOptions['errorExpiryLength']>;\n    fetchedAt?: number;\n}\ndeclare function createReceiveError<S extends Schema | undefined = any>(error: Error, { schema, key, options, errorExpiryLength, fetchedAt }: Options<S>): ReceiveAction;\n\nexport { AbstractInstanceType, ActionTypes, _default as BackupBoundary, BodyFromShape, CacheProvider, Controller, ControllerContext, DeleteShape, DenormalizeCacheContext, Dispatch, DispatchContext, EndpointInterface, EndpointUpdateFunction, EntityInterface, ErrorTypes$1 as ErrorTypes, ExpiryStatus, FetchAction, FetchShape, GCAction, InvalidateAction, Manager, Middleware, MiddlewareAPI, MutateShape, NetworkError, NetworkManager, OptimisticAction, PK, ParamsFromShape, ReadShape, ReceiveAction, ReceiveMeta, ReceiveTypes, ResetAction, ResetError, ResolveType, ResponseActions, ResultEntry, ReturnFromShape, Schema, SetShapeParams, State, StateContext, SubscribeAction, UnknownError, UnsubscribeAction, UpdateFunction, internal_d as __INTERNAL__, actionTypes_d as actionTypes, applyManager, createFetch, createReceive, createReceiveError, createReducer, hasUsableData, initialState, reducer, useCache, useController, useDLE, useDenormalized, useError, useFetch, useFetchDispatcher, useFetcher, useInvalidateDispatcher, useInvalidator, useMeta, usePromisifiedDispatch, useResetter, useResource, useRetrieve, useSubscription, useSuspense };\n"}}]);