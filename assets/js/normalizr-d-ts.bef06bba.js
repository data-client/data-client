(self.webpackChunk=self.webpackChunk||[]).push([[12192],{14991:e=>{e.exports="declare type Schema =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema[]\n  | SchemaSimple\n  | Serializable;\ndeclare type Serializable<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: Record<string, unknown>,\n    unvisit: UnvisitFunction,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface UnvisitFunction {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction;\n  setLocal?: (entity: any) => void;\n}\ndeclare type NormalizedIndex = {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n};\n\n/** Link in a chain */\ndeclare class Link<K extends object, V> {\n  children: WeakMap<K, Link<K, V>>;\n  value?: V;\n}\n/** Maps from a list of objects (referentially) to any value\n *\n * If *any* members of the list get claned up, so does that key/value pair get removed.\n */\ndeclare class WeakListMap<K extends object, V> {\n  readonly first: WeakMap<K, Link<K, V>>;\n  delete(key: K[]): boolean;\n  get(key: K[]): V | undefined;\n  has(key: K[]): boolean;\n  set(key: K[], value: V): WeakListMap<K, V>;\n  protected traverse(key: K[]): Link<K, V> | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ndeclare type NormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Normalize$1<S[K]> : S[K];\n};\ndeclare type NormalizedNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? NormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n  fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ninterface DenormalizeCache {\n  entities: {\n    [key: string]: {\n      [pk: string]: WeakListMap<object, EntityInterface>;\n    };\n  };\n  results: {\n    [key: string]: WeakListMap<object, any>;\n  };\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type NormalizeReturnType<T> = T extends (...args: any) => infer R\n  ? R\n  : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U>\n  ? U\n  : S extends RecordClass\n  ? AbstractInstanceType<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['denormalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject<S>\n  : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any>\n  ? DenormalizeNullableNestedSchema<S> | undefined\n  : S extends RecordClass\n  ? DenormalizeNullableNestedSchema<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['_denormalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject<S>\n  : S;\ndeclare type Normalize$1<S> = S extends EntityInterface\n  ? string\n  : S extends RecordClass\n  ? NormalizeObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['normalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizeObject<S>\n  : S;\ndeclare type NormalizeNullable$1<S> = S extends EntityInterface\n  ? string | undefined\n  : S extends RecordClass\n  ? NormalizedNullableObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['_normalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizedNullableObject<S>\n  : S;\ndeclare type NormalizedSchema<E, R> = {\n  entities: E;\n  result: R;\n  indexes: NormalizedIndex;\n  entityMeta: {\n    readonly [entityKey: string]: {\n      readonly [pk: string]: {\n        readonly date: number;\n        readonly expiresAt: number;\n        readonly fetchedAt: number;\n      };\n    };\n  };\n};\n\ndeclare type DenormalizeReturn<S extends Schema> =\n  | [\n      denormalized: Denormalize$1<S>,\n      found: true,\n      deleted: false,\n      resolvedEntities: Record<string, Record<string, any>>,\n    ]\n  | [\n      denormalized: DenormalizeNullable$1<S>,\n      found: boolean,\n      deleted: true,\n      resolvedEntities: Record<string, Record<string, any>>,\n    ]\n  | [\n      denormalized: DenormalizeNullable$1<S>,\n      found: false,\n      deleted: boolean,\n      resolvedEntities: Record<string, Record<string, any>>,\n    ];\ndeclare const denormalize: <S extends Schema>(\n  input: unknown,\n  schema: S | undefined,\n  entities: any,\n  entityCache?: DenormalizeCache['entities'],\n  resultCache?: WeakListMap<object, any>,\n) => DenormalizeReturn<S>;\n\ndeclare const normalize: <\n  S extends Schema = Schema,\n  E extends Record<string, Record<string, any> | undefined> = Record<\n    string,\n    Record<string, any>\n  >,\n  R = NormalizeNullable$1<S>,\n>(\n  input: any,\n  schema?: S | undefined,\n  existingEntities?: Readonly<E>,\n  existingIndexes?: Readonly<NormalizedIndex>,\n  existingEntityMeta?: {\n    readonly [entityKey: string]: {\n      readonly [pk: string]: {\n        readonly date: number;\n        readonly expiresAt: number;\n        readonly fetchedAt: number;\n      };\n    };\n  },\n  meta?: {\n    expiresAt: number;\n    date: number;\n    fetchedAt?: number;\n  },\n) => NormalizedSchema<E, R>;\n\ndeclare function isEntity(schema: Schema): schema is EntityInterface;\n\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\ndeclare function inferResults<S extends Schema>(\n  schema: S,\n  args: any[],\n  indexes: NormalizedIndex,\n): NormalizeNullable$1<S>;\n\ndeclare const DELETED: unique symbol;\n\ninterface NetworkError extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<\n  F extends FetchFunction,\n  S extends Schema | undefined,\n> = S extends undefined\n  ? ReturnType<F>\n  : ReturnType<F> extends unknown\n  ? Promise<Denormalize$1<S>>\n  : ReturnType<F>;\n\ninterface IndexInterface<S extends Schema = Schema, P = object> {\n  key(params?: P): string;\n  readonly schema: S;\n}\ndeclare type ArrayElement<ArrayType extends unknown[] | readonly unknown[]> =\n  ArrayType[number];\ndeclare type IndexParams<S extends Schema> = S extends {\n  indexes: readonly string[];\n}\n  ? {\n      [K in Extract<\n        ArrayElement<S['indexes']>,\n        keyof AbstractInstanceType<S>\n      >]?: AbstractInstanceType<S>[K];\n    }\n  : Readonly<object>;\n\ndeclare const enum ExpiryStatus {\n  Invalid = 1,\n  InvalidIfStale = 2,\n  Valid = 3,\n}\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n  getResponse: <\n    E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: DenormalizeNullable$1<E['schema']>;\n    expiryStatus: ExpiryStatusInterface;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes | undefined;\n  readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions<F> {\n  (...args: Parameters<F>): InferReturn<F, S>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface,\n    ...args: Parameters<F>\n  ): ResolveType<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\ndeclare type OptimisticUpdateParams<\n  SourceSchema extends Schema | undefined,\n  Dest extends EndpointInterface<FetchFunction, Schema, any>,\n> = [\n  Dest,\n  Parameters<Dest>[0],\n  UpdateFunction<SourceSchema, Exclude<Dest['schema'], undefined>>,\n];\ndeclare type UpdateFunction<\n  SourceSchema extends Schema | undefined,\n  DestSchema extends Schema,\n> = (\n  sourceResults: Normalize$1<SourceSchema>,\n  destResults: Normalize$1<DestSchema> | undefined,\n) => Normalize$1<DestSchema>;\n/** To change values on the server */\ninterface MutateEndpoint<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n> extends EndpointInterface<F, S, true> {\n  sideEffect: true;\n}\n/** For retrieval requests */\ndeclare type ReadEndpoint<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n> = EndpointInterface<F, S, undefined>;\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Denormalize$1<S>\n    : Denormalize$1<Extract<S, EntityInterface[]>>\n  : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? DenormalizeNullable$1<S>\n    : DenormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : DenormalizeNullable$1<Extract<S, EntityInterface>>;\ndeclare type Normalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Normalize$1<S>\n    : Normalize$1<Extract<S, EntityInterface[]>>\n  : Normalize$1<Extract<S, EntityInterface>>;\ndeclare type NormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? NormalizeNullable$1<S>\n    : NormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : NormalizeNullable$1<Extract<S, EntityInterface>>;\n\nexport {\n  AbstractInstanceType,\n  ArrayElement,\n  DELETED,\n  Denormalize,\n  DenormalizeCache,\n  DenormalizeNullable,\n  DenormalizeReturnType,\n  EndpointExtraOptions,\n  EndpointInterface,\n  EntityInterface,\n  ErrorTypes,\n  ExpiryStatus,\n  ExpiryStatusInterface,\n  FetchFunction,\n  IndexInterface,\n  IndexParams,\n  InferReturn,\n  MutateEndpoint,\n  NetworkError,\n  Normalize,\n  NormalizeNullable,\n  NormalizeReturnType,\n  NormalizedIndex,\n  NormalizedSchema,\n  OptimisticUpdateParams,\n  ReadEndpoint,\n  ResolveType,\n  Schema,\n  SchemaClass,\n  SchemaSimple,\n  Serializable,\n  SnapshotInterface,\n  UnknownError,\n  UnvisitFunction,\n  UpdateFunction,\n  WeakListMap,\n  denormalize,\n  inferResults,\n  isEntity,\n  normalize,\n};\n"}}]);