(self.webpackChunk=self.webpackChunk||[]).push([[30007],{90734:e=>{e.exports="import {\n  ErrorFluxStandardActionWithPayloadAndMeta,\n  FSA,\n  FSAWithPayloadAndMeta,\n  FSAWithMeta,\n} from 'flux-standard-action';\n\ndeclare type Schema =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema[]\n  | SchemaSimple\n  | Serializable;\ndeclare type Serializable<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n    entities: EntityTable,\n  ): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface UnvisitFunction {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction;\n  setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n}\ninterface EntityTable {\n  [entityKey: string]:\n    | {\n        [pk: string]: unknown;\n      }\n    | undefined;\n}\n\n/** Link in a chain */\ndeclare class Link<K extends object, V> {\n  children: WeakMap<K, Link<K, V>>;\n  value?: V;\n}\n/** Maps from a list of objects (referentially) to any value\n *\n * If *any* members of the list get claned up, so does that key/value pair get removed.\n */\ndeclare class WeakListMap<K extends object, V> {\n  readonly first: WeakMap<K, Link<K, V>>;\n  delete(key: K[]): boolean;\n  get(key: K[]): V | undefined;\n  has(key: K[]): boolean;\n  set(key: K[], value: V): WeakListMap<K, V>;\n  protected traverse(key: K[]): Link<K, V> | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ndeclare type NormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Normalize$1<S[K]> : S[K];\n};\ndeclare type NormalizedNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? NormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n  fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ninterface DenormalizeCache {\n  entities: {\n    [key: string]: {\n      [pk: string]: WeakListMap<object, EntityInterface>;\n    };\n  };\n  results: {\n    [key: string]: WeakListMap<object, any>;\n  };\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type NormalizeReturnType<T> = T extends (...args: any) => infer R\n  ? R\n  : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U>\n  ? U\n  : S extends RecordClass\n  ? AbstractInstanceType<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['denormalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject<S>\n  : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any>\n  ? DenormalizeNullableNestedSchema<S> | undefined\n  : S extends RecordClass\n  ? DenormalizeNullableNestedSchema<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['_denormalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject<S>\n  : S;\ndeclare type Normalize$1<S> = S extends EntityInterface\n  ? string\n  : S extends RecordClass\n  ? NormalizeObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['normalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizeObject<S>\n  : S;\ndeclare type NormalizeNullable$1<S> = S extends EntityInterface\n  ? string | undefined\n  : S extends RecordClass\n  ? NormalizedNullableObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['_normalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizedNullableObject<S>\n  : S;\n\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\ndeclare function inferResults<S extends Schema>(\n  schema: S,\n  args: any[],\n  indexes: NormalizedIndex,\n  entities?: EntityTable,\n): NormalizeNullable$1<S>;\n\ndeclare const DELETED: unique symbol;\n\ninterface NetworkError extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<\n  F extends FetchFunction,\n  S extends Schema | undefined,\n> = S extends undefined\n  ? ReturnType<F>\n  : ReturnType<F> extends unknown\n  ? Promise<Denormalize$1<S>>\n  : ReturnType<F>;\n\ndeclare const enum ExpiryStatus {\n  Invalid = 1,\n  InvalidIfStale = 2,\n  Valid = 3,\n}\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n  getResponse: <\n    E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: any;\n    expiryStatus: ExpiryStatusInterface;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes | undefined;\n  readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions<F> {\n  (...args: Parameters<F>): InferReturn<F, S>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface,\n    ...args: Parameters<F>\n  ): ResolveType<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\ndeclare type UpdateFunction<\n  SourceSchema extends Schema | undefined,\n  DestSchema extends Schema,\n> = (\n  sourceResults: Normalize$1<SourceSchema>,\n  destResults: Normalize$1<DestSchema> | undefined,\n) => Normalize$1<DestSchema>;\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Denormalize$1<S>\n    : Denormalize$1<Extract<S, EntityInterface[]>>\n  : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? DenormalizeNullable$1<S>\n    : DenormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : DenormalizeNullable$1<Extract<S, EntityInterface>>;\ndeclare type Normalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Normalize$1<S>\n    : Normalize$1<Extract<S, EntityInterface[]>>\n  : Normalize$1<Extract<S, EntityInterface>>;\ndeclare type NormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? NormalizeNullable$1<S>\n    : NormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : NormalizeNullable$1<Extract<S, EntityInterface>>;\n\ndeclare const RIC: (cb: (...args: any[]) => void, options: any) => void;\n\ndeclare type ResultEntry<E extends EndpointInterface> =\n  E['schema'] extends undefined ? ResolveType<E> : Normalize<E>;\ndeclare type EndpointUpdateFunction<\n  Source extends EndpointInterface,\n  Updaters extends Record<string, any> = Record<string, any>,\n> = (\n  source: ResultEntry<Source>,\n  ...args: Parameters<Source>\n) => {\n  [K in keyof Updaters]: (result: Updaters[K]) => Updaters[K];\n};\n\ndeclare type RHDispatch = (value: ActionTypes) => Promise<void>;\ninterface ConstructorProps {\n  dispatch?: RHDispatch;\n  globalCache?: DenormalizeCache;\n}\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/Controller\n */\ndeclare class Controller {\n  readonly dispatch: RHDispatch;\n  readonly globalCache: DenormalizeCache;\n  constructor({ dispatch, globalCache }?: ConstructorProps);\n  /*************** Action Dispatchers ***************/\n  /**\n   * Fetches the endpoint with given args, updating the Rest Hooks cache with the response or error upon completion.\n   * @see https://resthooks.io/docs/api/Controller#fetch\n   */\n  fetch: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...args_0: Parameters<E>\n  ) => ReturnType<E>;\n\n  /**\n   * Forces refetching and suspense on useResource with the same Endpoint and parameters.\n   * @see https://resthooks.io/docs/api/Controller#invalidate\n   */\n  invalidate: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [...Parameters<E>] | readonly [null]\n  ) => Promise<void>;\n\n  /**\n   * Resets the entire Rest Hooks cache. All inflight requests will not resolve.\n   * @see https://resthooks.io/docs/api/Controller#resetEntireStore\n   */\n  resetEntireStore: () => Promise<void>;\n  /**\n   * Stores response in cache for given Endpoint and args.\n   * @see https://resthooks.io/docs/api/Controller#receive\n   */\n  receive: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...rest: readonly [...Parameters<E>, any]\n  ) => Promise<void>;\n\n  /**\n   * Stores the result of Endpoint and args as the error provided.\n   * @see https://resthooks.io/docs/api/Controller#receiveError\n   */\n  receiveError: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...rest: readonly [...Parameters<E>, Error]\n  ) => Promise<void>;\n\n  /**\n   * Resolves an inflight fetch. `fetchedAt` should `fetch`'s `createdAt`\n   * @see https://resthooks.io/docs/api/Controller#resolve\n   */\n  resolve: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    meta:\n      | {\n          args: readonly [...Parameters<E>];\n          response: Error;\n          fetchedAt: number;\n          error: true;\n        }\n      | {\n          args: readonly [...Parameters<E>];\n          response: any;\n          fetchedAt: number;\n          error?: false | undefined;\n        },\n  ) => Promise<void>;\n\n  /**\n   * Marks a new subscription to a given Endpoint.\n   * @see https://resthooks.io/docs/api/Controller#subscribe\n   */\n  subscribe: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [null] | readonly [...Parameters<E>]\n  ) => Promise<void>;\n\n  /**\n   * Marks completion of subscription to a given Endpoint.\n   * @see https://resthooks.io/docs/api/Controller#unsubscribe\n   */\n  unsubscribe: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [null] | readonly [...Parameters<E>]\n  ) => Promise<void>;\n\n  /*************** More ***************/\n  /**\n   * Gets the latest state snapshot that is fully committed.\n   *\n   * This can be useful for imperative use-cases like event handlers.\n   * This should *not* be used to render; instead useSuspense() or useCache()\n   * @see https://resthooks.io/docs/api/Controller#getState\n   */\n  getState: () => State<unknown>;\n  snapshot: (state: State<unknown>, fetchedAt?: number) => SnapshotInterface;\n  /**\n   * Gets the error, if any, for a given endpoint. Returns undefined for no errors.\n   * @see https://resthooks.io/docs/api/Controller#getError\n   */\n  getError: <\n    E extends Pick<\n      EndpointInterface<\n        FetchFunction<any, any>,\n        Schema | undefined,\n        true | undefined\n      >,\n      'key'\n    >,\n    Args extends readonly [null] | readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...rest: [...Args, State<unknown>]\n  ) => ErrorTypes | undefined;\n\n  /**\n   * Gets the (globally referentially stable) response for a given endpoint/args pair from state given.\n   * @see https://resthooks.io/docs/api/Controller#getResponse\n   */\n  getResponse: <\n    E extends Pick<\n      EndpointInterface<\n        FetchFunction<any, any>,\n        Schema | undefined,\n        true | undefined\n      >,\n      'key' | 'schema' | 'invalidIfStale'\n    >,\n    Args extends readonly [null] | readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...rest: [...Args, State<unknown>]\n  ) => {\n    data: DenormalizeNullable<E['schema']>;\n    expiryStatus: ExpiryStatus;\n    expiresAt: number;\n  };\n\n  private getResults;\n}\n\ninterface MiddlewareAPI$1<R extends Reducer<any, any> = Reducer<any, any>> {\n  getState: () => ReducerState<R>;\n  dispatch: Dispatch<R>;\n  controller: Controller;\n}\ndeclare type Dispatch<R extends Reducer<any, any>> = (\n  action: ReducerAction<R>,\n) => Promise<void>;\ndeclare type Middleware$1 = <R extends Reducer<any, any>>({\n  dispatch,\n}: MiddlewareAPI$1<R>) => (next: Dispatch<R>) => Dispatch<R>;\ndeclare type Reducer<S, A> = (prevState: S, action: A) => S;\ndeclare type ReducerState<R extends Reducer<any, any>> = R extends Reducer<\n  infer S,\n  any\n>\n  ? S\n  : never;\ndeclare type ReducerAction<R extends Reducer<any, any>> = R extends Reducer<\n  any,\n  infer A\n>\n  ? A\n  : never;\n\ndeclare type ErrorableFSAWithPayloadAndMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n  CustomError extends Error = Error,\n> =\n  | ErrorFluxStandardActionWithPayloadAndMeta<Type, CustomError, Meta>\n  | NoErrorFluxStandardActionWithPayloadAndMeta<Type, Payload, Meta>;\ninterface NoErrorFluxStandardAction<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends FSA<Type, Payload, Meta> {\n  error?: false;\n}\n/**\n * A Flux Standard action with a required payload property.\n */\ninterface NoErrorFluxStandardActionWithPayload<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n  /**\n   * The required `payload` property MAY be any type of value.\n   * It represents the payload of the action.\n   * Any information about the action that is not the type or status of the action should be part of the `payload` field.\n   * By convention, if `error` is `true`, the `payload` SHOULD be an error object.\n   * This is akin to rejecting a promise with an error object.\n   */\n  payload: Payload;\n}\n/**\n * A Flux Standard action with a required metadata property.\n */\ninterface NoErrorFluxStandardActionWithMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n  /**\n   * The required `meta` property MAY be any type of value.\n   * It is intended for any extra information that is not part of the payload.\n   */\n  meta: Meta;\n}\n/**\n * A Flux Standard action with required payload and metadata properties.\n */\ndeclare type NoErrorFluxStandardActionWithPayloadAndMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> = NoErrorFluxStandardActionWithPayload<Type, Payload, Meta> &\n  NoErrorFluxStandardActionWithMeta<Type, Payload, Meta>;\n\n/** Defines the shape of a network request */\ninterface FetchShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response = any,\n> {\n  readonly type: 'read' | 'mutate' | 'delete';\n  fetch(params: Params, body?: Body): Promise<Response>;\n  getFetchKey(params: Params): string;\n  readonly schema: S;\n  readonly options?: EndpointExtraOptions;\n}\n/** To change values on the server */\ninterface MutateShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, Body, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, body: Body): Promise<Response>;\n}\n/** Removes entities */\ninterface DeleteShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, ...args: any): Promise<Response>;\n}\n/** For retrieval requests */\ninterface ReadShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'read';\n  fetch(params: Params): Promise<Response>;\n}\n\n/** Sets a FetchShape's Param type.\n * Useful to constrain acceptable params (second arg) in hooks like useResource().\n *\n * @param [Shape] FetchShape to act upon\n * @param [Params] what to set the Params to\n */\ndeclare type SetShapeParams<\n  Shape extends FetchShape<any, any, any>,\n  Params extends Readonly<object>,\n> = {\n  [K in keyof Shape]: Shape[K];\n} & (Shape['fetch'] extends (first: any, ...rest: infer Args) => infer Return\n  ? {\n      fetch: (first: Params, ...rest: Args) => Return;\n    }\n  : never);\n/** Get the Params type for a given Shape */\ndeclare type ParamsFromShape<S> = S extends {\n  fetch: (first: infer A, ...rest: any) => any;\n}\n  ? A\n  : S extends {\n      getFetchKey: (first: infer A, ...rest: any) => any;\n    }\n  ? A\n  : never;\n/** Get the Schema type for a given Shape */\ndeclare type SchemaFromShape<\n  F extends FetchShape<Schema | undefined, any, any>,\n> = F['schema'];\n/** Get the Body type for a given Shape */\ndeclare type BodyFromShape<F extends FetchShape<any, any, any>> = Parameters<\n  F['fetch']\n>[1];\ndeclare type OptimisticUpdateParams<\n  SourceSchema extends Schema | undefined,\n  DestShape extends FetchShape<any, any, any>,\n> = [\n  DestShape,\n  ParamsFromShape<DestShape>,\n  UpdateFunction<SourceSchema, SchemaFromShape<DestShape>>,\n];\ndeclare type ReturnFromShape<S extends FetchShape<any, any, any>> = ReturnType<\n  S['fetch']\n> extends unknown\n  ? Promise<Denormalize<S['schema']>>\n  : ReturnType<S['fetch']>;\n\ndeclare const FETCH_TYPE: 'rest-hooks/fetch';\ndeclare const RECEIVE_TYPE: 'rest-hooks/receive';\ndeclare const OPTIMISTIC_TYPE: 'rest-hooks/optimistic';\ndeclare const RESET_TYPE: 'rest-hooks/reset';\ndeclare const SUBSCRIBE_TYPE: 'rest-hooks/subscribe';\ndeclare const UNSUBSCRIBE_TYPE: 'rest-hook/unsubscribe';\ndeclare const INVALIDATE_TYPE: 'rest-hooks/invalidate';\ndeclare const GC_TYPE: 'rest-hooks/gc';\n\ndeclare const actionTypes_d_FETCH_TYPE: typeof FETCH_TYPE;\ndeclare const actionTypes_d_RECEIVE_TYPE: typeof RECEIVE_TYPE;\ndeclare const actionTypes_d_OPTIMISTIC_TYPE: typeof OPTIMISTIC_TYPE;\ndeclare const actionTypes_d_RESET_TYPE: typeof RESET_TYPE;\ndeclare const actionTypes_d_SUBSCRIBE_TYPE: typeof SUBSCRIBE_TYPE;\ndeclare const actionTypes_d_UNSUBSCRIBE_TYPE: typeof UNSUBSCRIBE_TYPE;\ndeclare const actionTypes_d_INVALIDATE_TYPE: typeof INVALIDATE_TYPE;\ndeclare const actionTypes_d_GC_TYPE: typeof GC_TYPE;\ndeclare namespace actionTypes_d {\n  export {\n    actionTypes_d_FETCH_TYPE as FETCH_TYPE,\n    actionTypes_d_RECEIVE_TYPE as RECEIVE_TYPE,\n    actionTypes_d_OPTIMISTIC_TYPE as OPTIMISTIC_TYPE,\n    actionTypes_d_RESET_TYPE as RESET_TYPE,\n    actionTypes_d_SUBSCRIBE_TYPE as SUBSCRIBE_TYPE,\n    actionTypes_d_UNSUBSCRIBE_TYPE as UNSUBSCRIBE_TYPE,\n    actionTypes_d_INVALIDATE_TYPE as INVALIDATE_TYPE,\n    actionTypes_d_GC_TYPE as GC_TYPE,\n  };\n}\n\ndeclare type ReceiveTypes = typeof RECEIVE_TYPE;\ndeclare type PK = string;\ninterface State<T> {\n  readonly entities: {\n    readonly [entityKey: string]:\n      | {\n          readonly [pk: string]: T;\n        }\n      | undefined;\n  };\n  readonly indexes: NormalizedIndex;\n  readonly results: {\n    readonly [key: string]: unknown | PK[] | PK | undefined;\n  };\n  readonly meta: {\n    readonly [key: string]: {\n      readonly date: number;\n      readonly error?: ErrorTypes;\n      readonly expiresAt: number;\n      readonly prevExpiresAt?: number;\n      readonly invalidated?: boolean;\n      readonly errorPolicy?: 'hard' | 'soft' | undefined;\n    };\n  };\n  readonly entityMeta: {\n    readonly [entityKey: string]: {\n      readonly [pk: string]: {\n        readonly date: number;\n        readonly expiresAt: number;\n        readonly fetchedAt: number;\n      };\n    };\n  };\n  readonly optimistic: (ReceiveAction | OptimisticAction)[];\n  readonly lastReset: Date | number;\n}\ninterface ReceiveMeta<S extends Schema | undefined> {\n  schema?: S;\n  key: string;\n  args?: readonly any[];\n  updaters?: Record<string, UpdateFunction<S, any>>;\n  update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n  fetchedAt?: number;\n  date: number;\n  expiresAt: number;\n  errorPolicy?: (error: any) => 'hard' | 'soft' | undefined;\n}\ndeclare type ReceiveAction<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> = ErrorableFSAWithPayloadAndMeta<\n  typeof RECEIVE_TYPE,\n  Payload,\n  ReceiveMeta<S>\n> & {\n  endpoint?: EndpointInterface;\n};\ndeclare type OptimisticAction<\n  E extends EndpointInterface & {\n    update?: EndpointUpdateFunction<E>;\n  } = EndpointInterface & {\n    update?: EndpointUpdateFunction<EndpointInterface>;\n  },\n> = {\n  type: typeof OPTIMISTIC_TYPE;\n  meta: {\n    schema: E['schema'];\n    key: string;\n    args: readonly any[];\n    update?: (\n      result: any,\n      ...args: any\n    ) => Record<string, (...args: any) => any>;\n    fetchedAt: number;\n    date: number;\n    expiresAt: number;\n    errorPolicy?: (error: any) => 'hard' | 'soft' | undefined;\n  };\n  endpoint: E;\n  error?: undefined;\n};\ninterface ResetAction {\n  type: typeof RESET_TYPE;\n  date: number | Date;\n}\ninterface FetchMeta<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> {\n  type: FetchShape<any, any>['type'];\n  schema?: S;\n  key: string;\n  args?: readonly any[];\n  updaters?: Record<string, UpdateFunction<S, any>>;\n  update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n  options?: EndpointExtraOptions;\n  throttle: boolean;\n  resolve: (value?: any | PromiseLike<any>) => void;\n  reject: (reason?: any) => void;\n  promise: PromiseLike<any>;\n  createdAt: number | Date;\n  optimisticResponse?: Payload;\n  nm?: boolean;\n}\ninterface FetchAction<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> extends FSAWithPayloadAndMeta<\n    typeof FETCH_TYPE,\n    () => Promise<Payload>,\n    FetchMeta<any, any>\n  > {\n  meta: FetchMeta<Payload, S>;\n  endpoint?: EndpointInterface;\n}\ninterface SubscribeAction\n  extends FSAWithMeta<typeof SUBSCRIBE_TYPE, undefined, any> {\n  endpoint?: EndpointInterface;\n  meta: {\n    args?: readonly any[];\n    schema: Schema | undefined;\n    fetch: () => Promise<any>;\n    key: string;\n    options: EndpointExtraOptions | undefined;\n  };\n}\ninterface UnsubscribeAction\n  extends FSAWithMeta<typeof UNSUBSCRIBE_TYPE, undefined, any> {\n  endpoint?: EndpointInterface;\n  meta: {\n    args?: readonly any[];\n    key: string;\n    options: EndpointExtraOptions | undefined;\n  };\n}\ninterface InvalidateAction\n  extends FSAWithMeta<typeof INVALIDATE_TYPE, undefined, any> {\n  meta: {\n    key: string;\n  };\n}\ninterface GCAction {\n  type: typeof GC_TYPE;\n  entities: [string, string][];\n  results: string[];\n}\ndeclare type ResponseActions = ReceiveAction;\ndeclare type ActionTypes =\n  | FetchAction\n  | OptimisticAction\n  | ReceiveAction\n  | SubscribeAction\n  | UnsubscribeAction\n  | InvalidateAction\n  | ResetAction\n  | GCAction;\ninterface Manager {\n  getMiddleware(): Middleware$1;\n  cleanup(): void;\n  init?: (state: State<any>) => void;\n}\n\ndeclare const initialState: State<unknown>;\ndeclare function createReducer(\n  controller: Controller,\n): (state: State<unknown> | undefined, action: ActionTypes) => State<unknown>;\n\n//# sourceMappingURL=internal.d.ts.map\n\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_RIC: typeof RIC;\ndeclare const internal_d_initialState: typeof initialState;\ndeclare namespace internal_d {\n  export {\n    internal_d_inferResults as inferResults,\n    internal_d_DELETED as DELETED,\n    internal_d_RIC as RIC,\n    internal_d_initialState as initialState,\n  };\n}\n\ndeclare class ResetError extends Error {\n  name: string;\n  constructor();\n}\n/** Handles all async network dispatches\n *\n * Dedupes concurrent requests by keeping track of all fetches in flight\n * and returning existing promises for requests already in flight.\n *\n * Interfaces with store via a redux-compatible middleware.\n */\ndeclare class NetworkManager implements Manager {\n  protected fetched: {\n    [k: string]: Promise<any>;\n  };\n\n  protected resolvers: {\n    [k: string]: (value?: any) => void;\n  };\n\n  protected rejectors: {\n    [k: string]: (value?: any) => void;\n  };\n\n  readonly dataExpiryLength: number;\n  readonly errorExpiryLength: number;\n  protected middleware: Middleware$1;\n  protected getState: () => State<unknown>;\n  cleanupDate?: number;\n  constructor(dataExpiryLength?: number, errorExpiryLength?: number);\n  /** Used by DevtoolsManager to determine whether to log an action */\n  skipLogging(action: ActionTypes): boolean;\n  /** On mount */\n  init(): void;\n  /** Ensures all promises are completed by rejecting remaining. */\n  cleanup(): void;\n  allSettled(): Promise<PromiseSettledResult<any>[]> | undefined;\n  /** Clear all promise state */\n  protected clearAll(): void;\n  /** Clear promise state for a given key */\n  protected clear(key: string): void;\n  protected getLastReset(): number;\n  /** Called when middleware intercepts 'rest-hooks/fetch' action.\n   *\n   * Will then start a promise for a key and potentially start the network\n   * fetch.\n   *\n   * Uses throttle only when instructed by action meta. This is valuable\n   * for ensures mutation requests always go through.\n   */\n  protected handleFetch(\n    action: FetchAction,\n    dispatch: Dispatch<any>,\n    controller: Controller,\n  ): Promise<string | number | void | object | null>;\n\n  /** Called when middleware intercepts a receive action.\n   *\n   * Will resolve the promise associated with receive key.\n   */\n  protected handleReceive(action: ReceiveAction): void;\n  /** Attaches NetworkManager to store\n   *\n   * Intercepts 'rest-hooks/fetch' actions to start requests.\n   *\n   * Resolve/rejects a request when matching 'rest-hooks/receive' event\n   * is seen.\n   */\n  getMiddleware<T extends NetworkManager>(this: T): Middleware$1;\n  /** Ensures only one request for a given key is in flight at any time\n   *\n   * Uses key to either retrieve in-flight promise, or if not\n   * create a new promise and call fetch.\n   *\n   * Note: The new promise is not actually tied to fetch at all,\n   * but is resolved when the expected 'recieve' action is processed.\n   * This ensures promises are resolved only once their data is processed\n   * by the reducer.\n   */\n  protected throttle(key: string, fetch: () => Promise<any>): Promise<any>;\n}\n\n/**\n * @deprecated use createReducer instead\n */\ndeclare const reducer: (\n  state: State<unknown> | undefined,\n  action: ActionTypes,\n) => State<unknown>;\n//# sourceMappingURL=reducerInstance.d.ts.map\n\ndeclare function applyManager(\n  managers: Manager[],\n  controller: Controller,\n): Middleware[];\ninterface MiddlewareAPI<R extends Reducer<any, any> = Reducer<any, any>> {\n  getState: () => ReducerState<R>;\n  dispatch: Dispatch<R>;\n}\ndeclare type Middleware = <R extends Reducer<any, any>>({\n  dispatch,\n}: MiddlewareAPI<R>) => (next: Dispatch<R>) => Dispatch<R>;\n\ninterface Options$2<\n  Shape extends FetchShape<\n    Schema | undefined,\n    Readonly<object>,\n    Readonly<object | string> | void\n  >,\n> {\n  params: ParamsFromShape<Shape>;\n  body?: BodyFromShape<Shape>;\n  throttle: boolean;\n  updateParams?:\n    | OptimisticUpdateParams<\n        SchemaFromShape<Shape>,\n        FetchShape<Schema | undefined, any, any>\n      >[]\n    | undefined;\n}\n/** Requesting a fetch to begin\n *\n * @param fetchShape\n * @param param1 { params, body, throttle, updateParams }\n */\ndeclare function createFetch<\n  Shape extends FetchShape<\n    Schema | undefined,\n    Readonly<object>,\n    Readonly<object | string> | void\n  >,\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  { params, body, throttle, updateParams }: Options$2<Shape>,\n): FetchAction;\n\ninterface Options$1<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> extends Pick<\n    FetchAction<Payload, S>['meta'],\n    'schema' | 'key' | 'type' | 'updaters' | 'update' | 'args'\n  > {\n  dataExpiryLength: NonNullable<EndpointExtraOptions['dataExpiryLength']>;\n  fetchedAt?: number;\n}\n/** Update state with data\n *\n * @param data\n * @param param1 { schema, key, type, updaters, dataExpiryLength }\n */\ndeclare function createReceive<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n>(\n  data: Payload,\n  {\n    schema,\n    key,\n    args,\n    updaters,\n    fetchedAt,\n    update,\n    dataExpiryLength,\n  }: Options$1<Payload, S>,\n): ReceiveAction<Payload, S>;\n\ninterface Options<S extends Schema | undefined = any>\n  extends Pick<FetchAction<any, S>['meta'], 'schema' | 'key' | 'options'> {\n  errorExpiryLength: NonNullable<EndpointExtraOptions['errorExpiryLength']>;\n  fetchedAt?: number;\n}\ndeclare function createReceiveError<S extends Schema | undefined = any>(\n  error: Error,\n  { schema, key, options, errorExpiryLength, fetchedAt }: Options<S>,\n): ReceiveAction;\n\n//# sourceMappingURL=index.d.ts.map\n\ndeclare const index_d_createFetch: typeof createFetch;\ndeclare const index_d_createReceive: typeof createReceive;\ndeclare const index_d_createReceiveError: typeof createReceiveError;\ndeclare namespace index_d {\n  export {\n    index_d_createFetch as createFetch,\n    index_d_createReceive as createReceive,\n    index_d_createReceiveError as createReceiveError,\n  };\n}\n\ninterface ConnectionListener {\n  isOnline: () => boolean;\n  addOnlineListener: (handler: () => void) => void;\n  removeOnlineListener: (handler: () => void) => void;\n  addOfflineListener: (handler: () => void) => void;\n  removeOfflineListener: (handler: () => void) => void;\n}\n\ndeclare let DefaultConnectionListener: {\n  new (): ConnectionListener;\n};\n\n/** Properties sent to Subscription constructor */\ninterface SubscriptionInit {\n  schema?: Schema | undefined;\n  fetch: () => Promise<any>;\n  key: string;\n  getState: () => State<unknown>;\n  frequency?: number | undefined;\n}\n/** Interface handling a single resource subscription */\ninterface Subscription {\n  add(frequency?: number): void;\n  remove(frequency?: number): boolean;\n  cleanup(): void;\n}\n/** The static class that constructs Subscription */\ninterface SubscriptionConstructable {\n  new (init: SubscriptionInit, dispatch: Dispatch<any>): Subscription;\n}\n/** Handles subscription actions -> fetch or receive actions\n *\n * Constructor takes a SubscriptionConstructable class to control how\n * subscriptions are handled. (e.g., polling, websockets)\n */\ndeclare class SubscriptionManager<S extends SubscriptionConstructable>\n  implements Manager\n{\n  protected subscriptions: {\n    [key: string]: InstanceType<S>;\n  };\n\n  protected readonly Subscription: S;\n  protected middleware: Middleware$1;\n  constructor(Subscription: S);\n  /** Ensures all subscriptions are cleaned up. */\n  cleanup(): void;\n  /** Called when middleware intercepts 'rest-hooks/subscribe' action.\n   *\n   */\n  protected handleSubscribe(\n    action: SubscribeAction,\n    dispatch: Dispatch<any>,\n    getState: () => State<unknown>,\n  ): void;\n\n  /** Called when middleware intercepts 'rest-hooks/unsubscribe' action.\n   *\n   */\n  protected handleUnsubscribe(\n    action: UnsubscribeAction,\n    dispatch: Dispatch<any>,\n  ): void;\n\n  /** Attaches Manager to store\n   *\n   * Intercepts 'rest-hooks/subscribe'/'rest-hooks/unsubscribe' to register resources that\n   * need to be kept up to date.\n   *\n   * Will possibly dispatch 'rest-hooks/fetch' or 'rest-hooks/receive' to keep resources fresh\n   *\n   */\n  getMiddleware<T extends SubscriptionManager<any>>(this: T): Middleware$1;\n}\n\n/**\n * PollingSubscription keeps a given resource updated by\n * dispatching a fetch at a rate equal to the minimum update\n * interval requested.\n */\ndeclare class PollingSubscription implements Subscription {\n  protected readonly schema: Schema | undefined;\n  protected readonly fetch: () => Promise<any>;\n  protected readonly key: string;\n  protected frequency: number;\n  protected frequencyHistogram: Map<number, number>;\n  protected dispatch: Dispatch<any>;\n  protected getState: () => State<unknown>;\n  protected intervalId?: ReturnType<typeof setInterval>;\n  protected lastIntervalId?: ReturnType<typeof setInterval>;\n  protected startId?: ReturnType<typeof setTimeout>;\n  private connectionListener;\n  constructor(\n    { key, schema, fetch, frequency, getState }: SubscriptionInit,\n    dispatch: Dispatch<any>,\n    connectionListener?: ConnectionListener,\n  );\n\n  /** Subscribe to a frequency */\n  add(frequency?: number): void;\n  /** Unsubscribe from a frequency */\n  remove(frequency?: number): boolean;\n  /** Cleanup means clearing out background interval. */\n  cleanup(): void;\n  /** Trigger request for latest resource */\n  protected update(): void;\n  /** What happens when browser goes offline */\n  protected offlineListener: () => void;\n  /** What happens when browser comes online */\n  protected onlineListener: () => void;\n  /** Run polling process with current frequency\n   *\n   * Will clean up old poll interval on next run\n   */\n  protected run(): void;\n  /** Last fetch time */\n  protected lastFetchTime(): number;\n}\n\ndeclare type DevToolsConfig = {\n  [k: string]: unknown;\n  name: string;\n};\n/** Integrates with https://github.com/zalmoxisus/redux-devtools-extension\n *\n * Options: https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\ndeclare class DevToolsManager implements Manager {\n  protected middleware: Middleware$1;\n  protected devTools: undefined | any;\n  constructor(\n    config?: DevToolsConfig,\n    skipLogging?: (action: ActionTypes) => boolean,\n  );\n\n  /** Called when initial state is ready */\n  init(state: State<any>): void;\n  /** Ensures all subscriptions are cleaned up. */\n  cleanup(): void;\n  /** Attaches Manager to store\n   *\n   */\n  getMiddleware<T extends DevToolsManager>(this: T): Middleware$1;\n}\n\nexport {\n  AbstractInstanceType,\n  ActionTypes,\n  BodyFromShape,\n  ConnectionListener,\n  Controller,\n  DefaultConnectionListener,\n  DeleteShape,\n  Denormalize,\n  DenormalizeCache,\n  DenormalizeNullable,\n  DevToolsConfig,\n  DevToolsManager,\n  Dispatch,\n  EndpointExtraOptions,\n  EndpointInterface,\n  EndpointUpdateFunction,\n  EntityInterface,\n  ErrorTypes,\n  ExpiryStatus,\n  FetchAction,\n  FetchFunction,\n  FetchShape,\n  GCAction,\n  InvalidateAction,\n  Manager,\n  Middleware$1 as Middleware,\n  MiddlewareAPI$1 as MiddlewareAPI,\n  MutateShape,\n  NetworkError,\n  NetworkManager,\n  Normalize,\n  NormalizeNullable,\n  OptimisticAction,\n  PK,\n  ParamsFromShape,\n  PollingSubscription,\n  ReadShape,\n  ReceiveAction,\n  ReceiveMeta,\n  ReceiveTypes,\n  ResetAction,\n  ResetError,\n  ResolveType,\n  ResponseActions,\n  ResultEntry,\n  ReturnFromShape,\n  Schema,\n  SetShapeParams,\n  State,\n  SubscribeAction,\n  SubscriptionManager,\n  UnknownError,\n  UnsubscribeAction,\n  UpdateFunction,\n  internal_d as __INTERNAL__,\n  actionTypes_d as actionTypes,\n  applyManager,\n  createReducer,\n  initialState,\n  index_d as legacyActions,\n  reducer,\n};\n"}}]);