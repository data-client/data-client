(self.webpackChunk=self.webpackChunk||[]).push([[78789],{52031:e=>{e.exports="import { Manager, State as State$1, Controller, NetworkError as NetworkError$2, ActionTypes, DenormalizeCache, legacyActions, __INTERNAL__, Schema as Schema$2, EndpointExtraOptions as EndpointExtraOptions$2, createReducer as createReducer$1, applyManager as applyManager$1, DenormalizeNullable as DenormalizeNullable$3, ExpiryStatus, EndpointInterface as EndpointInterface$2, FetchFunction as FetchFunction$2, ResolveType as ResolveType$2, UnknownError as UnknownError$2, Denormalize as Denormalize$3 } from '@rest-hooks/core';\nexport { AbstractInstanceType, ActionTypes, Controller, DefaultConnectionListener, Denormalize, DenormalizeNullable, DevToolsManager, Dispatch, EndpointExtraOptions, EndpointInterface, ExpiryStatus, FetchAction, FetchFunction, InvalidateAction, Manager, Middleware, MiddlewareAPI, NetworkError, NetworkManager, Normalize, NormalizeNullable, PK, PollingSubscription, ReceiveAction, ReceiveTypes, ResetAction, ResolveType, Schema, State, SubscribeAction, SubscriptionManager, UnknownError, UnsubscribeAction, UpdateFunction, actionTypes } from '@rest-hooks/core';\nimport React$1, { Context } from 'react';\n\ntype AbstractInstanceType$1<T> = T extends {\n    prototype: infer U;\n} ? U : never;\ntype DenormalizeObject$1<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema$1 ? Denormalize$2<S[K]> : S[K];\n};\ntype DenormalizeNullableObject$1<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema$1 ? DenormalizeNullable$2<S[K]> : S[K];\n};\ninterface NestedSchemaClass$1<T = any> {\n    schema: Record<string, Schema$1>;\n    prototype: T;\n}\ninterface RecordClass$1<T = any> extends NestedSchemaClass$1<T> {\n    fromJS: (...args: any) => AbstractInstanceType$1<T>;\n}\ntype DenormalizeNullableNestedSchema$1<S extends NestedSchemaClass$1> = keyof S['schema'] extends never ? S['prototype'] : string extends keyof S['schema'] ? S['prototype'] : S['prototype'] & {\n    [K in keyof S['schema']]: DenormalizeNullable$2<S['schema'][K]>;\n};\ntype DenormalizeReturnType$1<T> = T extends (input: any, unvisit: any) => [infer R, any, any] ? R : never;\ntype Denormalize$2<S> = S extends EntityInterface$1<infer U> ? U : S extends RecordClass$1 ? AbstractInstanceType$1<S> : S extends SchemaClass$1 ? DenormalizeReturnType$1<S['denormalize']> : S extends Serializable$1<infer T> ? T : S extends Array<infer F> ? Denormalize$2<F>[] : S extends {\n    [K: string]: any;\n} ? DenormalizeObject$1<S> : S;\ntype DenormalizeNullable$2<S> = S extends EntityInterface$1<any> ? DenormalizeNullableNestedSchema$1<S> | undefined : S extends RecordClass$1 ? DenormalizeNullableNestedSchema$1<S> : S extends SchemaClass$1 ? DenormalizeReturnType$1<S['_denormalizeNullable']> : S extends Serializable$1<infer T> ? T : S extends Array<infer F> ? Denormalize$2<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? DenormalizeNullableObject$1<S> : S;\n\ninterface NetworkError$1 extends Error {\n    status: number;\n    response?: Response;\n}\ninterface UnknownError$1 extends Error {\n    status?: unknown;\n    response?: unknown;\n}\ntype ErrorTypes$2 = NetworkError$1 | UnknownError$1;\n\ninterface SnapshotInterface$1 {\n    getResponse: <E extends Pick<EndpointInterface$1, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => {\n        data: DenormalizeNullable$2<E['schema']>;\n        expiryStatus: ExpiryStatusInterface$1;\n        expiresAt: number;\n    };\n    getError: <E extends Pick<EndpointInterface$1, 'key'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => ErrorTypes$2 | undefined;\n    readonly fetchedAt: number;\n}\ntype ExpiryStatusInterface$1 = 1 | 2 | 3;\n\n/** Get the Params type for a given Shape */\ntype EndpointParam<E> = E extends (first: infer A, ...rest: any) => any ? A : E extends {\n    key: (first: infer A, ...rest: any) => any;\n} ? A : never;\n/** What the function's promise resolves to */\ntype ResolveType$1<E extends (...args: any) => any> = ReturnType<E> extends Promise<infer R> ? R : never;\ntype PartialArray<A> = A extends [] ? [] : A extends [infer F] ? [F] | [] : A extends [infer F, ...infer Rest] ? [F] | [F, ...PartialArray<Rest>] : A extends (infer T)[] ? T[] : never;\n\ntype FetchFunction$1<A extends readonly any[] = any, R = any> = (...args: A) => Promise<R>;\ninterface EndpointExtraOptions$1<F extends FetchFunction$1 = FetchFunction$1> {\n    /** Default data expiry length, will fall back to NetworkManager default if not defined */\n    readonly dataExpiryLength?: number;\n    /** Default error expiry length, will fall back to NetworkManager default if not defined */\n    readonly errorExpiryLength?: number;\n    /** Poll with at least this frequency in miliseconds */\n    readonly pollFrequency?: number;\n    /** Marks cached resources as invalid if they are stale */\n    readonly invalidIfStale?: boolean;\n    /** Enables optimistic updates for this request - uses return value as assumed network response\n     * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n     */\n    optimisticUpdate?(...args: Parameters<F>): ResolveType$1<F>;\n    /** Enables optimistic updates for this request - uses return value as assumed network response */\n    getOptimisticResponse?(snap: SnapshotInterface$1, ...args: Parameters<F>): ResolveType$1<F>;\n    /** Determines whether to throw or fallback to */\n    errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n    /** User-land extra data to send */\n    readonly extra?: any;\n}\n\ntype Schema$1 = null | string | {\n    [K: string]: any;\n} | Schema$1[] | SchemaSimple$1 | Serializable$1;\ntype Serializable$1<T extends {\n    toJSON(): string;\n} = {\n    toJSON(): string;\n}> = {\n    prototype: T;\n};\ninterface SchemaSimple$1<T = any> {\n    normalize(input: any, parent: any, key: any, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    denormalize(input: {}, unvisit: UnvisitFunction$1): [denormalized: T, found: boolean, suspend: boolean];\n    infer(args: readonly any[], indexes: NormalizedIndex$1, recurse: (...args: any) => any, entities: EntityTable$1): any;\n}\ninterface SchemaClass$1<T = any, N = T | undefined> extends SchemaSimple$1<T> {\n    _normalizeNullable(): any;\n    _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface$1<T = any> extends SchemaSimple$1 {\n    pk(params: any, parent?: any, key?: string): string | undefined;\n    readonly key: string;\n    merge(existing: any, incoming: any): any;\n    expiresAt?(meta: any, input: any): number;\n    useIncoming?(existingMeta: any, incomingMeta: any, existing: any, incoming: any): boolean;\n    indexes?: any;\n    schema: Record<string, Schema$1>;\n    prototype: T;\n}\ninterface UnvisitFunction$1 {\n    (input: any, schema: any): [any, boolean, boolean];\n    og?: UnvisitFunction$1;\n    setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex$1 {\n    readonly [entityKey: string]: {\n        readonly [indexName: string]: {\n            readonly [lookup: string]: string;\n        };\n    };\n}\ninterface EntityTable$1 {\n    [entityKey: string]: {\n        [pk: string]: unknown;\n    } | undefined;\n}\n/** Defines a networking endpoint */\ninterface EndpointInterface$1<F extends FetchFunction$1 = FetchFunction$1, S extends Schema$1 | undefined = Schema$1 | undefined, M extends true | undefined = true | undefined> extends EndpointExtraOptions$1<F> {\n    (...args: Parameters<F>): ReturnType<F>;\n    key(...args: Parameters<F>): string;\n    readonly sideEffect?: M;\n    readonly schema?: S;\n}\n/** To change values on the server */\ninterface MutateEndpoint<F extends FetchFunction$1 = FetchFunction$1, S extends Schema$1 | undefined = Schema$1 | undefined> extends EndpointInterface$1<F, S, true> {\n    sideEffect: true;\n}\n/** For retrieval requests */\ntype ReadEndpoint<F extends FetchFunction$1 = FetchFunction$1, S extends Schema$1 | undefined = Schema$1 | undefined> = EndpointInterface$1<F, S, undefined>;\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\ninterface EndpointOptions<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = undefined,\n  M extends true | undefined = undefined,\n> extends EndpointExtraOptions$1<F> {\n  key?: (...args: Parameters<F>) => string;\n  sideEffect?: M;\n  schema?: S;\n  [k: string]: any;\n}\n\ninterface EndpointExtendOptions<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointOptions<F, S, M> {\n  fetch?: FetchFunction$1;\n}\n\ntype KeyofEndpointInstance = keyof EndpointInstance<FetchFunction$1>;\n\ntype ExtendedEndpoint<\n  O extends EndpointExtendOptions<F>,\n  E extends EndpointInstance<\n    FetchFunction$1,\n    Schema$1 | undefined,\n    true | undefined\n  >,\n  F extends FetchFunction$1,\n> = EndpointInstance<\n  'fetch' extends keyof O ? Exclude<O['fetch'], undefined> : E['fetch'],\n  'schema' extends keyof O ? O['schema'] : E['schema'],\n  'sideEffect' extends keyof O ? O['sideEffect'] : E['sideEffect']\n> &\n  Omit<O, KeyofEndpointInstance> &\n  Omit<E, KeyofEndpointInstance>;\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstance<\n  F extends (...args: any) => Promise<any> = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInstanceInterface<F, S, M> {\n  extend<\n    E extends EndpointInstance<\n      (...args: any) => Promise<any>,\n      Schema$1 | undefined,\n      true | undefined\n    >,\n    O extends EndpointExtendOptions<F> &\n      Partial<Omit<E, keyof EndpointInstance<FetchFunction$1>>> &\n      Record<string, unknown>,\n  >(\n    this: E,\n    options: Readonly<O>,\n  ): ExtendedEndpoint<typeof options, E, F>;\n}\n\n/**\n * Defines an async data source.\n * @see https://resthooks.io/docs/api/Endpoint\n */\ninterface EndpointInstanceInterface<\n  F extends FetchFunction$1 = FetchFunction$1,\n  S extends Schema$1 | undefined = Schema$1 | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointInterface$1<F, S, M> {\n  constructor: EndpointConstructor;\n\n  /**\n   * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n   * @param thisArg The object to be used as the this object.\n   * @param argArray A set of arguments to be passed to the function.\n   */\n  apply<E extends FetchFunction$1>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    argArray?: Parameters<E>,\n  ): ReturnType<E>;\n\n  /**\n   * Calls a method of an object, substituting another object for the current object.\n   * @param thisArg The object to be used as the current object.\n   * @param argArray A list of arguments to be passed to the method.\n   */\n  call<E extends FetchFunction$1>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...argArray: Parameters<E>\n  ): ReturnType<E>;\n\n  /**\n   * For a given function, creates a bound function that has the same body as the original function.\n   * The this object of the bound function is associated with the specified object, and has the specified initial parameters.\n   * @param thisArg An object to which the this keyword can refer inside the new function.\n   * @param argArray A list of arguments to be passed to the new function.\n   */\n  bind<E extends FetchFunction$1, P extends PartialArray<Parameters<E>>>(\n    this: E,\n    thisArg: ThisParameterType<E>,\n    ...args: readonly [...P]\n  ): EndpointInstance<\n    (...args: readonly [...RemoveArray<Parameters<E>, P>]) => ReturnType<E>,\n    S,\n    M\n  > &\n    Omit<E, keyof EndpointInstance<FetchFunction$1>>;\n\n  /** Returns a string representation of a function. */\n  toString(): string;\n\n  prototype: any;\n  readonly length: number;\n\n  // Non-standard extensions\n  arguments: any;\n  caller: F;\n\n  key(...args: Parameters<F>): string;\n\n  readonly sideEffect: M;\n\n  readonly schema: S;\n\n  fetch: F;\n\n  /** The following is for compatibility with FetchShape */\n  /** @deprecated */\n  readonly type: M extends undefined\n    ? 'read'\n    : IfAny<M, any, IfTypeScriptLooseNull<'read', 'mutate'>>;\n\n  /** @deprecated */\n  getFetchKey(...args: OnlyFirst<Parameters<F>>): string;\n  /** @deprecated */\n  options?: EndpointExtraOptions$1<F>;\n}\n\ninterface EndpointConstructor {\n  new <\n    F extends (\n      this: EndpointInstance<FetchFunction$1> & E,\n      params?: any,\n      body?: any,\n    ) => Promise<any>,\n    S extends Schema$1 | undefined = undefined,\n    M extends true | undefined = undefined,\n    E extends Record<string, any> = {},\n  >(\n    fetchFunction: F,\n    options?: EndpointOptions<F, S, M> & E,\n  ): EndpointInstance<F, S, M> & E;\n  readonly prototype: Function;\n}\ndeclare let Endpoint: EndpointConstructor;\n\n\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\ntype IfTypeScriptLooseNull<Y, N> = 1 | undefined extends 1 ? Y : N;\n\ntype OnlyFirst<A extends unknown[]> = A extends [] ? [] : [A[0]];\n\ntype RemoveArray<Orig extends any[], Rem extends any[]> = Rem extends [\n  any,\n  ...infer RestRem,\n]\n  ? Orig extends [any, ...infer RestOrig]\n    ? RemoveArray<RestOrig, RestRem>\n    : never\n  : Orig;\n\n/**\n * Performant lookups by secondary indexes\n * @see https://resthooks.io/docs/api/Index\n */\ndeclare class Index<S extends Schema$1, P = Readonly<IndexParams<S>>> {\n    schema: S;\n    constructor(schema: S, key?: (params: P) => string);\n    key(params?: P): string;\n    /** The following is for compatibility with FetchShape */\n    getFetchKey: (params: P) => string;\n}\ntype ArrayElement<ArrayType extends unknown[] | readonly unknown[]> = ArrayType[number];\ntype IndexParams<S extends Schema$1> = S extends {\n    indexes: readonly string[];\n} ? {\n    [K in Extract<ArrayElement<S['indexes']>, keyof AbstractInstanceType$1<S>>]?: AbstractInstanceType$1<S>[K];\n} : Readonly<object>;\n\ndeclare const _default$1: React$1.NamedExoticComponent<{\n    children: React$1.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\ninterface ProviderProps {\n    children: React$1.ReactNode;\n    managers: Manager[];\n    initialState: State$1<unknown>;\n    Controller: typeof Controller;\n}\n/**\n * Manages state, providing all context needed to use the hooks.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({ children, managers, initialState, Controller, }: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n    var defaultProps: {\n        managers: Manager[];\n        initialState: State$1<unknown>;\n        Controller: typeof Controller;\n    };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\n/**\n * Handles loading and error conditions of Suspense\n * @see https://resthooks.io/docs/api/AsyncBoundary\n */\ndeclare function AsyncBoundary({ children, errorComponent, fallback, }: {\n    children: React$1.ReactNode;\n    fallback?: React$1.ReactNode;\n    errorComponent?: React$1.ComponentType<{\n        error: NetworkError$2;\n    }>;\n}): JSX.Element;\ndeclare const _default: React$1.MemoExoticComponent<typeof AsyncBoundary>;\n//# sourceMappingURL=AsyncBoundary.d.ts.map\n\ninterface Props<E extends NetworkError$2> {\n    children: React$1.ReactNode;\n    fallbackComponent: React$1.ComponentType<{\n        error: E;\n    }>;\n}\ninterface State<E extends NetworkError$2> {\n    error?: E;\n}\n/**\n * Handles any networking errors from suspense\n * @see https://resthooks.io/docs/api/NetworkErrorBoundary\n */\ndeclare class NetworkErrorBoundary<E extends NetworkError$2> extends React$1.Component<Props<E>, State<E>> {\n    static defaultProps: {\n        fallbackComponent: ({ error }: {\n            error: NetworkError$2;\n        }) => JSX.Element;\n    };\n    static getDerivedStateFromError(error: NetworkError$2 | any): {\n        error: NetworkError$2;\n    };\n    state: State<E>;\n    render(): JSX.Element;\n}\n\ntype Schema = null | string | {\n    [K: string]: any;\n} | Schema[] | SchemaSimple | Serializable;\ntype Serializable<T extends {\n    toJSON(): string;\n} = {\n    toJSON(): string;\n}> = {\n    prototype: T;\n};\ninterface SchemaSimple<T = any> {\n    normalize(input: any, parent: any, key: any, visit: (...args: any) => any, addEntity: (...args: any) => any, visitedEntities: Record<string, any>): any;\n    denormalize(input: {}, unvisit: UnvisitFunction): [denormalized: T, found: boolean, suspend: boolean];\n    infer(args: readonly any[], indexes: NormalizedIndex, recurse: (...args: any) => any, entities: EntityTable): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n    _normalizeNullable(): any;\n    _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n    pk(params: any, parent?: any, key?: string): string | undefined;\n    readonly key: string;\n    merge(existing: any, incoming: any): any;\n    expiresAt?(meta: any, input: any): number;\n    useIncoming?(existingMeta: any, incomingMeta: any, existing: any, incoming: any): boolean;\n    indexes?: any;\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface UnvisitFunction {\n    (input: any, schema: any): [any, boolean, boolean];\n    og?: UnvisitFunction;\n    setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n    readonly [entityKey: string]: {\n        readonly [indexName: string]: {\n            readonly [lookup: string]: string;\n        };\n    };\n}\ninterface EntityTable {\n    [entityKey: string]: {\n        [pk: string]: unknown;\n    } | undefined;\n}\n\ntype AbstractInstanceType<T> = T extends {\n    prototype: infer U;\n} ? U : never;\ntype DenormalizeObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ntype DenormalizeNullableObject<S extends Record<string, any>> = {\n    [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n    schema: Record<string, Schema>;\n    prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n    fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ntype DenormalizeNullableNestedSchema<S extends NestedSchemaClass> = keyof S['schema'] extends never ? S['prototype'] : string extends keyof S['schema'] ? S['prototype'] : S['prototype'];\ntype DenormalizeReturnType<T> = T extends (input: any, unvisit: any) => [infer R, any, any] ? R : never;\ntype Denormalize$1<S> = S extends EntityInterface<infer U> ? U : S extends RecordClass ? AbstractInstanceType<S> : S extends SchemaClass ? DenormalizeReturnType<S['denormalize']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] : S extends {\n    [K: string]: any;\n} ? DenormalizeObject<S> : S;\ntype DenormalizeNullable$1<S> = S extends EntityInterface<any> ? DenormalizeNullableNestedSchema<S> | undefined : S extends RecordClass ? DenormalizeNullableNestedSchema<S> : S extends SchemaClass ? DenormalizeReturnType<S['_denormalizeNullable']> : S extends Serializable<infer T> ? T : S extends Array<infer F> ? Denormalize$1<F>[] | undefined : S extends {\n    [K: string]: any;\n} ? DenormalizeNullableObject<S> : S;\n\ninterface NetworkError extends Error {\n    status: number;\n    response?: Response;\n}\ninterface UnknownError extends Error {\n    status?: unknown;\n    response?: unknown;\n}\ntype ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ntype ResolveType<E extends (...args: any) => any> = ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ntype InferReturn<F extends FetchFunction, S extends Schema | undefined> = S extends undefined ? ReturnType<F> : ReturnType<F> extends unknown ? Promise<Denormalize$1<S>> : ReturnType<F>;\n\ntype ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n    getResponse: <E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => {\n        data: any;\n        expiryStatus: ExpiryStatusInterface;\n        expiresAt: number;\n    };\n    getError: <E extends Pick<EndpointInterface, 'key'>, Args extends readonly [...Parameters<E['key']>]>(endpoint: E, ...args: Args) => ErrorTypes$1 | undefined;\n    readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<F extends FetchFunction = FetchFunction, S extends Schema | undefined = Schema | undefined, M extends true | undefined = true | undefined> extends EndpointExtraOptions<F> {\n    (...args: Parameters<F>): InferReturn<F, S>;\n    key(...args: Parameters<F>): string;\n    readonly sideEffect?: M;\n    readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n    /** Default data expiry length, will fall back to NetworkManager default if not defined */\n    readonly dataExpiryLength?: number;\n    /** Default error expiry length, will fall back to NetworkManager default if not defined */\n    readonly errorExpiryLength?: number;\n    /** Poll with at least this frequency in miliseconds */\n    readonly pollFrequency?: number;\n    /** Marks cached resources as invalid if they are stale */\n    readonly invalidIfStale?: boolean;\n    /** Enables optimistic updates for this request - uses return value as assumed network response\n     * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n     */\n    optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n    /** Enables optimistic updates for this request - uses return value as assumed network response */\n    getOptimisticResponse?(snap: SnapshotInterface, ...args: Parameters<F>): ResolveType<F>;\n    /** Determines whether to throw or fallback to */\n    errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n    /** User-land extra data to send */\n    readonly extra?: any;\n}\n\ntype FetchFunction<A extends readonly any[] = any, R = any> = (...args: A) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ntype Denormalize<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? Denormalize$1<S> : Denormalize$1<Extract<S, EntityInterface[]>> : Denormalize$1<Extract<S, EntityInterface>>;\ntype DenormalizeNullable<S> = Extract<S, EntityInterface> extends never ? Extract<S, EntityInterface[]> extends never ? DenormalizeNullable$1<S> : DenormalizeNullable$1<Extract<S, EntityInterface[]>> : DenormalizeNullable$1<Extract<S, EntityInterface>>;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): Args extends [null] ? E['schema'] extends Exclude<Schema, null> ? DenormalizeNullable<E['schema']> : undefined : E['schema'] extends Exclude<Schema, null> ? Denormalize<E['schema']> : ResolveType<E>;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\ntype CondNull$1<P, A, B> = P extends null ? A : B;\ntype StatefulReturn<S extends Schema | undefined, P> = CondNull$1<P, {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n}, {\n    data: Denormalize<S>;\n    loading: false;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: true;\n    error: undefined;\n} | {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: ErrorTypes$1;\n}>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/api/useDLE\n */\ndeclare function useDLE<E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>, Args extends readonly [...Parameters<E>] | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends undefined ? {\n    data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n    loading: boolean;\n    error: ErrorTypes$1 | undefined;\n} : StatefulReturn<E['schema'], Args[0]>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\ndeclare const StateContext: Context<State$1<unknown>>;\ndeclare const DispatchContext: Context<(value: ActionTypes) => Promise<void>>;\ndeclare const DenormalizeCacheContext: Context<DenormalizeCache>;\ndeclare const ControllerContext: Context<Controller>;\ninterface Store<S> {\n    subscribe(listener: () => void): () => void;\n    dispatch: React.Dispatch<ActionTypes>;\n    getState(): S;\n    uninitialized?: boolean;\n}\ndeclare const StoreContext: Context<Store<State$1<unknown>>>;\n\ndeclare const createFetch$1: typeof legacyActions.createFetch;\ndeclare const createReceive$1: typeof legacyActions.createReceive;\ndeclare const createReceiveError$1: typeof legacyActions.createReceiveError;\ndeclare const inferResults$1: typeof __INTERNAL__.inferResults;\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<R extends React$1.Reducer<any, any>>(dispatch: React$1.Dispatch<React$1.ReducerAction<R>>, state: React$1.ReducerState<R>): (action: React$1.ReducerAction<R>) => Promise<void>;\n\n/** Defines the shape of a network request */\ninterface FetchShape<S extends Schema$2 | undefined, Params extends Readonly<object> = Readonly<object>, Body extends Readonly<object | string> | void | unknown = Readonly<object | string> | undefined, Response = any> {\n    readonly type: 'read' | 'mutate' | 'delete';\n    fetch(params: Params, body?: Body): Promise<Response>;\n    getFetchKey(params: Params): string;\n    readonly schema: S;\n    readonly options?: EndpointExtraOptions$2;\n}\n/** To change values on the server */\ninterface MutateShape<S extends Schema$2 | undefined, Params extends Readonly<object> = Readonly<object>, Body extends Readonly<object | string> | void | unknown = Readonly<object | string> | undefined, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, Body, Response> {\n    readonly type: 'mutate';\n    fetch(params: Params, body: Body): Promise<Response>;\n}\n/** Removes entities */\ninterface DeleteShape<S extends Schema$2 | undefined, Params extends Readonly<object> = Readonly<object>, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, undefined, Response> {\n    readonly type: 'mutate';\n    fetch(params: Params, ...args: any): Promise<Response>;\n}\n/** For retrieval requests */\ninterface ReadShape<S extends Schema$2 | undefined, Params extends Readonly<object> = Readonly<object>, Response extends object | string | number | boolean | null = any> extends FetchShape<S, Params, undefined, Response> {\n    readonly type: 'read';\n    fetch(params: Params): Promise<Response>;\n}\n\n/** Sets a FetchShape's Param type.\n * Useful to constrain acceptable params (second arg) in hooks like useResource().\n *\n * @param [Shape] FetchShape to act upon\n * @param [Params] what to set the Params to\n */\ntype SetShapeParams<Shape extends FetchShape<any, any, any>, Params extends Readonly<object>> = {\n    [K in keyof Shape]: Shape[K];\n} & (Shape['fetch'] extends (first: any, ...rest: infer Args) => infer Return ? {\n    fetch: (first: Params, ...rest: Args) => Return;\n} : never);\n/** Get the Params type for a given Shape */\ntype ParamsFromShape<S> = S extends {\n    fetch: (first: infer A, ...rest: any) => any;\n} ? A : S extends {\n    getFetchKey: (first: infer A, ...rest: any) => any;\n} ? A : never;\n\ndeclare function makeCacheProvider(managers: Manager[], initialState?: State$1<unknown>): (props: {\n    children: React$1.ReactNode;\n}) => JSX.Element;\n\ndeclare const createFetch: typeof createFetch$1;\ndeclare const createReceive: typeof createReceive$1;\ndeclare const createReceiveError: typeof createReceiveError$1;\ndeclare const initialState: State$1<unknown>;\ndeclare const DELETED: symbol;\ndeclare const inferResults: typeof inferResults$1;\ndeclare const createReducer: typeof createReducer$1;\ndeclare const applyManager: typeof applyManager$1;\ndeclare const useCacheState: () => State$1<unknown>;\n\ndeclare const internal_d_createFetch: typeof createFetch;\ndeclare const internal_d_createReceive: typeof createReceive;\ndeclare const internal_d_createReceiveError: typeof createReceiveError;\ndeclare const internal_d_initialState: typeof initialState;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_createReducer: typeof createReducer;\ndeclare const internal_d_applyManager: typeof applyManager;\ndeclare const internal_d_useCacheState: typeof useCacheState;\ndeclare const internal_d_StateContext: typeof StateContext;\ndeclare const internal_d_DispatchContext: typeof DispatchContext;\ndeclare namespace internal_d {\n  export {\n    internal_d_createFetch as createFetch,\n    internal_d_createReceive as createReceive,\n    internal_d_createReceiveError as createReceiveError,\n    internal_d_initialState as initialState,\n    internal_d_DELETED as DELETED,\n    internal_d_inferResults as inferResults,\n    internal_d_createReducer as createReducer,\n    internal_d_applyManager as applyManager,\n    internal_d_useCacheState as useCacheState,\n    internal_d_StateContext as StateContext,\n    internal_d_DispatchContext as DispatchContext,\n  };\n}\n\n/**\n * @deprecated use https://resthooks.io/docs/api/Controller#getResponse directly instead\n *\n * Selects the denormalized form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n *\n * @returns [denormalizedValue, ready]\n */\ndeclare function useDenormalized<Shape extends Pick<ReadShape<Schema$2 | undefined, any>, 'getFetchKey' | 'schema' | 'options'>>(shape: Shape, params: ParamsFromShape<Shape> | null, state: State$1<any>, \n/** @deprecated */\ndenormalizeCache?: any): {\n    data: DenormalizeNullable$3<Shape['schema']>;\n    expiryStatus: ExpiryStatus;\n    expiresAt: number;\n};\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<E extends Pick<EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined>, 'key' | 'schema' | 'invalidIfStale'> | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): E['schema'] extends {} ? DenormalizeNullable$3<E['schema']> : E extends (...args: any) => any ? ResolveType$2<E> | undefined : any;\n\ntype ErrorTypes = NetworkError$2 | UnknownError$2;\ntype UseErrorReturn<P> = P extends [null] ? undefined : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<E extends Pick<EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined>, 'key' | 'schema' | 'invalidIfStale'> | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): UseErrorReturn<typeof args>;\n\n/**\n * Gets meta for a fetch key.\n * @see https://resthooks.io/docs/api/useMeta\n */\ndeclare function useMeta<E extends Pick<EndpointInterface$2<FetchFunction$2>, 'key'> | Pick<FetchShape<any, any>, 'getFetchKey'>, Args extends (E extends {\n    key: any;\n} ? readonly [...Parameters<E['key']>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): StateMeta | null;\ntype StateMeta<R = any> = State$1<R>['meta'][string];\n\ntype ResourceReturn<P, S extends {\n    fetch: any;\n    schema: any;\n}> = CondNull<P, S['schema'] extends undefined ? ResolveType$2<S['fetch']> | undefined : DenormalizeNullable$3<S['schema']>, S['schema'] extends undefined ? ResolveType$2<S['fetch']> : Denormalize$3<S['schema']>>;\ntype CondNull<P, A, B> = P extends null ? A : B;\n/**\n * Ensure a resource is available.\n * Suspends until it is.\n *\n * `useResource` guarantees referential equality globally.\n * @deprecated use https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null>(v1: readonly [S1, P1]): [ResourceReturn<P1, S1>];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2]): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>];\ndeclare function useResource<S extends ReadShape<any, any>, P extends ParamsFromShape<S> | null>(fetchShape: S, params: P): ResourceReturn<P, S>;\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3]): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>, ResourceReturn<P3, S3>];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null, S15 extends ReadShape<any, any>, P15 extends ParamsFromShape<S15> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14], v15: readonly [S15, P15]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>,\n    ResourceReturn<P15, S15>\n];\ndeclare function useResource<S1 extends ReadShape<any, any>, P1 extends ParamsFromShape<S1> | null, S2 extends ReadShape<any, any>, P2 extends ParamsFromShape<S2> | null, S3 extends ReadShape<any, any>, P3 extends ParamsFromShape<S3> | null, S4 extends ReadShape<any, any>, P4 extends ParamsFromShape<S4> | null, S5 extends ReadShape<any, any>, P5 extends ParamsFromShape<S5> | null, S6 extends ReadShape<any, any>, P6 extends ParamsFromShape<S6> | null, S7 extends ReadShape<any, any>, P7 extends ParamsFromShape<S7> | null, S8 extends ReadShape<any, any>, P8 extends ParamsFromShape<S8> | null, S9 extends ReadShape<any, any>, P9 extends ParamsFromShape<S9> | null, S10 extends ReadShape<any, any>, P10 extends ParamsFromShape<S10> | null, S11 extends ReadShape<any, any>, P11 extends ParamsFromShape<S11> | null, S12 extends ReadShape<any, any>, P12 extends ParamsFromShape<S12> | null, S13 extends ReadShape<any, any>, P13 extends ParamsFromShape<S13> | null, S14 extends ReadShape<any, any>, P14 extends ParamsFromShape<S14> | null, S15 extends ReadShape<any, any>, P15 extends ParamsFromShape<S15> | null, S16 extends ReadShape<any, any>, P16 extends ParamsFromShape<S16> | null>(v1: readonly [S1, P1], v2: readonly [S2, P2], v3: readonly [S3, P3], v4: readonly [S4, P4], v5: readonly [S5, P5], v6: readonly [S6, P6], v7: readonly [S7, P7], v8: readonly [S8, P8], v9: readonly [S9, P9], v10: readonly [S10, P10], v11: readonly [S11, P11], v12: readonly [S12, P12], v13: readonly [S13, P13], v14: readonly [S14, P14], v15: readonly [S15, P15], v16: readonly [S16, P16]): [\n    ResourceReturn<P1, S1>,\n    ResourceReturn<P2, S2>,\n    ResourceReturn<P3, S3>,\n    ResourceReturn<P4, S4>,\n    ResourceReturn<P5, S5>,\n    ResourceReturn<P6, S6>,\n    ResourceReturn<P7, S7>,\n    ResourceReturn<P8, S8>,\n    ResourceReturn<P9, S9>,\n    ResourceReturn<P10, S10>,\n    ResourceReturn<P11, S11>,\n    ResourceReturn<P12, S12>,\n    ResourceReturn<P13, S13>,\n    ResourceReturn<P14, S14>,\n    ResourceReturn<P15, S15>,\n    ResourceReturn<P16, S16>\n];\n\n/**\n * Request a resource if it is not in cache.\\\n * @deprecated use https://resthooks.io/docs/api/useFetch\n */\ndeclare function useRetrieve<Shape extends ReadShape<any, any>>(fetchShape: Shape, params: ParamsFromShape<Shape> | null, triggerFetch?: boolean, entitiesExpireAt?: number): any;\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<E extends EndpointInterface$2<FetchFunction$2, Schema$2 | undefined, undefined> | ReadShape<any, any>, Args extends (E extends (...args: any) => any ? readonly [...Parameters<E>] : readonly [ParamsFromShape<E>]) | readonly [null]>(endpoint: E, ...args: Args): void;\n\nexport { ArrayElement, _default as AsyncBoundary, _default$1 as BackupBoundary, CacheProvider, ControllerContext, DeleteShape, DenormalizeCacheContext, DispatchContext, Endpoint, EndpointParam, EndpointExtraOptions$1 as FetchOptions, FetchShape, Index, IndexParams, MutateEndpoint, MutateShape, NetworkErrorBoundary, ParamsFromShape, ReadEndpoint, ReadShape, SetShapeParams, StateContext, Store, StoreContext, internal_d as __INTERNAL__, makeCacheProvider, useCache, useController, useDLE, useDenormalized, useError, useFetch, useMeta, usePromisifiedDispatch, useResource, useRetrieve, useSubscription, useSuspense };\n"}}]);