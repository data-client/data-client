(self.webpackChunk=self.webpackChunk||[]).push([[30007],{90734:e=>{e.exports="/// <reference types=\"react\" />\nimport * as React$1 from 'react';\nimport React__default from 'react';\nimport {\n  ErrorFluxStandardActionWithPayloadAndMeta,\n  FSA,\n  FSAWithPayloadAndMeta,\n  FSAWithMeta,\n} from 'flux-standard-action';\n\ndeclare type Schema =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema[]\n  | SchemaSimple\n  | Serializable;\ndeclare type Serializable<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: Record<string, unknown>,\n    unvisit: UnvisitFunction,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n  ): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface UnvisitFunction {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction;\n  setLocal?: (entity: any) => void;\n}\ndeclare type NormalizedIndex = {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n};\n\n/** Link in a chain */\ndeclare class Link<K extends object, V> {\n  children: WeakMap<K, Link<K, V>>;\n  value?: V;\n}\n/** Maps from a list of objects (referentially) to any value\n *\n * If *any* members of the list get claned up, so does that key/value pair get removed.\n */\ndeclare class WeakListMap<K extends object, V> {\n  readonly first: WeakMap<K, Link<K, V>>;\n  delete(key: K[]): boolean;\n  get(key: K[]): V | undefined;\n  has(key: K[]): boolean;\n  set(key: K[], value: V): WeakListMap<K, V>;\n  protected traverse(key: K[]): Link<K, V> | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ndeclare type NormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Normalize$1<S[K]> : S[K];\n};\ndeclare type NormalizedNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? NormalizeNullable<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n  fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ninterface DenormalizeCache {\n  entities: {\n    [key: string]: {\n      [pk: string]: WeakListMap<object, EntityInterface>;\n    };\n  };\n  results: {\n    [key: string]: WeakListMap<object, any>;\n  };\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type NormalizeReturnType<T> = T extends (...args: any) => infer R\n  ? R\n  : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U>\n  ? U\n  : S extends RecordClass\n  ? AbstractInstanceType<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['denormalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject<S>\n  : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any>\n  ? DenormalizeNullableNestedSchema<S> | undefined\n  : S extends RecordClass\n  ? DenormalizeNullableNestedSchema<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['_denormalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject<S>\n  : S;\ndeclare type Normalize$1<S> = S extends EntityInterface\n  ? string\n  : S extends RecordClass\n  ? NormalizeObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['normalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizeObject<S>\n  : S;\ndeclare type NormalizeNullable<S> = S extends EntityInterface\n  ? string | undefined\n  : S extends RecordClass\n  ? NormalizedNullableObject<S['schema']>\n  : S extends SchemaClass\n  ? NormalizeReturnType<S['_normalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Normalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? NormalizedNullableObject<S>\n  : S;\n\n/**\n * Build the result parameter to denormalize from schema alone.\n * Tries to compute the entity ids from params.\n */\ndeclare function inferResults<S extends Schema>(\n  schema: S,\n  args: any[],\n  indexes: NormalizedIndex,\n): NormalizeNullable<S>;\n\ndeclare const DELETED: unique symbol;\n\ninterface NetworkError extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<\n  F extends FetchFunction,\n  S extends Schema | undefined,\n> = S extends undefined\n  ? ReturnType<F>\n  : ReturnType<F> extends unknown\n  ? Promise<Denormalize$1<S>>\n  : ReturnType<F>;\n\ndeclare const enum ExpiryStatus {\n  Invalid = 1,\n  InvalidIfStale = 2,\n  Valid = 3,\n}\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n  getResponse: <\n    E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: DenormalizeNullable$1<E['schema']>;\n    expiryStatus: ExpiryStatusInterface;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes$1 | undefined;\n  readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions<F> {\n  (...args: Parameters<F>): InferReturn<F, S>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface,\n    ...args: Parameters<F>\n  ): ResolveType<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\ndeclare type UpdateFunction<\n  SourceSchema extends Schema | undefined,\n  DestSchema extends Schema,\n> = (\n  sourceResults: Normalize$1<SourceSchema>,\n  destResults: Normalize$1<DestSchema> | undefined,\n) => Normalize$1<DestSchema>;\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Denormalize$1<S>\n    : Denormalize$1<Extract<S, EntityInterface[]>>\n  : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? DenormalizeNullable$1<S>\n    : DenormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : DenormalizeNullable$1<Extract<S, EntityInterface>>;\ndeclare type Normalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Normalize$1<S>\n    : Normalize$1<Extract<S, EntityInterface[]>>\n  : Normalize$1<Extract<S, EntityInterface>>;\n\ndeclare const RIC: (cb: (...args: any[]) => void, options: any) => void;\n\ndeclare const _default: React__default.NamedExoticComponent<{\n  children: React__default.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\n//# sourceMappingURL=internal.d.ts.map\n\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_RIC: typeof RIC;\ndeclare namespace internal_d {\n  export {\n    internal_d_inferResults as inferResults,\n    internal_d_DELETED as DELETED,\n    internal_d_RIC as RIC,\n    _default as BackupBoundary,\n  };\n}\n\ninterface MiddlewareAPI$1<\n  R extends React__default.Reducer<any, any> = React__default.Reducer<any, any>,\n> {\n  getState: () => React__default.ReducerState<R>;\n  dispatch: Dispatch<R>;\n}\ndeclare type Dispatch<R extends React__default.Reducer<any, any>> = (\n  action: React__default.ReducerAction<R>,\n) => Promise<void>;\ndeclare type Middleware$1 = <R extends React__default.Reducer<any, any>>({\n  dispatch,\n}: MiddlewareAPI$1<R>) => (next: Dispatch<R>) => Dispatch<R>;\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<\n  R extends React__default.Reducer<any, any>,\n>(\n  dispatch: React__default.Dispatch<React__default.ReducerAction<R>>,\n  state: React__default.ReducerState<R>,\n): (action: React__default.ReducerAction<R>) => Promise<void>;\n\ndeclare type ErrorableFSAWithPayloadAndMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n  CustomError extends Error = Error,\n> =\n  | ErrorFluxStandardActionWithPayloadAndMeta<Type, CustomError, Meta>\n  | NoErrorFluxStandardActionWithPayloadAndMeta<Type, Payload, Meta>;\ninterface NoErrorFluxStandardAction<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends FSA<Type, Payload, Meta> {\n  error?: false;\n}\n/**\n * A Flux Standard action with a required payload property.\n */\ninterface NoErrorFluxStandardActionWithPayload<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n  /**\n   * The required `payload` property MAY be any type of value.\n   * It represents the payload of the action.\n   * Any information about the action that is not the type or status of the action should be part of the `payload` field.\n   * By convention, if `error` is `true`, the `payload` SHOULD be an error object.\n   * This is akin to rejecting a promise with an error object.\n   */\n  payload: Payload;\n}\n/**\n * A Flux Standard action with a required metadata property.\n */\ninterface NoErrorFluxStandardActionWithMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> extends NoErrorFluxStandardAction<Type, Payload, Meta> {\n  /**\n   * The required `meta` property MAY be any type of value.\n   * It is intended for any extra information that is not part of the payload.\n   */\n  meta: Meta;\n}\n/**\n * A Flux Standard action with required payload and metadata properties.\n */\ndeclare type NoErrorFluxStandardActionWithPayloadAndMeta<\n  Type extends string = string,\n  Payload = undefined,\n  Meta = undefined,\n> = NoErrorFluxStandardActionWithPayload<Type, Payload, Meta> &\n  NoErrorFluxStandardActionWithMeta<Type, Payload, Meta>;\n\n/** Defines the shape of a network request */\ninterface FetchShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response = any,\n> {\n  readonly type: 'read' | 'mutate' | 'delete';\n  fetch(params: Params, body?: Body): Promise<Response>;\n  getFetchKey(params: Params): string;\n  readonly schema: S;\n  readonly options?: EndpointExtraOptions;\n}\n/** To change values on the server */\ninterface MutateShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Body extends Readonly<object | string> | void | unknown =\n    | Readonly<object | string>\n    | undefined,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, Body, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, body: Body): Promise<Response>;\n}\n/** Removes entities */\ninterface DeleteShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'mutate';\n  fetch(params: Params, ...args: any): Promise<Response>;\n}\n/** For retrieval requests */\ninterface ReadShape<\n  S extends Schema | undefined,\n  Params extends Readonly<object> = Readonly<object>,\n  Response extends object | string | number | boolean | null = any,\n> extends FetchShape<S, Params, undefined, Response> {\n  readonly type: 'read';\n  fetch(params: Params): Promise<Response>;\n}\n\n/** Sets a FetchShape's Param type.\n * Useful to constrain acceptable params (second arg) in hooks like useResource().\n *\n * @param [Shape] FetchShape to act upon\n * @param [Params] what to set the Params to\n */\ndeclare type SetShapeParams<\n  Shape extends FetchShape<any, any, any>,\n  Params extends Readonly<object>,\n> = {\n  [K in keyof Shape]: Shape[K];\n} & (Shape['fetch'] extends (first: any, ...rest: infer Args) => infer Return\n  ? {\n      fetch: (first: Params, ...rest: Args) => Return;\n    }\n  : never);\n/** Get the Params type for a given Shape */\ndeclare type ParamsFromShape<S> = S extends {\n  fetch: (first: infer A, ...rest: any) => any;\n}\n  ? A\n  : S extends {\n      getFetchKey: (first: infer A, ...rest: any) => any;\n    }\n  ? A\n  : never;\n/** Get the Schema type for a given Shape */\ndeclare type SchemaFromShape<\n  F extends FetchShape<Schema | undefined, any, any>,\n> = F['schema'];\n/** Get the Body type for a given Shape */\ndeclare type BodyFromShape<F extends FetchShape<any, any, any>> = Parameters<\n  F['fetch']\n>[1];\ndeclare type OptimisticUpdateParams<\n  SourceSchema extends Schema | undefined,\n  DestShape extends FetchShape<any, any, any>,\n> = [\n  DestShape,\n  ParamsFromShape<DestShape>,\n  UpdateFunction<SourceSchema, SchemaFromShape<DestShape>>,\n];\ndeclare type ReturnFromShape<S extends FetchShape<any, any, any>> = ReturnType<\n  S['fetch']\n> extends unknown\n  ? Promise<Denormalize<S['schema']>>\n  : ReturnType<S['fetch']>;\n\ndeclare const FETCH_TYPE: 'rest-hooks/fetch';\ndeclare const RECEIVE_TYPE: 'rest-hooks/receive';\ndeclare const OPTIMISTIC_TYPE: 'rest-hooks/optimistic';\ndeclare const RESET_TYPE: 'rest-hooks/reset';\ndeclare const SUBSCRIBE_TYPE: 'rest-hooks/subscribe';\ndeclare const UNSUBSCRIBE_TYPE: 'rest-hook/unsubscribe';\ndeclare const INVALIDATE_TYPE: 'rest-hooks/invalidate';\ndeclare const GC_TYPE: 'rest-hooks/gc';\n\ndeclare const actionTypes_d_FETCH_TYPE: typeof FETCH_TYPE;\ndeclare const actionTypes_d_RECEIVE_TYPE: typeof RECEIVE_TYPE;\ndeclare const actionTypes_d_OPTIMISTIC_TYPE: typeof OPTIMISTIC_TYPE;\ndeclare const actionTypes_d_RESET_TYPE: typeof RESET_TYPE;\ndeclare const actionTypes_d_SUBSCRIBE_TYPE: typeof SUBSCRIBE_TYPE;\ndeclare const actionTypes_d_UNSUBSCRIBE_TYPE: typeof UNSUBSCRIBE_TYPE;\ndeclare const actionTypes_d_INVALIDATE_TYPE: typeof INVALIDATE_TYPE;\ndeclare const actionTypes_d_GC_TYPE: typeof GC_TYPE;\ndeclare namespace actionTypes_d {\n  export {\n    actionTypes_d_FETCH_TYPE as FETCH_TYPE,\n    actionTypes_d_RECEIVE_TYPE as RECEIVE_TYPE,\n    actionTypes_d_OPTIMISTIC_TYPE as OPTIMISTIC_TYPE,\n    actionTypes_d_RESET_TYPE as RESET_TYPE,\n    actionTypes_d_SUBSCRIBE_TYPE as SUBSCRIBE_TYPE,\n    actionTypes_d_UNSUBSCRIBE_TYPE as UNSUBSCRIBE_TYPE,\n    actionTypes_d_INVALIDATE_TYPE as INVALIDATE_TYPE,\n    actionTypes_d_GC_TYPE as GC_TYPE,\n  };\n}\n\ndeclare type ResultEntry<E extends EndpointInterface> =\n  E['schema'] extends undefined ? ResolveType<E> : Normalize<E>;\ndeclare type EndpointUpdateFunction<\n  Source extends EndpointInterface,\n  Updaters extends Record<string, any> = Record<string, any>,\n> = (\n  source: ResultEntry<Source>,\n  ...args: Parameters<Source>\n) => {\n  [K in keyof Updaters]: (result: Updaters[K]) => Updaters[K];\n};\n\ndeclare type RHDispatch = (value: ActionTypes) => Promise<void>;\ninterface ConstructorProps {\n  dispatch?: RHDispatch;\n  globalCache?: DenormalizeCache;\n}\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/Controller\n */\ndeclare class Controller {\n  readonly dispatch: RHDispatch;\n  readonly globalCache: DenormalizeCache;\n  constructor({ dispatch, globalCache }?: ConstructorProps);\n  /*************** Action Dispatchers ***************/\n  /**\n   * Fetches the endpoint with given args, updating the Rest Hooks cache with the response or error upon completion.\n   * @see https://resthooks.io/docs/api/Controller#fetch\n   */\n  fetch: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...args_0: Parameters<E>\n  ) => ReturnType<E>;\n\n  /**\n   * Forces refetching and suspense on useResource with the same Endpoint and parameters.\n   * @see https://resthooks.io/docs/api/Controller#invalidate\n   */\n  invalidate: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [...Parameters<E>] | readonly [null]\n  ) => Promise<void>;\n\n  /**\n   * Resets the entire Rest Hooks cache. All inflight requests will not resolve.\n   * @see https://resthooks.io/docs/api/Controller#resetEntireStore\n   */\n  resetEntireStore: () => Promise<void>;\n  /**\n   * Stores response in cache for given Endpoint and args.\n   * @see https://resthooks.io/docs/api/Controller#receive\n   */\n  receive: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...rest: readonly [...Parameters<E>, any]\n  ) => Promise<void>;\n\n  /**\n   * Stores the result of Endpoint and args as the error provided.\n   * @see https://resthooks.io/docs/api/Controller#receiveError\n   */\n  receiveError: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    ...rest: readonly [...Parameters<E>, Error]\n  ) => Promise<void>;\n\n  /**\n   * Resolves an inflight fetch. `fetchedAt` should `fetch`'s `createdAt`\n   * @see https://resthooks.io/docs/api/Controller#resolve\n   */\n  resolve: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      true | undefined\n    > & {\n      update?: EndpointUpdateFunction<E, Record<string, any>> | undefined;\n    },\n  >(\n    endpoint: E,\n    meta:\n      | {\n          args: readonly [...Parameters<E>];\n          response: Error;\n          fetchedAt: number;\n          error: true;\n        }\n      | {\n          args: readonly [...Parameters<E>];\n          response: any;\n          fetchedAt: number;\n          error?: false | undefined;\n        },\n  ) => Promise<void>;\n\n  /**\n   * Marks a new subscription to a given Endpoint.\n   * @see https://resthooks.io/docs/api/Controller#subscribe\n   */\n  subscribe: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [null] | readonly [...Parameters<E>]\n  ) => Promise<void>;\n\n  /**\n   * Marks completion of subscription to a given Endpoint.\n   * @see https://resthooks.io/docs/api/Controller#unsubscribe\n   */\n  unsubscribe: <\n    E extends EndpointInterface<\n      FetchFunction<any, any>,\n      Schema | undefined,\n      undefined\n    >,\n  >(\n    endpoint: E,\n    ...args: readonly [null] | readonly [...Parameters<E>]\n  ) => Promise<void>;\n\n  /*************** More ***************/\n  snapshot: (state: State<unknown>, fetchedAt?: number) => SnapshotInterface;\n  getError: <\n    E extends Pick<\n      EndpointInterface<\n        FetchFunction<any, any>,\n        Schema | undefined,\n        true | undefined\n      >,\n      'key'\n    >,\n    Args extends readonly [null] | readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...rest: [...Args, State<unknown>]\n  ) => ErrorTypes$1 | undefined;\n\n  getResponse: <\n    E extends Pick<\n      EndpointInterface<\n        FetchFunction<any, any>,\n        Schema | undefined,\n        true | undefined\n      >,\n      'schema' | 'key' | 'invalidIfStale'\n    >,\n    Args extends readonly [null] | readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...rest: [...Args, State<unknown>]\n  ) => {\n    data: DenormalizeNullable<E['schema']>;\n    expiryStatus: ExpiryStatus;\n    expiresAt: number;\n  };\n\n  private getResults;\n}\n\ndeclare type ReceiveTypes = typeof RECEIVE_TYPE;\ndeclare type PK = string;\ninterface State<T> {\n  readonly entities: {\n    readonly [entityKey: string]:\n      | {\n          readonly [pk: string]: T;\n        }\n      | undefined;\n  };\n  readonly indexes: NormalizedIndex;\n  readonly results: {\n    readonly [key: string]: unknown | PK[] | PK | undefined;\n  };\n  readonly meta: {\n    readonly [key: string]: {\n      readonly date: number;\n      readonly error?: ErrorTypes$1;\n      readonly expiresAt: number;\n      readonly prevExpiresAt?: number;\n      readonly invalidated?: boolean;\n      readonly errorPolicy?: 'hard' | 'soft' | undefined;\n    };\n  };\n  readonly entityMeta: {\n    readonly [entityKey: string]: {\n      readonly [pk: string]: {\n        readonly date: number;\n        readonly expiresAt: number;\n        readonly fetchedAt: number;\n      };\n    };\n  };\n  readonly optimistic: (ReceiveAction | OptimisticAction)[];\n  readonly lastReset: Date | number;\n}\ninterface ReceiveMeta<S extends Schema | undefined> {\n  schema?: S;\n  key: string;\n  args?: readonly any[];\n  updaters?: Record<string, UpdateFunction<S, any>>;\n  update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n  fetchedAt?: number;\n  date: number;\n  expiresAt: number;\n  errorPolicy?: (error: any) => 'hard' | 'soft' | undefined;\n}\ndeclare type ReceiveAction<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> = ErrorableFSAWithPayloadAndMeta<\n  typeof RECEIVE_TYPE,\n  Payload,\n  ReceiveMeta<S>\n> & {\n  endpoint?: EndpointInterface;\n};\ndeclare type OptimisticAction<\n  E extends EndpointInterface & {\n    update?: EndpointUpdateFunction<E>;\n  } = EndpointInterface & {\n    update?: EndpointUpdateFunction<EndpointInterface>;\n  },\n> = {\n  type: typeof OPTIMISTIC_TYPE;\n  meta: {\n    schema: E['schema'];\n    key: string;\n    args: readonly any[];\n    update?: (\n      result: any,\n      ...args: any\n    ) => Record<string, (...args: any) => any>;\n    fetchedAt: number;\n    date: number;\n    expiresAt: number;\n    errorPolicy?: (error: any) => 'hard' | 'soft' | undefined;\n  };\n  endpoint: E;\n  error?: undefined;\n};\ninterface ResetAction {\n  type: typeof RESET_TYPE;\n  date: number | Date;\n}\ninterface FetchMeta<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> {\n  type: FetchShape<any, any>['type'];\n  schema?: S;\n  key: string;\n  args?: readonly any[];\n  updaters?: Record<string, UpdateFunction<S, any>>;\n  update?: (result: any, ...args: any) => Record<string, (...args: any) => any>;\n  options?: EndpointExtraOptions;\n  throttle: boolean;\n  resolve: (value?: any | PromiseLike<any>) => void;\n  reject: (reason?: any) => void;\n  promise: PromiseLike<any>;\n  createdAt: number | Date;\n  optimisticResponse?: Payload;\n  nm?: boolean;\n}\ninterface FetchAction<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> extends FSAWithPayloadAndMeta<\n    typeof FETCH_TYPE,\n    () => Promise<Payload>,\n    FetchMeta<any, any>\n  > {\n  meta: FetchMeta<Payload, S>;\n  endpoint?: EndpointInterface;\n}\ninterface SubscribeAction\n  extends FSAWithMeta<typeof SUBSCRIBE_TYPE, undefined, any> {\n  endpoint?: EndpointInterface;\n  meta: {\n    args?: readonly any[];\n    schema: Schema | undefined;\n    fetch: () => Promise<any>;\n    key: string;\n    options: EndpointExtraOptions | undefined;\n  };\n}\ninterface UnsubscribeAction\n  extends FSAWithMeta<typeof UNSUBSCRIBE_TYPE, undefined, any> {\n  endpoint?: EndpointInterface;\n  meta: {\n    args?: readonly any[];\n    key: string;\n    options: EndpointExtraOptions | undefined;\n  };\n}\ninterface InvalidateAction\n  extends FSAWithMeta<typeof INVALIDATE_TYPE, undefined, any> {\n  meta: {\n    key: string;\n  };\n}\ninterface GCAction {\n  type: typeof GC_TYPE;\n  entities: [string, string][];\n  results: string[];\n}\ndeclare type ResponseActions = ReceiveAction;\ndeclare type ActionTypes =\n  | FetchAction\n  | OptimisticAction\n  | ReceiveAction\n  | SubscribeAction\n  | UnsubscribeAction\n  | InvalidateAction\n  | ResetAction\n  | GCAction;\ninterface Manager {\n  getMiddleware(): Middleware;\n  cleanup(): void;\n  init?: (state: State<any>) => void;\n}\ndeclare type Middleware = <R extends React.Reducer<any, any>>(\n  options: MiddlewareAPI<R>,\n) => (next: Dispatch<R>) => Dispatch<R>;\ninterface MiddlewareAPI<\n  R extends React.Reducer<any, any> = React.Reducer<any, any>,\n> {\n  getState: () => React.ReducerState<R>;\n  dispatch: Dispatch<R>;\n  controller: Controller;\n}\n\ndeclare class ResetError extends Error {\n  name: string;\n  constructor();\n}\n/** Handles all async network dispatches\n *\n * Dedupes concurrent requests by keeping track of all fetches in flight\n * and returning existing promises for requests already in flight.\n *\n * Interfaces with store via a redux-compatible middleware.\n */\ndeclare class NetworkManager implements Manager {\n  protected fetched: {\n    [k: string]: Promise<any>;\n  };\n\n  protected resolvers: {\n    [k: string]: (value?: any) => void;\n  };\n\n  protected rejectors: {\n    [k: string]: (value?: any) => void;\n  };\n\n  readonly dataExpiryLength: number;\n  readonly errorExpiryLength: number;\n  protected middleware: Middleware;\n  protected getState: () => State<unknown>;\n  cleanupDate?: number;\n  constructor(dataExpiryLength?: number, errorExpiryLength?: number);\n  /** Used by DevtoolsManager to determine whether to log an action */\n  skipLogging(action: ActionTypes): boolean;\n  /** On mount */\n  init(): void;\n  /** Ensures all promises are completed by rejecting remaining. */\n  cleanup(): void;\n  /** Clear all promise state */\n  protected clearAll(): void;\n  /** Clear promise state for a given key */\n  protected clear(key: string): void;\n  protected getLastReset(): number;\n  /** Called when middleware intercepts 'rest-hooks/fetch' action.\n   *\n   * Will then start a promise for a key and potentially start the network\n   * fetch.\n   *\n   * Uses throttle only when instructed by action meta. This is valuable\n   * for ensures mutation requests always go through.\n   */\n  protected handleFetch(\n    action: FetchAction,\n    dispatch: Dispatch<any>,\n    controller: Controller,\n  ): Promise<string | number | void | object | null>;\n\n  /** Called when middleware intercepts a receive action.\n   *\n   * Will resolve the promise associated with receive key.\n   */\n  protected handleReceive(action: ReceiveAction): void;\n  /** Attaches NetworkManager to store\n   *\n   * Intercepts 'rest-hooks/fetch' actions to start requests.\n   *\n   * Resolve/rejects a request when matching 'rest-hooks/receive' event\n   * is seen.\n   */\n  getMiddleware<T extends NetworkManager>(this: T): Middleware;\n  /** Ensures only one request for a given key is in flight at any time\n   *\n   * Uses key to either retrieve in-flight promise, or if not\n   * create a new promise and call fetch.\n   *\n   * Note: The new promise is not actually tied to fetch at all,\n   * but is resolved when the expected 'recieve' action is processed.\n   * This ensures promises are resolved only once their data is processed\n   * by the reducer.\n   */\n  protected throttle(key: string, fetch: () => Promise<any>): Promise<any>;\n}\n\ndeclare const initialState: State<unknown>;\ndeclare function createReducer(\n  controller: Controller,\n): (state: State<unknown> | undefined, action: ActionTypes) => State<unknown>;\n\n/**\n * @deprecated use createReducer instead\n */\ndeclare const reducer: (\n  state: State<unknown> | undefined,\n  action: ActionTypes,\n) => State<unknown>;\n//# sourceMappingURL=reducerInstance.d.ts.map\n\ndeclare function applyManager(\n  managers: Manager[],\n  controller: Controller,\n): Middleware$1[];\n\n/**\n * @deprecated use https://resthooks.io/docs/api/Controller#getResponse directly instead\n *\n * Selects the denormalized form from `state` cache.\n *\n * If `result` is not found, will attempt to generate it naturally\n * using params and schema. This increases cache hit rate for many\n * detail shapes.\n *\n * @returns [denormalizedValue, ready]\n */\ndeclare function useDenormalized<\n  Shape extends Pick<\n    ReadShape<Schema | undefined, any>,\n    'getFetchKey' | 'schema' | 'options'\n  >,\n>(\n  shape: Shape,\n  params: ParamsFromShape<Shape> | null,\n  state: State<any>,\n  /** @deprecated */\n  denormalizeCache?: any,\n): {\n  data: DenormalizeNullable<Shape['schema']>;\n  expiryStatus: ExpiryStatus;\n  expiresAt: number;\n};\n\ninterface ProviderProps {\n  children: React__default.ReactNode;\n  managers: Manager[];\n  initialState: State<unknown>;\n  Controller: typeof Controller;\n}\n/**\n * Controller managing state of the cache and coordinating network requests.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({\n  children,\n  managers,\n  initialState,\n  Controller,\n}: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n  var defaultProps: {\n    managers: Manager[];\n    initialState: State<unknown>;\n    Controller: typeof Controller;\n  };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\n/**\n * Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetcher<\n  Shape extends FetchShape<Schema, Readonly<object>, any>,\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  throttle?: boolean,\n): <\n  UpdateParams extends OptimisticUpdateParams<\n    SchemaFromShape<Shape>,\n    FetchShape<any, any, any>\n  >[],\n>(\n  a: Parameters<Shape['fetch']>[0],\n  b?: Parameters<Shape['fetch']>[1],\n  updateParams?: UpdateParams | undefined,\n) => ReturnFromShape<typeof fetchShape>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<\n  E extends\n    | Pick<\n        EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n        'key' | 'schema' | 'invalidIfStale'\n      >\n    | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends Record<string, unknown>\n  ? DenormalizeNullable<E['schema']>\n  : E extends (...args: any) => any\n  ? ResolveType<E> | undefined\n  : any;\n\n/**\n * Request a resource if it is not in cache.\\\n * @see https://resthooks.io/docs/api/useRetrieve\n */\ndeclare function useRetrieve<Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n  params: ParamsFromShape<Shape> | null,\n  triggerFetch?: boolean,\n  entitiesExpireAt?: number,\n): any;\n\ndeclare type ResourceReturn<\n  P,\n  S extends {\n    fetch: any;\n    schema: any;\n  },\n> = CondNull$1<\n  P,\n  S['schema'] extends undefined\n    ? ResolveType<S['fetch']> | undefined\n    : DenormalizeNullable<S['schema']>,\n  S['schema'] extends undefined\n    ? ResolveType<S['fetch']>\n    : Denormalize<S['schema']>\n>;\ndeclare type CondNull$1<P, A, B> = P extends null ? A : B;\n/**\n * Ensure a resource is available.\n * Suspends until it is.\n *\n * `useResource` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useresource\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n>(v1: readonly [S1, P1]): [ResourceReturn<P1, S1>];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>];\ndeclare function useResource<\n  S extends ReadShape<any, any>,\n  P extends ParamsFromShape<S> | null,\n>(fetchShape: S, params: P): ResourceReturn<P, S>;\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n): [ResourceReturn<P1, S1>, ResourceReturn<P2, S2>, ResourceReturn<P3, S3>];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n  S15 extends ReadShape<any, any>,\n  P15 extends ParamsFromShape<S15> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n  v15: readonly [S15, P15],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n  ResourceReturn<P15, S15>,\n];\ndeclare function useResource<\n  S1 extends ReadShape<any, any>,\n  P1 extends ParamsFromShape<S1> | null,\n  S2 extends ReadShape<any, any>,\n  P2 extends ParamsFromShape<S2> | null,\n  S3 extends ReadShape<any, any>,\n  P3 extends ParamsFromShape<S3> | null,\n  S4 extends ReadShape<any, any>,\n  P4 extends ParamsFromShape<S4> | null,\n  S5 extends ReadShape<any, any>,\n  P5 extends ParamsFromShape<S5> | null,\n  S6 extends ReadShape<any, any>,\n  P6 extends ParamsFromShape<S6> | null,\n  S7 extends ReadShape<any, any>,\n  P7 extends ParamsFromShape<S7> | null,\n  S8 extends ReadShape<any, any>,\n  P8 extends ParamsFromShape<S8> | null,\n  S9 extends ReadShape<any, any>,\n  P9 extends ParamsFromShape<S9> | null,\n  S10 extends ReadShape<any, any>,\n  P10 extends ParamsFromShape<S10> | null,\n  S11 extends ReadShape<any, any>,\n  P11 extends ParamsFromShape<S11> | null,\n  S12 extends ReadShape<any, any>,\n  P12 extends ParamsFromShape<S12> | null,\n  S13 extends ReadShape<any, any>,\n  P13 extends ParamsFromShape<S13> | null,\n  S14 extends ReadShape<any, any>,\n  P14 extends ParamsFromShape<S14> | null,\n  S15 extends ReadShape<any, any>,\n  P15 extends ParamsFromShape<S15> | null,\n  S16 extends ReadShape<any, any>,\n  P16 extends ParamsFromShape<S16> | null,\n>(\n  v1: readonly [S1, P1],\n  v2: readonly [S2, P2],\n  v3: readonly [S3, P3],\n  v4: readonly [S4, P4],\n  v5: readonly [S5, P5],\n  v6: readonly [S6, P6],\n  v7: readonly [S7, P7],\n  v8: readonly [S8, P8],\n  v9: readonly [S9, P9],\n  v10: readonly [S10, P10],\n  v11: readonly [S11, P11],\n  v12: readonly [S12, P12],\n  v13: readonly [S13, P13],\n  v14: readonly [S14, P14],\n  v15: readonly [S15, P15],\n  v16: readonly [S16, P16],\n): [\n  ResourceReturn<P1, S1>,\n  ResourceReturn<P2, S2>,\n  ResourceReturn<P3, S3>,\n  ResourceReturn<P4, S4>,\n  ResourceReturn<P5, S5>,\n  ResourceReturn<P6, S6>,\n  ResourceReturn<P7, S7>,\n  ResourceReturn<P8, S8>,\n  ResourceReturn<P9, S9>,\n  ResourceReturn<P10, S10>,\n  ResourceReturn<P11, S11>,\n  ResourceReturn<P12, S12>,\n  ResourceReturn<P13, S13>,\n  ResourceReturn<P14, S14>,\n  ResourceReturn<P15, S15>,\n  ResourceReturn<P16, S16>,\n];\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<\n  E extends\n    | EndpointInterface<FetchFunction, Schema | undefined, undefined>\n    | ReadShape<any, any>,\n  Args extends\n    | (E extends (...args: any) => any\n        ? readonly [...Parameters<E>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(endpoint: E, ...args: Args): void;\n\n/**\n * Gets meta for a fetch key.\n * @see https://resthooks.io/docs/api/useMeta\n */\ndeclare function useMeta<\n  E extends\n    | Pick<EndpointInterface<FetchFunction>, 'key'>\n    | Pick<FetchShape<any, any>, 'getFetchKey'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): {\n  readonly date: number;\n  readonly error?: ErrorTypes$1 | undefined;\n  readonly expiresAt: number;\n  readonly prevExpiresAt?: number | undefined;\n  readonly invalidated?: boolean | undefined;\n  readonly errorPolicy?: 'hard' | 'soft' | undefined;\n} | null;\n\ndeclare type ErrorTypes = NetworkError | UnknownError;\ndeclare type UseErrorReturn<P> = P extends [null]\n  ? undefined\n  : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<\n  E extends\n    | Pick<\n        EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n        'key' | 'schema' | 'invalidIfStale'\n      >\n    | Pick<ReadShape<any, any>, 'getFetchKey' | 'schema' | 'options'>,\n  Args extends\n    | (E extends {\n        key: any;\n      }\n        ? readonly [...Parameters<E['key']>]\n        : readonly [ParamsFromShape<E>])\n    | readonly [null],\n>(endpoint: E, ...args: Args): UseErrorReturn<typeof args>;\n\n/**\n * Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidator<Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n): (params: ParamsFromShape<Shape> | null) => void;\n\n/**\n * Returns a function to completely clear the cache of all entries\n * @deprecated use https://resthooks.io/docs/api/Controller#resetEntireStore\n */\ndeclare function useResetter(): () => void;\n\n/** Build an imperative dispatcher to issue network requests.\n * @deprecated use https://resthooks.io/docs/api/Controller#fetch\n */\ndeclare function useFetchDispatcher(throttle?: boolean): <\n  Shape extends FetchShape<Schema, Readonly<object>, any>,\n  UpdateParams extends OptimisticUpdateParams<\n    SchemaFromShape<Shape>,\n    FetchShape<any, any, any>\n  >[],\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  params: ParamsFromShape<Shape>,\n  body: BodyFromShape<Shape>,\n  updateParams?: UpdateParams | undefined,\n) => ReturnFromShape<typeof fetchShape>;\n\n/** Invalidate a certain item within the cache\n * @deprecated use https://resthooks.io/docs/api/Controller#invalidate\n */\ndeclare function useInvalidateDispatcher(): <Shape extends ReadShape<any, any>>(\n  fetchShape: Shape,\n  params: ParamsFromShape<Shape>,\n) => void;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): Args extends [null]\n  ? E['schema'] extends Exclude<Schema, null>\n    ? DenormalizeNullable<E['schema']>\n    : undefined\n  : E['schema'] extends Exclude<Schema, null>\n  ? Denormalize<E['schema']>\n  : ResolveType<E>;\n\n/** @deprecated use https://resthooks.io/docs/api/Controller#getResponse */\ndeclare function hasUsableData(\n  fetchShape: Pick<FetchShape<any>, 'options'>,\n  cacheReady: boolean,\n  deleted: boolean,\n  invalidated?: boolean,\n): boolean;\n\ndeclare type CondNull<P, A, B> = P extends null ? A : B;\ndeclare type StatefulReturn<S extends Schema | undefined, P> = CondNull<\n  P,\n  {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n  },\n  | {\n      data: Denormalize<S>;\n      loading: false;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: true;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: false;\n      error: ErrorTypes$1;\n    }\n>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/guides/no-suspense\n */\ndeclare function useDLE<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends undefined\n  ? {\n      data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n      loading: boolean;\n      error: ErrorTypes$1 | undefined;\n    }\n  : StatefulReturn<E['schema'], Args[0]>;\n\ndeclare const StateContext: React$1.Context<State<unknown>>;\ndeclare const DispatchContext: React$1.Context<\n  (value: ActionTypes) => Promise<void>\n>;\ndeclare const DenormalizeCacheContext: React$1.Context<DenormalizeCache>;\ndeclare const ControllerContext: React$1.Context<Controller>;\n\ninterface Options$2<\n  Shape extends FetchShape<\n    Schema | undefined,\n    Readonly<object>,\n    Readonly<object | string> | void\n  >,\n> {\n  params: ParamsFromShape<Shape>;\n  body?: BodyFromShape<Shape>;\n  throttle: boolean;\n  updateParams?:\n    | OptimisticUpdateParams<\n        SchemaFromShape<Shape>,\n        FetchShape<Schema | undefined, any, any>\n      >[]\n    | undefined;\n}\n/** Requesting a fetch to begin\n *\n * @param fetchShape\n * @param param1 { params, body, throttle, updateParams }\n */\ndeclare function createFetch<\n  Shape extends FetchShape<\n    Schema | undefined,\n    Readonly<object>,\n    Readonly<object | string> | void\n  >,\n>(\n  fetchShape: Shape & {\n    update?: (...args: any) => Record<string, (...args: any) => any>;\n  },\n  { params, body, throttle, updateParams }: Options$2<Shape>,\n): FetchAction;\n\ninterface Options$1<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n> extends Pick<\n    FetchAction<Payload, S>['meta'],\n    'schema' | 'key' | 'type' | 'updaters' | 'update' | 'args'\n  > {\n  dataExpiryLength: NonNullable<EndpointExtraOptions['dataExpiryLength']>;\n  fetchedAt?: number;\n}\n/** Update state with data\n *\n * @param data\n * @param param1 { schema, key, type, updaters, dataExpiryLength }\n */\ndeclare function createReceive<\n  Payload extends object | string | number | null =\n    | object\n    | string\n    | number\n    | null,\n  S extends Schema | undefined = any,\n>(\n  data: Payload,\n  {\n    schema,\n    key,\n    args,\n    updaters,\n    fetchedAt,\n    update,\n    dataExpiryLength,\n  }: Options$1<Payload, S>,\n): ReceiveAction<Payload, S>;\n\ninterface Options<S extends Schema | undefined = any>\n  extends Pick<FetchAction<any, S>['meta'], 'schema' | 'key' | 'options'> {\n  errorExpiryLength: NonNullable<EndpointExtraOptions['errorExpiryLength']>;\n  fetchedAt?: number;\n}\ndeclare function createReceiveError<S extends Schema | undefined = any>(\n  error: Error,\n  { schema, key, options, errorExpiryLength, fetchedAt }: Options<S>,\n): ReceiveAction;\n\nexport {\n  AbstractInstanceType,\n  ActionTypes,\n  _default as BackupBoundary,\n  BodyFromShape,\n  CacheProvider,\n  Controller,\n  ControllerContext,\n  DeleteShape,\n  DenormalizeCacheContext,\n  Dispatch,\n  DispatchContext,\n  EndpointInterface,\n  EndpointUpdateFunction,\n  EntityInterface,\n  ErrorTypes$1 as ErrorTypes,\n  ExpiryStatus,\n  FetchAction,\n  FetchShape,\n  GCAction,\n  InvalidateAction,\n  Manager,\n  Middleware,\n  MiddlewareAPI,\n  MutateShape,\n  NetworkError,\n  NetworkManager,\n  OptimisticAction,\n  PK,\n  ParamsFromShape,\n  ReadShape,\n  ReceiveAction,\n  ReceiveMeta,\n  ReceiveTypes,\n  ResetAction,\n  ResetError,\n  ResolveType,\n  ResponseActions,\n  ResultEntry,\n  ReturnFromShape,\n  Schema,\n  SetShapeParams,\n  State,\n  StateContext,\n  SubscribeAction,\n  UnknownError,\n  UnsubscribeAction,\n  UpdateFunction,\n  internal_d as __INTERNAL__,\n  actionTypes_d as actionTypes,\n  applyManager,\n  createFetch,\n  createReceive,\n  createReceiveError,\n  createReducer,\n  hasUsableData,\n  initialState,\n  reducer,\n  useCache,\n  useController,\n  useDLE,\n  useDenormalized,\n  useError,\n  useFetch,\n  useFetchDispatcher,\n  useFetcher,\n  useInvalidateDispatcher,\n  useInvalidator,\n  useMeta,\n  usePromisifiedDispatch,\n  useResetter,\n  useResource,\n  useRetrieve,\n  useSubscription,\n  useSuspense,\n};\n"}}]);