(self.webpackChunk=self.webpackChunk||[]).push([[42713],{93716:n=>{n.exports="export default BigNumber;\n\nexport namespace BigNumber {\n  /** See `BigNumber.config` (alias `BigNumber.set`) and `BigNumber.clone`. */\n  interface Config {\n    /**\n     * An integer, 0 to 1e+9. Default value: 20.\n     *\n     * The maximum number of decimal places of the result of operations involving division, i.e.\n     * division, square root and base conversion operations, and exponentiation when the exponent is\n     * negative.\n     *\n     * ```ts\n     * BigNumber.config({ DECIMAL_PLACES: 5 })\n     * BigNumber.set({ DECIMAL_PLACES: 5 })\n     * ```\n     */\n    DECIMAL_PLACES?: number;\n\n    /**\n     * An integer, 0 to 8. Default value: `BigNumber.ROUND_HALF_UP` (4).\n     *\n     * The rounding mode used in operations that involve division (see `DECIMAL_PLACES`) and the\n     * default rounding mode of the `decimalPlaces`, `precision`, `toExponential`, `toFixed`,\n     * `toFormat` and `toPrecision` methods.\n     *\n     * The modes are available as enumerated properties of the BigNumber constructor.\n     *\n     * ```ts\n     * BigNumber.config({ ROUNDING_MODE: 0 })\n     * BigNumber.set({ ROUNDING_MODE: BigNumber.ROUND_UP })\n     * ```\n     */\n    ROUNDING_MODE?: BigNumber.RoundingMode;\n\n    /**\n     * An integer, 0 to 1e+9, or an array, [-1e+9 to 0, 0 to 1e+9].\n     * Default value: `[-7, 20]`.\n     *\n     * The exponent value(s) at which `toString` returns exponential notation.\n     *\n     * If a single number is assigned, the value is the exponent magnitude.\n     *\n     * If an array of two numbers is assigned then the first number is the negative exponent value at\n     * and beneath which exponential notation is used, and the second number is the positive exponent\n     * value at and above which exponential notation is used.\n     *\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they begin\n     * to use exponential notation, use `[-7, 20]`.\n     *\n     * ```ts\n     * BigNumber.config({ EXPONENTIAL_AT: 2 })\n     * new BigNumber(12.3)         // '12.3'        e is only 1\n     * new BigNumber(123)          // '1.23e+2'\n     * new BigNumber(0.123)        // '0.123'       e is only -1\n     * new BigNumber(0.0123)       // '1.23e-2'\n     *\n     * BigNumber.config({ EXPONENTIAL_AT: [-7, 20] })\n     * new BigNumber(123456789)    // '123456789'   e is only 8\n     * new BigNumber(0.000000123)  // '1.23e-7'\n     *\n     * // Almost never return exponential notation:\n     * BigNumber.config({ EXPONENTIAL_AT: 1e+9 })\n     *\n     * // Always return exponential notation:\n     * BigNumber.config({ EXPONENTIAL_AT: 0 })\n     * ```\n     *\n     * Regardless of the value of `EXPONENTIAL_AT`, the `toFixed` method will always return a value in\n     * normal notation and the `toExponential` method will always return a value in exponential form.\n     * Calling `toString` with a base argument, e.g. `toString(10)`, will also always return normal\n     * notation.\n     */\n    EXPONENTIAL_AT?: number | [number, number];\n\n    /**\n     * An integer, magnitude 1 to 1e+9, or an array, [-1e+9 to -1, 1 to 1e+9].\n     * Default value: `[-1e+9, 1e+9]`.\n     *\n     * The exponent value(s) beyond which overflow to Infinity and underflow to zero occurs.\n     *\n     * If a single number is assigned, it is the maximum exponent magnitude: values wth a positive\n     * exponent of greater magnitude become Infinity and those with a negative exponent of greater\n     * magnitude become zero.\n     *\n     * If an array of two numbers is assigned then the first number is the negative exponent limit and\n     * the second number is the positive exponent limit.\n     *\n     * For example, to emulate JavaScript numbers in terms of the exponent values at which they\n     * become zero and Infinity, use [-324, 308].\n     *\n     * ```ts\n     * BigNumber.config({ RANGE: 500 })\n     * BigNumber.config().RANGE     // [ -500, 500 ]\n     * new BigNumber('9.999e499')   // '9.999e+499'\n     * new BigNumber('1e500')       // 'Infinity'\n     * new BigNumber('1e-499')      // '1e-499'\n     * new BigNumber('1e-500')      // '0'\n     *\n     * BigNumber.config({ RANGE: [-3, 4] })\n     * new BigNumber(99999)         // '99999'      e is only 4\n     * new BigNumber(100000)        // 'Infinity'   e is 5\n     * new BigNumber(0.001)         // '0.01'       e is only -3\n     * new BigNumber(0.0001)        // '0'          e is -4\n     * ```\n     * The largest possible magnitude of a finite BigNumber is 9.999...e+1000000000.\n     * The smallest possible magnitude of a non-zero BigNumber is 1e-1000000000.\n     */\n    RANGE?: number | [number, number];\n\n    /**\n     * A boolean: `true` or `false`. Default value: `false`.\n     *\n     * The value that determines whether cryptographically-secure pseudo-random number generation is\n     * used. If `CRYPTO` is set to true then the random method will generate random digits using\n     * `crypto.getRandomValues` in browsers that support it, or `crypto.randomBytes` if using a\n     * version of Node.js that supports it.\n     *\n     * If neither function is supported by the host environment then attempting to set `CRYPTO` to\n     * `true` will fail and an exception will be thrown.\n     *\n     * If `CRYPTO` is `false` then the source of randomness used will be `Math.random` (which is\n     * assumed to generate at least 30 bits of randomness).\n     *\n     * See `BigNumber.random`.\n     *\n     * ```ts\n     * // Node.js\n     * global.crypto = require('crypto')\n     *\n     * BigNumber.config({ CRYPTO: true })\n     * BigNumber.config().CRYPTO       // true\n     * BigNumber.random()              // 0.54340758610486147524\n     * ```\n     */\n    CRYPTO?: boolean;\n\n    /**\n     * An integer, 0, 1, 3, 6 or 9. Default value: `BigNumber.ROUND_DOWN` (1).\n     *\n     * The modulo mode used when calculating the modulus: `a mod n`.\n     * The quotient, `q = a / n`, is calculated according to the `ROUNDING_MODE` that corresponds to\n     * the chosen `MODULO_MODE`.\n     * The remainder, `r`, is calculated as: `r = a - n * q`.\n     *\n     * The modes that are most commonly used for the modulus/remainder operation are shown in the\n     * following table. Although the other rounding modes can be used, they may not give useful\n     * results.\n     *\n     * Property           | Value | Description\n     * :------------------|:------|:------------------------------------------------------------------\n     *  `ROUND_UP`        |   0   | The remainder is positive if the dividend is negative.\n     *  `ROUND_DOWN`      |   1   | The remainder has the same sign as the dividend.\n     *                    |       | Uses 'truncating division' and matches JavaScript's `%` operator .\n     *  `ROUND_FLOOR`     |   3   | The remainder has the same sign as the divisor.\n     *                    |       | This matches Python's `%` operator.\n     *  `ROUND_HALF_EVEN` |   6   | The IEEE 754 remainder function.\n     *  `EUCLID`          |   9   | The remainder is always positive.\n     *                    |       | Euclidian division: `q = sign(n) * floor(a / abs(n))`\n     *\n     * The rounding/modulo modes are available as enumerated properties of the BigNumber constructor.\n     *\n     * See `modulo`.\n     *\n     * ```ts\n     * BigNumber.config({ MODULO_MODE: BigNumber.EUCLID })\n     * BigNumber.set({ MODULO_MODE: 9 })          // equivalent\n     * ```\n     */\n    MODULO_MODE?: BigNumber.ModuloMode;\n\n    /**\n     * An integer, 0 to 1e+9. Default value: 0.\n     *\n     * The maximum precision, i.e. number of significant digits, of the result of the power operation\n     * - unless a modulus is specified.\n     *\n     * If set to 0, the number of significant digits will not be limited.\n     *\n     * See `exponentiatedBy`.\n     *\n     * ```ts\n     * BigNumber.config({ POW_PRECISION: 100 })\n     * ```\n     */\n    POW_PRECISION?: number;\n\n    /**\n     * An object including any number of the properties shown below.\n     *\n     * The object configures the format of the string returned by the `toFormat` method.\n     * The example below shows the properties of the object that are recognised, and\n     * their default values.\n     *\n     * Unlike the other configuration properties, the values of the properties of the `FORMAT` object\n     * will not be checked for validity - the existing object will simply be replaced by the object\n     * that is passed in.\n     *\n     * See `toFormat`.\n     *\n     * ```ts\n     * BigNumber.config({\n     *   FORMAT: {\n     *     // string to prepend\n     *     prefix: '',\n     *     // the decimal separator\n     *     decimalSeparator: '.',\n     *     // the grouping separator of the integer part\n     *     groupSeparator: ',',\n     *     // the primary grouping size of the integer part\n     *     groupSize: 3,\n     *     // the secondary grouping size of the integer part\n     *     secondaryGroupSize: 0,\n     *     // the grouping separator of the fraction part\n     *     fractionGroupSeparator: ' ',\n     *     // the grouping size of the fraction part\n     *     fractionGroupSize: 0,\n     *     // string to append\n     *     suffix: ''\n     *   }\n     * })\n     * ```\n     */\n    FORMAT?: BigNumber.Format;\n\n    /**\n     * The alphabet used for base conversion. The length of the alphabet corresponds to the maximum\n     * value of the base argument that can be passed to the BigNumber constructor or `toString`.\n     *\n     * Default value: `'0123456789abcdefghijklmnopqrstuvwxyz'`.\n     *\n     * There is no maximum length for the alphabet, but it must be at least 2 characters long,\n     * and it must not contain whitespace or a repeated character, or the sign indicators '+' and\n     * '-', or the decimal separator '.'.\n     *\n     * ```ts\n     * // duodecimal (base 12)\n     * BigNumber.config({ ALPHABET: '0123456789TE' })\n     * x = new BigNumber('T', 12)\n     * x.toString()                // '10'\n     * x.toString(12)              // 'T'\n     * ```\n     */\n    ALPHABET?: string;\n  }\n\n  /** See `FORMAT` and `toFormat`. */\n  interface Format {\n    /** The string to prepend. */\n    prefix?: string;\n\n    /** The decimal separator. */\n    decimalSeparator?: string;\n\n    /** The grouping separator of the integer part. */\n    groupSeparator?: string;\n\n    /** The primary grouping size of the integer part. */\n    groupSize?: number;\n\n    /** The secondary grouping size of the integer part. */\n    secondaryGroupSize?: number;\n\n    /** The grouping separator of the fraction part. */\n    fractionGroupSeparator?: string;\n\n    /** The grouping size of the fraction part. */\n    fractionGroupSize?: number;\n\n    /** The string to append. */\n    suffix?: string;\n  }\n\n  interface Instance {\n    /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\n    readonly c: number[] | null;\n\n    /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\n    readonly e: number | null;\n\n    /** The sign of the value of this BigNumber, -1, 1, or null. */\n    readonly s: number | null;\n\n    [key: string]: any;\n  }\n\n  type Constructor = typeof BigNumber;\n  type ModuloMode = 0 | 1 | 3 | 6 | 9;\n  type RoundingMode = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n  type Value = string | number | Instance;\n}\n\nexport declare class BigNumber implements BigNumber.Instance {\n  /** Used internally to identify a BigNumber instance. */\n  private readonly _isBigNumber: true;\n\n  /** The coefficient of the value of this BigNumber, an array of base 1e14 integer numbers, or null. */\n  readonly c: number[] | null;\n\n  /** The exponent of the value of this BigNumber, an integer number, -1000000000 to 1000000000, or null. */\n  readonly e: number | null;\n\n  /** The sign of the value of this BigNumber, -1, 1, or null. */\n  readonly s: number | null;\n\n  /**\n   * Returns a new instance of a BigNumber object with value `n`, where `n` is a numeric value in\n   * the specified `base`, or base 10 if `base` is omitted or is `null` or `undefined`.\n   *\n   * ```ts\n   * x = new BigNumber(123.4567)              // '123.4567'\n   * // 'new' is optional\n   * y = BigNumber(x)                         // '123.4567'\n   * ```\n   *\n   * If `n` is a base 10 value it can be in normal (fixed-point) or exponential notation.\n   * Values in other bases must be in normal notation. Values in any base can have fraction digits,\n   * i.e. digits after the decimal point.\n   *\n   * ```ts\n   * new BigNumber(43210)                     // '43210'\n   * new BigNumber('4.321e+4')                // '43210'\n   * new BigNumber('-735.0918e-430')          // '-7.350918e-428'\n   * new BigNumber('123412421.234324', 5)     // '607236.557696'\n   * ```\n   *\n   * Signed `0`, signed `Infinity` and `NaN` are supported.\n   *\n   * ```ts\n   * new BigNumber('-Infinity')               // '-Infinity'\n   * new BigNumber(NaN)                       // 'NaN'\n   * new BigNumber(-0)                        // '0'\n   * new BigNumber('.5')                      // '0.5'\n   * new BigNumber('+2')                      // '2'\n   * ```\n   *\n   * String values in hexadecimal literal form, e.g. `'0xff'`, are valid, as are string values with\n   * the octal and binary prefixs `'0o'` and `'0b'`. String values in octal literal form without the\n   * prefix will be interpreted as decimals, e.g. `'011'` is interpreted as 11, not 9.\n   *\n   * ```ts\n   * new BigNumber(-10110100.1, 2)            // '-180.5'\n   * new BigNumber('-0b10110100.1')           // '-180.5'\n   * new BigNumber('ff.8', 16)                // '255.5'\n   * new BigNumber('0xff.8')                  // '255.5'\n   * ```\n   *\n   * If a base is specified, `n` is rounded according to the current `DECIMAL_PLACES` and\n   * `ROUNDING_MODE` settings. This includes base 10, so don't include a `base` parameter for decimal\n   * values unless this behaviour is desired.\n   *\n   * ```ts\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\n   * new BigNumber(1.23456789)                // '1.23456789'\n   * new BigNumber(1.23456789, 10)            // '1.23457'\n   * ```\n   *\n   * An error is thrown if `base` is invalid.\n   *\n   * There is no limit to the number of digits of a value of type string (other than that of\n   * JavaScript's maximum array size). See `RANGE` to set the maximum and minimum possible exponent\n   * value of a BigNumber.\n   *\n   * ```ts\n   * new BigNumber('5032485723458348569331745.33434346346912144534543')\n   * new BigNumber('4.321e10000000')\n   * ```\n   *\n   * BigNumber `NaN` is returned if `n` is invalid (unless `BigNumber.DEBUG` is `true`, see below).\n   *\n   * ```ts\n   * new BigNumber('.1*')                    // 'NaN'\n   * new BigNumber('blurgh')                 // 'NaN'\n   * new BigNumber(9, 2)                     // 'NaN'\n   * ```\n   *\n   * To aid in debugging, if `BigNumber.DEBUG` is `true` then an error will be thrown on an\n   * invalid `n`. An error will also be thrown if `n` is of type number with more than 15\n   * significant digits, as calling `toString` or `valueOf` on these numbers may not result in the\n   * intended value.\n   *\n   * ```ts\n   * console.log(823456789123456.3)          //  823456789123456.2\n   * new BigNumber(823456789123456.3)        // '823456789123456.2'\n   * BigNumber.DEBUG = true\n   * // 'Error: Number has more than 15 significant digits'\n   * new BigNumber(823456789123456.3)\n   * // 'Error: Not a base 2 number'\n   * new BigNumber(9, 2)\n   * ```\n   *\n   * A BigNumber can also be created from an object literal.\n   * Use `isBigNumber` to check that it is well-formed.\n   *\n   * ```ts\n   * new BigNumber({ s: 1, e: 2, c: [ 777, 12300000000000 ], _isBigNumber: true })    // '777.123'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param base The base of `n`, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\n   */\n  constructor(n: BigNumber.Value, base?: number);\n\n  /**\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\n   * BigNumber.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber(-0.8)\n   * x.absoluteValue()           // '0.8'\n   * ```\n   */\n  absoluteValue(): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the absolute value, i.e. the magnitude, of the value of this\n   * BigNumber.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber(-0.8)\n   * x.abs()                     // '0.8'\n   * ```\n   */\n  abs(): BigNumber;\n\n  /**\n   *  Returns |                                                               |\n   * :-------:|:--------------------------------------------------------------|\n   *     1    | If the value of this BigNumber is greater than the value of `n`\n   *    -1    | If the value of this BigNumber is less than the value of `n`\n   *     0    | If this BigNumber and `n` have the same value\n   *  `null`  | If the value of either this BigNumber or `n` is `NaN`\n   *\n   * ```ts\n   *\n   * x = new BigNumber(Infinity)\n   * y = new BigNumber(5)\n   * x.comparedTo(y)                 // 1\n   * x.comparedTo(x.minus(1))        // 0\n   * y.comparedTo(NaN)               // null\n   * y.comparedTo('110', 2)          // -1\n   * ```\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  comparedTo(n: BigNumber.Value, base?: number): number;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\n   *\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\n   * \xb1`Infinity` or `NaN`.\n   *\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(1234.56)\n   * x.decimalPlaces()                      // 2\n   * x.decimalPlaces(1)                     // '1234.6'\n   * x.decimalPlaces(2)                     // '1234.56'\n   * x.decimalPlaces(10)                    // '1234.56'\n   * x.decimalPlaces(0, 1)                  // '1234'\n   * x.decimalPlaces(0, 6)                  // '1235'\n   * x.decimalPlaces(1, 1)                  // '1234.5'\n   * x.decimalPlaces(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\n   * x                                      // '1234.56'\n   * y = new BigNumber('9.9e-101')\n   * y.decimalPlaces()                      // 102\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  decimalPlaces(): number | null;\n  decimalPlaces(\n    decimalPlaces: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber rounded by rounding mode\n   * `roundingMode` to a maximum of `decimalPlaces` decimal places.\n   *\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the return value is the number of\n   * decimal places of the value of this BigNumber, or `null` if the value of this BigNumber is\n   * \xb1`Infinity` or `NaN`.\n   *\n   * If `roundingMode` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(1234.56)\n   * x.dp()                                 // 2\n   * x.dp(1)                                // '1234.6'\n   * x.dp(2)                                // '1234.56'\n   * x.dp(10)                               // '1234.56'\n   * x.dp(0, 1)                             // '1234'\n   * x.dp(0, 6)                             // '1235'\n   * x.dp(1, 1)                             // '1234.5'\n   * x.dp(1, BigNumber.ROUND_HALF_EVEN)     // '1234.6'\n   * x                                      // '1234.56'\n   * y = new BigNumber('9.9e-101')\n   * y.dp()                                 // 102\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  dp(): number | null;\n  dp(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\n   *\n   * ```ts\n   * x = new BigNumber(355)\n   * y = new BigNumber(113)\n   * x.dividedBy(y)                  // '3.14159292035398230088'\n   * x.dividedBy(5)                  // '71'\n   * x.dividedBy(47, 16)             // '5'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  dividedBy(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\n   *\n   * ```ts\n   * x = new BigNumber(355)\n   * y = new BigNumber(113)\n   * x.div(y)                    // '3.14159292035398230088'\n   * x.div(5)                    // '71'\n   * x.div(47, 16)               // '5'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  div(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\n   * `n`.\n   *\n   * ```ts\n   * x = new BigNumber(5)\n   * y = new BigNumber(3)\n   * x.dividedToIntegerBy(y)              // '1'\n   * x.dividedToIntegerBy(0.7)            // '7'\n   * x.dividedToIntegerBy('0.f', 16)      // '5'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  dividedToIntegerBy(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the integer part of dividing the value of this BigNumber by\n   * `n`.\n   *\n   * ```ts\n   * x = new BigNumber(5)\n   * y = new BigNumber(3)\n   * x.idiv(y)                       // '1'\n   * x.idiv(0.7)                     // '7'\n   * x.idiv('0.f', 16)               // '5'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  idiv(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\n   * raised to the power `n`, and optionally modulo a modulus `m`.\n   *\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\n   * `ROUNDING_MODE` settings.\n   *\n   * As the number of digits of the result of the power operation can grow so large so quickly,\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\n   *\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\n   * digits will be calculated, and that the method's performance will decrease dramatically for\n   * larger exponents.\n   *\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\n   * be performed as `x.exponentiatedBy(n).modulo(m)` with a `POW_PRECISION` of 0.\n   *\n   * Throws if `n` is not an integer.\n   *\n   * ```ts\n   * Math.pow(0.7, 2)                    // 0.48999999999999994\n   * x = new BigNumber(0.7)\n   * x.exponentiatedBy(2)                // '0.49'\n   * BigNumber(3).exponentiatedBy(-2)    // '0.11111111111111111111'\n   * ```\n   *\n   * @param n The exponent, an integer.\n   * @param [m] The modulus.\n   */\n  exponentiatedBy(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\n  exponentiatedBy(n: number, m?: BigNumber.Value): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber exponentiated by `n`, i.e.\n   * raised to the power `n`, and optionally modulo a modulus `m`.\n   *\n   * If `n` is negative the result is rounded according to the current `DECIMAL_PLACES` and\n   * `ROUNDING_MODE` settings.\n   *\n   * As the number of digits of the result of the power operation can grow so large so quickly,\n   * e.g. 123.456**10000 has over 50000 digits, the number of significant digits calculated is\n   * limited to the value of the `POW_PRECISION` setting (unless a modulus `m` is specified).\n   *\n   * By default `POW_PRECISION` is set to 0. This means that an unlimited number of significant\n   * digits will be calculated, and that the method's performance will decrease dramatically for\n   * larger exponents.\n   *\n   * If `m` is specified and the value of `m`, `n` and this BigNumber are integers and `n` is\n   * positive, then a fast modular exponentiation algorithm is used, otherwise the operation will\n   * be performed as `x.pow(n).modulo(m)` with a `POW_PRECISION` of 0.\n   *\n   * Throws if `n` is not an integer.\n   *\n   * ```ts\n   * Math.pow(0.7, 2)                   // 0.48999999999999994\n   * x = new BigNumber(0.7)\n   * x.pow(2)                           // '0.49'\n   * BigNumber(3).pow(-2)               // '0.11111111111111111111'\n   * ```\n   *\n   * @param n The exponent, an integer.\n   * @param [m] The modulus.\n   */\n  pow(n: BigNumber.Value, m?: BigNumber.Value): BigNumber;\n  pow(n: number, m?: BigNumber.Value): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using\n   * rounding mode `rm`.\n   *\n   * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `rm` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(123.456)\n   * x.integerValue()                        // '123'\n   * x.integerValue(BigNumber.ROUND_CEIL)    // '124'\n   * y = new BigNumber(-12.7)\n   * y.integerValue()                        // '-13'\n   * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'\n   * ```\n   *\n   * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.\n   */\n  integerValue(rm?: BigNumber.RoundingMode): BigNumber;\n\n  /**\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\n   * `false`.\n   *\n   * As with JavaScript, `NaN` does not equal `NaN`.\n   *\n   * ```ts\n   * 0 === 1e-324                           // true\n   * x = new BigNumber(0)\n   * x.isEqualTo('1e-324')                  // false\n   * BigNumber(-0).isEqualTo(x)             // true  ( -0 === 0 )\n   * BigNumber(255).isEqualTo('ff', 16)     // true\n   *\n   * y = new BigNumber(NaN)\n   * y.isEqualTo(NaN)                // false\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  isEqualTo(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is equal to the value of `n`, otherwise returns\n   * `false`.\n   *\n   * As with JavaScript, `NaN` does not equal `NaN`.\n   *\n   * ```ts\n   * 0 === 1e-324                    // true\n   * x = new BigNumber(0)\n   * x.eq('1e-324')                  // false\n   * BigNumber(-0).eq(x)             // true  ( -0 === 0 )\n   * BigNumber(255).eq('ff', 16)     // true\n   *\n   * y = new BigNumber(NaN)\n   * y.eq(NaN)                       // false\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  eq(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is a finite number, otherwise returns `false`.\n   *\n   * The only possible non-finite values of a BigNumber are `NaN`, `Infinity` and `-Infinity`.\n   *\n   * ```ts\n   * x = new BigNumber(1)\n   * x.isFinite()                    // true\n   * y = new BigNumber(Infinity)\n   * y.isFinite()                    // false\n   * ```\n   */\n  isFinite(): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\n   * returns `false`.\n   *\n   * ```ts\n   * 0.1 > (0.3 - 0.2)                             // true\n   * x = new BigNumber(0.1)\n   * x.isGreaterThan(BigNumber(0.3).minus(0.2))    // false\n   * BigNumber(0).isGreaterThan(x)                 // false\n   * BigNumber(11, 3).isGreaterThan(11.1, 2)       // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  isGreaterThan(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is greater than the value of `n`, otherwise\n   * returns `false`.\n   *\n   * ```ts\n   * 0.1 > (0.3 - 0                     // true\n   * x = new BigNumber(0.1)\n   * x.gt(BigNumber(0.3).minus(0.2))    // false\n   * BigNumber(0).gt(x)                 // false\n   * BigNumber(11, 3).gt(11.1, 2)       // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  gt(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\n   * otherwise returns `false`.\n   *\n   * ```ts\n   * (0.3 - 0.2) >= 0.1                                  // false\n   * x = new BigNumber(0.3).minus(0.2)\n   * x.isGreaterThanOrEqualTo(0.1)                       // true\n   * BigNumber(1).isGreaterThanOrEqualTo(x)              // true\n   * BigNumber(10, 18).isGreaterThanOrEqualTo('i', 36)   // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  isGreaterThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is greater than or equal to the value of `n`,\n   * otherwise returns `false`.\n   *\n   * ```ts\n   * (0.3 - 0.2) >= 0.1                    // false\n   * x = new BigNumber(0.3).minus(0.2)\n   * x.gte(0.1)                            // true\n   * BigNumber(1).gte(x)                   // true\n   * BigNumber(10, 18).gte('i', 36)        // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  gte(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is an integer, otherwise returns `false`.\n   *\n   * ```ts\n   * x = new BigNumber(1)\n   * x.isInteger()                   // true\n   * y = new BigNumber(123.456)\n   * y.isInteger()                   // false\n   * ```\n   */\n  isInteger(): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\n   * `false`.\n   *\n   * ```ts\n   * (0.3 - 0.2) < 0.1                       // true\n   * x = new BigNumber(0.3).minus(0.2)\n   * x.isLessThan(0.1)                       // false\n   * BigNumber(0).isLessThan(x)              // true\n   * BigNumber(11.1, 2).isLessThan(11, 3)    // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  isLessThan(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns\n   * `false`.\n   *\n   * ```ts\n   * (0.3 - 0.2) < 0.1                       // true\n   * x = new BigNumber(0.3).minus(0.2)\n   * x.lt(0.1)                               // false\n   * BigNumber(0).lt(x)                      // true\n   * BigNumber(11.1, 2).lt(11, 3)            // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  lt(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\n   * otherwise returns `false`.\n   *\n   * ```ts\n   * 0.1 <= (0.3 - 0.2)                                 // false\n   * x = new BigNumber(0.1)\n   * x.isLessThanOrEqualTo(BigNumber(0.3).minus(0.2))   // true\n   * BigNumber(-1).isLessThanOrEqualTo(x)               // true\n   * BigNumber(10, 18).isLessThanOrEqualTo('i', 36)     // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  isLessThanOrEqualTo(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is less than or equal to the value of `n`,\n   * otherwise returns `false`.\n   *\n   * ```ts\n   * 0.1 <= (0.3 - 0.2)                  // false\n   * x = new BigNumber(0.1)\n   * x.lte(BigNumber(0.3).minus(0.2))    // true\n   * BigNumber(-1).lte(x)                // true\n   * BigNumber(10, 18).lte('i', 36)      // true\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  lte(n: BigNumber.Value, base?: number): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is `NaN`, otherwise returns `false`.\n   *\n   * ```ts\n   * x = new BigNumber(NaN)\n   * x.isNaN()                       // true\n   * y = new BigNumber('Infinity')\n   * y.isNaN()                       // false\n   * ```\n   */\n  isNaN(): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is negative, otherwise returns `false`.\n   *\n   * ```ts\n   * x = new BigNumber(-0)\n   * x.isNegative()                  // true\n   * y = new BigNumber(2)\n   * y.isNegative()                  // false\n   * ```\n   */\n  isNegative(): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is positive, otherwise returns `false`.\n   *\n   * ```ts\n   * x = new BigNumber(-0)\n   * x.isPositive()                  // false\n   * y = new BigNumber(2)\n   * y.isPositive()                  // true\n   * ```\n   */\n  isPositive(): boolean;\n\n  /**\n   * Returns `true` if the value of this BigNumber is zero or minus zero, otherwise returns `false`.\n   *\n   * ```ts\n   * x = new BigNumber(-0)\n   * x.isZero()                 // true\n   * ```\n   */\n  isZero(): boolean;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber minus `n`.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * 0.3 - 0.1                       // 0.19999999999999998\n   * x = new BigNumber(0.3)\n   * x.minus(0.1)                    // '0.2'\n   * x.minus(0.6, 20)                // '0'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  minus(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\n   * remainder of dividing this BigNumber by `n`.\n   *\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\n   * limits of double precision) and BigDecimal's `remainder` method.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * See `MODULO_MODE` for a description of the other modulo modes.\n   *\n   * ```ts\n   * 1 % 0.9                         // 0.09999999999999998\n   * x = new BigNumber(1)\n   * x.modulo(0.9)                   // '0.1'\n   * y = new BigNumber(33)\n   * y.modulo('a', 33)               // '3'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  modulo(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber modulo `n`, i.e. the integer\n   * remainder of dividing this BigNumber by `n`.\n   *\n   * The value returned, and in particular its sign, is dependent on the value of the `MODULO_MODE`\n   * setting of this BigNumber constructor. If it is 1 (default value), the result will have the\n   * same sign as this BigNumber, and it will match that of Javascript's `%` operator (within the\n   * limits of double precision) and BigDecimal's `remainder` method.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * See `MODULO_MODE` for a description of the other modulo modes.\n   *\n   * ```ts\n   * 1 % 0.9                      // 0.09999999999999998\n   * x = new BigNumber(1)\n   * x.mod(0.9)                   // '0.1'\n   * y = new BigNumber(33)\n   * y.mod('a', 33)               // '3'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  mod(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * 0.6 * 3                                // 1.7999999999999998\n   * x = new BigNumber(0.6)\n   * y = x.multipliedBy(3)                  // '1.8'\n   * BigNumber('7e+500').multipliedBy(y)    // '1.26e+501'\n   * x.multipliedBy('-a', 16)               // '-6'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  multipliedBy(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * 0.6 * 3                         // 1.7999999999999998\n   * x = new BigNumber(0.6)\n   * y = x.times(3)                  // '1.8'\n   * BigNumber('7e+500').times(y)    // '1.26e+501'\n   * x.times('-a', 16)               // '-6'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  times(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber negated, i.e. multiplied by -1.\n   *\n   * ```ts\n   * x = new BigNumber(1.8)\n   * x.negated()                     // '-1.8'\n   * y = new BigNumber(-1.3)\n   * y.negated()                     // '1.3'\n   * ```\n   */\n  negated(): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber plus `n`.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * 0.1 + 0.2                       // 0.30000000000000004\n   * x = new BigNumber(0.1)\n   * y = x.plus(0.2)                 // '0.3'\n   * BigNumber(0.7).plus(x).plus(y)  // '1.1'\n   * x.plus('0.1', 8)                // '0.225'\n   * ```\n   *\n   * @param n A numeric value.\n   * @param [base] The base of n.\n   */\n  plus(n: BigNumber.Value, base?: number): BigNumber;\n\n  /**\n   * Returns the number of significant digits of the value of this BigNumber, or `null` if the value\n   * of this BigNumber is \xb1`Infinity` or `NaN`.\n   *\n   * If `includeZeros` is true then any trailing zeros of the integer part of the value of this\n   * BigNumber are counted as significant digits, otherwise they are not.\n   *\n   * Throws if `includeZeros` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(9876.54321)\n   * x.precision()                         // 9\n   * y = new BigNumber(987000)\n   * y.precision(false)                    // 3\n   * y.precision(true)                     // 6\n   * ```\n   *\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\n   */\n  precision(includeZeros?: boolean): number;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\n   *\n   * Throws if `significantDigits` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(9876.54321)\n   * x.precision(6)                         // '9876.54'\n   * x.precision(6, BigNumber.ROUND_UP)     // '9876.55'\n   * x.precision(2)                         // '9900'\n   * x.precision(2, 1)                      // '9800'\n   * x                                      // '9876.54321'\n   * ```\n   *\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  precision(\n    significantDigits: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): BigNumber;\n\n  /**\n   * Returns the number of significant digits of the value of this BigNumber,\n   * or `null` if the value of this BigNumber is \xb1`Infinity` or `NaN`.\n   *\n   * If `includeZeros` is true then any trailing zeros of the integer part of\n   * the value of this BigNumber are counted as significant digits, otherwise\n   * they are not.\n   *\n   * Throws if `includeZeros` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(9876.54321)\n   * x.sd()                         // 9\n   * y = new BigNumber(987000)\n   * y.sd(false)                    // 3\n   * y.sd(true)                     // 6\n   * ```\n   *\n   * @param [includeZeros] Whether to include integer trailing zeros in the significant digit count.\n   */\n  sd(includeZeros?: boolean): number;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber rounded to a precision of\n   * `significantDigits` significant digits using rounding mode `roundingMode`.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` will be used.\n   *\n   * Throws if `significantDigits` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(9876.54321)\n   * x.sd(6)                           // '9876.54'\n   * x.sd(6, BigNumber.ROUND_UP)       // '9876.55'\n   * x.sd(2)                           // '9900'\n   * x.sd(2, 1)                        // '9800'\n   * x                                 // '9876.54321'\n   * ```\n   *\n   * @param significantDigits Significant digits, integer, 1 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  sd(\n    significantDigits: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the value of this BigNumber shifted by `n` places.\n   *\n   * The shift is of the decimal point, i.e. of powers of ten, and is to the left if `n` is negative\n   * or to the right if `n` is positive.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * Throws if `n` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(1.23)\n   * x.shiftedBy(3)                      // '1230'\n   * x.shiftedBy(-3)                     // '0.00123'\n   * ```\n   *\n   * @param n The shift value, integer, -9007199254740991 to 9007199254740991.\n   */\n  shiftedBy(n: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\n   *\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\n   * to an infinite number of correct digits before rounding.\n   *\n   * ```ts\n   * x = new BigNumber(16)\n   * x.squareRoot()                  // '4'\n   * y = new BigNumber(3)\n   * y.squareRoot()                  // '1.73205080756887729353'\n   * ```\n   */\n  squareRoot(): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the square root of the value of this BigNumber, rounded\n   * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.\n   *\n   * The return value will be correctly rounded, i.e. rounded as if the result was first calculated\n   * to an infinite number of correct digits before rounding.\n   *\n   * ```ts\n   * x = new BigNumber(16)\n   * x.sqrt()                  // '4'\n   * y = new BigNumber(3)\n   * y.sqrt()                  // '1.73205080756887729353'\n   * ```\n   */\n  sqrt(): BigNumber;\n\n  /**\n   * Returns a string representing the value of this BigNumber in exponential notation rounded using\n   * rounding mode `roundingMode` to `decimalPlaces` decimal places, i.e with one digit before the\n   * decimal point and `decimalPlaces` digits after it.\n   *\n   * If the value of this BigNumber in exponential notation has fewer than `decimalPlaces` fraction\n   * digits, the return value will be appended with zeros accordingly.\n   *\n   * If `decimalPlaces` is omitted, or is `null` or `undefined`, the number of digits after the\n   * decimal point defaults to the minimum number of digits necessary to represent the value\n   * exactly.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = 45.6\n   * y = new BigNumber(x)\n   * x.toExponential()               // '4.56e+1'\n   * y.toExponential()               // '4.56e+1'\n   * x.toExponential(0)              // '5e+1'\n   * y.toExponential(0)              // '5e+1'\n   * x.toExponential(1)              // '4.6e+1'\n   * y.toExponential(1)              // '4.6e+1'\n   * y.toExponential(1, 1)           // '4.5e+1'  (ROUND_DOWN)\n   * x.toExponential(3)              // '4.560e+1'\n   * y.toExponential(3)              // '4.560e+1'\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  toExponential(\n    decimalPlaces: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): string;\n\n  toExponential(): string;\n\n  /**\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`.\n   *\n   * If the value of this BigNumber in normal notation has fewer than `decimalPlaces` fraction\n   * digits, the return value will be appended with zeros accordingly.\n   *\n   * Unlike `Number.prototype.toFixed`, which returns exponential notation if a number is greater or\n   * equal to 10**21, this method will always return normal notation.\n   *\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, the return value will be unrounded\n   * and in normal notation. This is also unlike `Number.prototype.toFixed`, which returns the value\n   * to zero decimal places. It is useful when normal notation is required and the current\n   * `EXPONENTIAL_AT` setting causes `toString` to return exponential notation.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `decimalPlaces` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = 3.456\n   * y = new BigNumber(x)\n   * x.toFixed()                     // '3'\n   * y.toFixed()                     // '3.456'\n   * y.toFixed(0)                    // '3'\n   * x.toFixed(2)                    // '3.46'\n   * y.toFixed(2)                    // '3.46'\n   * y.toFixed(2, 1)                 // '3.45'  (ROUND_DOWN)\n   * x.toFixed(5)                    // '3.45600'\n   * y.toFixed(5)                    // '3.45600'\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   */\n  toFixed(decimalPlaces: number, roundingMode?: BigNumber.RoundingMode): string;\n  toFixed(): string;\n\n  /**\n   * Returns a string representing the value of this BigNumber in normal (fixed-point) notation\n   * rounded to `decimalPlaces` decimal places using rounding mode `roundingMode`, and formatted\n   * according to the properties of the `format` or `FORMAT` object.\n   *\n   * The formatting object may contain some or all of the properties shown in the examples below.\n   *\n   * If `decimalPlaces` is omitted or is `null` or `undefined`, then the return value is not\n   * rounded to a fixed number of decimal places.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * If `format` is omitted or is `null` or `undefined`, `FORMAT` is used.\n   *\n   * Throws if `decimalPlaces`, `roundingMode`, or `format` is invalid.\n   *\n   * ```ts\n   * fmt = {\n   *   decimalSeparator: '.',\n   *   groupSeparator: ',',\n   *   groupSize: 3,\n   *   secondaryGroupSize: 0,\n   *   fractionGroupSeparator: ' ',\n   *   fractionGroupSize: 0\n   * }\n   *\n   * x = new BigNumber('123456789.123456789')\n   *\n   * // Set the global formatting options\n   * BigNumber.config({ FORMAT: fmt })\n   *\n   * x.toFormat()                              // '123,456,789.123456789'\n   * x.toFormat(3)                             // '123,456,789.123'\n   *\n   * // If a reference to the object assigned to FORMAT has been retained,\n   * // the format properties can be changed directly\n   * fmt.groupSeparator = ' '\n   * fmt.fractionGroupSize = 5\n   * x.toFormat()                              // '123 456 789.12345 6789'\n   *\n   * // Alternatively, pass the formatting options as an argument\n   * fmt = {\n   *   decimalSeparator: ',',\n   *   groupSeparator: '.',\n   *   groupSize: 3,\n   *   secondaryGroupSize: 2\n   * }\n   *\n   * x.toFormat()                              // '123 456 789.12345 6789'\n   * x.toFormat(fmt)                           // '12.34.56.789,123456789'\n   * x.toFormat(2, fmt)                        // '12.34.56.789,12'\n   * x.toFormat(3, BigNumber.ROUND_UP, fmt)    // '12.34.56.789,124'\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer, 0 to 8.\n   * @param [format] Formatting options object. See `BigNumber.Format`.\n   */\n  toFormat(\n    decimalPlaces: number,\n    roundingMode: BigNumber.RoundingMode,\n    format?: BigNumber.Format,\n  ): string;\n\n  toFormat(\n    decimalPlaces: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): string;\n\n  toFormat(decimalPlaces?: number): string;\n  toFormat(decimalPlaces: number, format: BigNumber.Format): string;\n  toFormat(format: BigNumber.Format): string;\n\n  /**\n   * Returns an array of two BigNumbers representing the value of this BigNumber as a simple\n   * fraction with an integer numerator and an integer denominator.\n   * The denominator will be a positive non-zero value less than or equal to `max_denominator`.\n   * If a maximum denominator, `max_denominator`, is not specified, or is `null` or `undefined`, the\n   * denominator will be the lowest value necessary to represent the number exactly.\n   *\n   * Throws if `max_denominator` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(1.75)\n   * x.toFraction()                  // '7, 4'\n   *\n   * pi = new BigNumber('3.14159265358')\n   * pi.toFraction()                 // '157079632679,50000000000'\n   * pi.toFraction(100000)           // '312689, 99532'\n   * pi.toFraction(10000)            // '355, 113'\n   * pi.toFraction(100)              // '311, 99'\n   * pi.toFraction(10)               // '22, 7'\n   * pi.toFraction(1)                // '3, 1'\n   * ```\n   *\n   * @param [max_denominator] The maximum denominator, integer > 0, or Infinity.\n   */\n  toFraction(max_denominator?: BigNumber.Value): [BigNumber, BigNumber];\n\n  /** As `valueOf`. */\n  toJSON(): string;\n\n  /**\n   * Returns the value of this BigNumber as a JavaScript primitive number.\n   *\n   * Using the unary plus operator gives the same result.\n   *\n   * ```ts\n   * x = new BigNumber(456.789)\n   * x.toNumber()                    // 456.789\n   * +x                              // 456.789\n   *\n   * y = new BigNumber('45987349857634085409857349856430985')\n   * y.toNumber()                    // 4.598734985763409e+34\n   *\n   * z = new BigNumber(-0)\n   * 1 / z.toNumber()                // -Infinity\n   * 1 / +z                          // -Infinity\n   * ```\n   */\n  toNumber(): number;\n\n  /**\n   * Returns a string representing the value of this BigNumber rounded to `significantDigits`\n   * significant digits using rounding mode `roundingMode`.\n   *\n   * If `significantDigits` is less than the number of digits necessary to represent the integer\n   * part of the value in normal (fixed-point) notation, then exponential notation is used.\n   *\n   * If `significantDigits` is omitted, or is `null` or `undefined`, then the return value is the\n   * same as `n.toString()`.\n   *\n   * If `roundingMode` is omitted or is `null` or `undefined`, `ROUNDING_MODE` is used.\n   *\n   * Throws if `significantDigits` or `roundingMode` is invalid.\n   *\n   * ```ts\n   * x = 45.6\n   * y = new BigNumber(x)\n   * x.toPrecision()                 // '45.6'\n   * y.toPrecision()                 // '45.6'\n   * x.toPrecision(1)                // '5e+1'\n   * y.toPrecision(1)                // '5e+1'\n   * y.toPrecision(2, 0)             // '4.6e+1'  (ROUND_UP)\n   * y.toPrecision(2, 1)             // '4.5e+1'  (ROUND_DOWN)\n   * x.toPrecision(5)                // '45.600'\n   * y.toPrecision(5)                // '45.600'\n   * ```\n   *\n   * @param [significantDigits] Significant digits, integer, 1 to 1e+9.\n   * @param [roundingMode] Rounding mode, integer 0 to 8.\n   */\n  toPrecision(\n    significantDigits: number,\n    roundingMode?: BigNumber.RoundingMode,\n  ): string;\n\n  toPrecision(): string;\n\n  /**\n   * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`\n   * is omitted or is `null` or `undefined`.\n   *\n   * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values\n   * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).\n   *\n   * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and\n   * `ROUNDING_MODE` settings, otherwise it is not.\n   *\n   * If a base is not specified, and this BigNumber has a positive exponent that is equal to or\n   * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative\n   * exponent equal to or less than the negative component of the setting, then exponential notation\n   * is returned.\n   *\n   * If `base` is `null` or `undefined` it is ignored.\n   *\n   * Throws if `base` is invalid.\n   *\n   * ```ts\n   * x = new BigNumber(750000)\n   * x.toString()                    // '750000'\n   * BigNumber.config({ EXPONENTIAL_AT: 5 })\n   * x.toString()                    // '7.5e+5'\n   *\n   * y = new BigNumber(362.875)\n   * y.toString(2)                   // '101101010.111'\n   * y.toString(9)                   // '442.77777777777777777778'\n   * y.toString(32)                  // 'ba.s'\n   *\n   * BigNumber.config({ DECIMAL_PLACES: 4 });\n   * z = new BigNumber('1.23456789')\n   * z.toString()                    // '1.23456789'\n   * z.toString(10)                  // '1.2346'\n   * ```\n   *\n   * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).\n   */\n  toString(base?: number): string;\n\n  /**\n   * As `toString`, but does not accept a base argument and includes the minus sign for negative\n   * zero.\n   *\n   * ``ts\n   * x = new BigNumber('-0')\n   * x.toString()                    // '0'\n   * x.valueOf()                     // '-0'\n   * y = new BigNumber('1.777e+457')\n   * y.valueOf()                     // '1.777e+457'\n   * ```\n   */\n  valueOf(): string;\n\n  /** Helps ES6 import. */\n  private static readonly default?: BigNumber.Constructor;\n\n  /** Helps ES6 import. */\n  private static readonly BigNumber?: BigNumber.Constructor;\n\n  /** Rounds away from zero. */\n  static readonly ROUND_UP: 0;\n\n  /** Rounds towards zero. */\n  static readonly ROUND_DOWN: 1;\n\n  /** Rounds towards Infinity. */\n  static readonly ROUND_CEIL: 2;\n\n  /** Rounds towards -Infinity. */\n  static readonly ROUND_FLOOR: 3;\n\n  /** Rounds towards nearest neighbour. If equidistant, rounds away from zero . */\n  static readonly ROUND_HALF_UP: 4;\n\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards zero. */\n  static readonly ROUND_HALF_DOWN: 5;\n\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards even neighbour. */\n  static readonly ROUND_HALF_EVEN: 6;\n\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards Infinity. */\n  static readonly ROUND_HALF_CEIL: 7;\n\n  /** Rounds towards nearest neighbour. If equidistant, rounds towards -Infinity. */\n  static readonly ROUND_HALF_FLOOR: 8;\n\n  /** See `MODULO_MODE`. */\n  static readonly EUCLID: 9;\n\n  /**\n   * To aid in debugging, if a `BigNumber.DEBUG` property is `true` then an error will be thrown\n   * if the BigNumber constructor receives an invalid `BigNumber.Value`, or if `BigNumber.isBigNumber`\n   * receives a BigNumber instance that is malformed.\n   *\n   * ```ts\n   * // No error, and BigNumber NaN is returned.\n   * new BigNumber('blurgh')    // 'NaN'\n   * new BigNumber(9, 2)        // 'NaN'\n   * BigNumber.DEBUG = true\n   * new BigNumber('blurgh')    // '[BigNumber Error] Not a number'\n   * new BigNumber(9, 2)        // '[BigNumber Error] Not a base 2 number'\n   * ```\n   *\n   * An error will also be thrown if a `BigNumber.Value` is of type number with more than 15\n   * significant digits, as calling `toString` or `valueOf` on such numbers may not result\n   * in the intended value.\n   *\n   * ```ts\n   * console.log(823456789123456.3)       //  823456789123456.2\n   * // No error, and the returned BigNumber does not have the same value as the number literal.\n   * new BigNumber(823456789123456.3)     // '823456789123456.2'\n   * BigNumber.DEBUG = true\n   * new BigNumber(823456789123456.3)\n   * // '[BigNumber Error] Number primitive has more than 15 significant digits'\n   * ```\n   *\n   * Check that a BigNumber instance is well-formed:\n   *\n   * ```ts\n   * x = new BigNumber(10)\n   *\n   * BigNumber.DEBUG = false\n   * // Change x.c to an illegitimate value.\n   * x.c = NaN\n   * // No error, as BigNumber.DEBUG is false.\n   * BigNumber.isBigNumber(x)    // true\n   *\n   * BigNumber.DEBUG = true\n   * BigNumber.isBigNumber(x)    // '[BigNumber Error] Invalid BigNumber'\n   * ```\n   */\n  static DEBUG?: boolean;\n\n  /**\n   * Returns a new independent BigNumber constructor with configuration as described by `object`, or\n   * with the default configuration if object is `null` or `undefined`.\n   *\n   * Throws if `object` is not an object.\n   *\n   * ```ts\n   * BigNumber.config({ DECIMAL_PLACES: 5 })\n   * BN = BigNumber.clone({ DECIMAL_PLACES: 9 })\n   *\n   * x = new BigNumber(1)\n   * y = new BN(1)\n   *\n   * x.div(3)                        // 0.33333\n   * y.div(3)                        // 0.333333333\n   *\n   * // BN = BigNumber.clone({ DECIMAL_PLACES: 9 }) is equivalent to:\n   * BN = BigNumber.clone()\n   * BN.config({ DECIMAL_PLACES: 9 })\n   * ```\n   *\n   * @param [object] The configuration object.\n   */\n  static clone(object?: BigNumber.Config): BigNumber.Constructor;\n\n  /**\n   * Configures the settings that apply to this BigNumber constructor.\n   *\n   * The configuration object, `object`, contains any number of the properties shown in the example\n   * below.\n   *\n   * Returns an object with the above properties and their current values.\n   *\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\n   * properties.\n   *\n   * ```ts\n   * BigNumber.config({\n   *     DECIMAL_PLACES: 40,\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\n   *     EXPONENTIAL_AT: [-10, 20],\n   *     RANGE: [-500, 500],\n   *     CRYPTO: true,\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\n   *     POW_PRECISION: 80,\n   *     FORMAT: {\n   *         groupSize: 3,\n   *         groupSeparator: ' ',\n   *         decimalSeparator: ','\n   *     },\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n   * });\n   *\n   * BigNumber.config().DECIMAL_PLACES        // 40\n   * ```\n   *\n   * @param object The configuration object.\n   */\n  static config(object: BigNumber.Config): BigNumber.Config;\n\n  /**\n   * Returns `true` if `value` is a BigNumber instance, otherwise returns `false`.\n   *\n   * If `BigNumber.DEBUG` is `true`, throws if a BigNumber instance is not well-formed.\n   *\n   * ```ts\n   * x = 42\n   * y = new BigNumber(x)\n   *\n   * BigNumber.isBigNumber(x)             // false\n   * y instanceof BigNumber               // true\n   * BigNumber.isBigNumber(y)             // true\n   *\n   * BN = BigNumber.clone();\n   * z = new BN(x)\n   * z instanceof BigNumber               // false\n   * BigNumber.isBigNumber(z)             // true\n   * ```\n   *\n   * @param value The value to test.\n   */\n  static isBigNumber(value: any): value is BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the maximum of the arguments.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber('3257869345.0378653')\n   * BigNumber.maximum(4e9, x, '123456789.9')      // '4000000000'\n   *\n   * arr = [12, '13', new BigNumber(14)]\n   * BigNumber.maximum.apply(null, arr)            // '14'\n   * ```\n   *\n   * @param n A numeric value.\n   */\n  static maximum(...n: BigNumber.Value[]): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the maximum of the arguments.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber('3257869345.0378653')\n   * BigNumber.max(4e9, x, '123456789.9')      // '4000000000'\n   *\n   * arr = [12, '13', new BigNumber(14)]\n   * BigNumber.max.apply(null, arr)            // '14'\n   * ```\n   *\n   * @param n A numeric value.\n   */\n  static max(...n: BigNumber.Value[]): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the minimum of the arguments.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber('3257869345.0378653')\n   * BigNumber.minimum(4e9, x, '123456789.9')          // '123456789.9'\n   *\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\n   * BigNumber.minimum.apply(null, arr)                // '-15.9999'\n   * ```\n   *\n   * @param n A numeric value.\n   */\n  static minimum(...n: BigNumber.Value[]): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the minimum of the arguments.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber('3257869345.0378653')\n   * BigNumber.min(4e9, x, '123456789.9')             // '123456789.9'\n   *\n   * arr = [2, new BigNumber(-14), '-15.9999', -12]\n   * BigNumber.min.apply(null, arr)                   // '-15.9999'\n   * ```\n   *\n   * @param n A numeric value.\n   */\n  static min(...n: BigNumber.Value[]): BigNumber;\n\n  /**\n   * Returns a new BigNumber with a pseudo-random value equal to or greater than 0 and less than 1.\n   *\n   * The return value will have `decimalPlaces` decimal places, or less if trailing zeros are\n   * produced. If `decimalPlaces` is omitted, the current `DECIMAL_PLACES` setting will be used.\n   *\n   * Depending on the value of this BigNumber constructor's `CRYPTO` setting and the support for the\n   * `crypto` object in the host environment, the random digits of the return value are generated by\n   * either `Math.random` (fastest), `crypto.getRandomValues` (Web Cryptography API in recent\n   * browsers) or `crypto.randomBytes` (Node.js).\n   *\n   * To be able to set `CRYPTO` to true when using Node.js, the `crypto` object must be available\n   * globally:\n   *\n   * ```ts\n   * global.crypto = require('crypto')\n   * ```\n   *\n   * If `CRYPTO` is true, i.e. one of the `crypto` methods is to be used, the value of a returned\n   * BigNumber should be cryptographically secure and statistically indistinguishable from a random\n   * value.\n   *\n   * Throws if `decimalPlaces` is invalid.\n   *\n   * ```ts\n   * BigNumber.config({ DECIMAL_PLACES: 10 })\n   * BigNumber.random()              // '0.4117936847'\n   * BigNumber.random(20)            // '0.78193327636914089009'\n   * ```\n   *\n   * @param [decimalPlaces] Decimal places, integer, 0 to 1e+9.\n   */\n  static random(decimalPlaces?: number): BigNumber;\n\n  /**\n   * Returns a BigNumber whose value is the sum of the arguments.\n   *\n   * The return value is always exact and unrounded.\n   *\n   * ```ts\n   * x = new BigNumber('3257869345.0378653')\n   * BigNumber.sum(4e9, x, '123456789.9')      // '7381326134.9378653'\n   *\n   * arr = [2, new BigNumber(14), '15.9999', 12]\n   * BigNumber.sum.apply(null, arr)            // '43.9999'\n   * ```\n   *\n   * @param n A numeric value.\n   */\n  static sum(...n: BigNumber.Value[]): BigNumber;\n\n  /**\n   * Configures the settings that apply to this BigNumber constructor.\n   *\n   * The configuration object, `object`, contains any number of the properties shown in the example\n   * below.\n   *\n   * Returns an object with the above properties and their current values.\n   *\n   * Throws if `object` is not an object, or if an invalid value is assigned to one or more of the\n   * properties.\n   *\n   * ```ts\n   * BigNumber.set({\n   *     DECIMAL_PLACES: 40,\n   *     ROUNDING_MODE: BigNumber.ROUND_HALF_CEIL,\n   *     EXPONENTIAL_AT: [-10, 20],\n   *     RANGE: [-500, 500],\n   *     CRYPTO: true,\n   *     MODULO_MODE: BigNumber.ROUND_FLOOR,\n   *     POW_PRECISION: 80,\n   *     FORMAT: {\n   *         groupSize: 3,\n   *         groupSeparator: ' ',\n   *         decimalSeparator: ','\n   *     },\n   *     ALPHABET: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n   * });\n   *\n   * BigNumber.set().DECIMAL_PLACES        // 40\n   * ```\n   *\n   * @param object The configuration object.\n   */\n  static set(object: BigNumber.Config): BigNumber.Config;\n}\n\nexport function BigNumber(n: BigNumber.Value, base?: number): BigNumber;\n"}}]);