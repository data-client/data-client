(self.webpackChunk=self.webpackChunk||[]).push([[97359],{61019:e=>{e.exports="import * as _rest_hooks_core from '@rest-hooks/core';\nimport {\n  Manager,\n  State as State$1,\n  Controller,\n  NetworkError as NetworkError$1,\n  ActionTypes,\n  DenormalizeCache,\n  legacyActions,\n  __INTERNAL__,\n  createReducer,\n  applyManager,\n} from '@rest-hooks/core';\nexport {\n  AbstractInstanceType,\n  ActionTypes,\n  Controller,\n  DefaultConnectionListener,\n  Denormalize,\n  DenormalizeNullable,\n  DevToolsManager,\n  Dispatch,\n  EndpointExtraOptions,\n  EndpointInterface,\n  ExpiryStatus,\n  FetchAction,\n  FetchFunction,\n  InvalidateAction,\n  Manager,\n  Middleware,\n  MiddlewareAPI,\n  NetworkError,\n  NetworkManager,\n  Normalize,\n  NormalizeNullable,\n  PK,\n  PollingSubscription,\n  ReceiveAction,\n  ReceiveTypes,\n  ResetAction,\n  ResolveType,\n  Schema,\n  State,\n  SubscribeAction,\n  SubscriptionManager,\n  UnknownError,\n  UnsubscribeAction,\n  UpdateFunction,\n  actionTypes,\n} from '@rest-hooks/core';\nimport React$1, { Context } from 'react';\n\ninterface ProviderProps {\n  children: React$1.ReactNode;\n  managers: Manager[];\n  initialState: State$1<unknown>;\n  Controller: typeof Controller;\n}\n/**\n * Manages state, providing all context needed to use the hooks.\n * @see https://resthooks.io/docs/api/CacheProvider\n */\ndeclare function CacheProvider({\n  children,\n  managers,\n  initialState,\n  Controller,\n}: ProviderProps): JSX.Element;\ndeclare namespace CacheProvider {\n  var defaultProps: {\n    managers: Manager[];\n    initialState: State$1<unknown>;\n    Controller: typeof Controller;\n  };\n}\n//# sourceMappingURL=CacheProvider.d.ts.map\n\ndeclare const _default$1: React$1.NamedExoticComponent<{\n  children: React$1.ReactNode;\n}>;\n//# sourceMappingURL=BackupBoundary.d.ts.map\n\n/**\n * Handles loading and error conditions of Suspense\n * @see https://resthooks.io/docs/api/AsyncBoundary\n */\ndeclare function AsyncBoundary({\n  children,\n  errorComponent,\n  fallback,\n}: {\n  children: React$1.ReactNode;\n  fallback?: React$1.ReactNode;\n  errorComponent?: React$1.ComponentType<{\n    error: NetworkError$1;\n  }>;\n}): JSX.Element;\ndeclare const _default: React$1.MemoExoticComponent<typeof AsyncBoundary>;\n//# sourceMappingURL=AsyncBoundary.d.ts.map\n\ninterface Props<E extends NetworkError$1> {\n  children: React$1.ReactNode;\n  fallbackComponent: React$1.ComponentType<{\n    error: E;\n  }>;\n}\ninterface State<E extends NetworkError$1> {\n  error?: E;\n}\n/**\n * Handles any networking errors from suspense\n * @see https://resthooks.io/docs/api/NetworkErrorBoundary\n */\ndeclare class NetworkErrorBoundary<\n  E extends NetworkError$1,\n> extends React$1.Component<Props<E>, State<E>> {\n  static defaultProps: {\n    fallbackComponent: ({ error }: { error: NetworkError$1 }) => JSX.Element;\n  };\n\n  static getDerivedStateFromError(error: NetworkError$1 | any): {\n    error: NetworkError$1;\n  };\n\n  state: State<E>;\n  render(): JSX.Element;\n}\n\ndeclare type Schema =\n  | null\n  | string\n  | {\n      [K: string]: any;\n    }\n  | Schema[]\n  | SchemaSimple\n  | Serializable;\ndeclare type Serializable<\n  T extends {\n    toJSON(): string;\n  } = {\n    toJSON(): string;\n  },\n> = {\n  prototype: T;\n};\ninterface SchemaSimple<T = any> {\n  normalize(\n    input: any,\n    parent: any,\n    key: any,\n    visit: (...args: any) => any,\n    addEntity: (...args: any) => any,\n    visitedEntities: Record<string, any>,\n  ): any;\n  denormalize(\n    input: {},\n    unvisit: UnvisitFunction,\n  ): [denormalized: T, found: boolean, suspend: boolean];\n  infer(\n    args: readonly any[],\n    indexes: NormalizedIndex,\n    recurse: (...args: any) => any,\n    entities: EntityTable,\n  ): any;\n}\ninterface SchemaClass<T = any, N = T | undefined> extends SchemaSimple<T> {\n  _normalizeNullable(): any;\n  _denormalizeNullable(): [N, boolean, boolean];\n}\ninterface EntityInterface<T = any> extends SchemaSimple {\n  pk(params: any, parent?: any, key?: string): string | undefined;\n  readonly key: string;\n  merge(existing: any, incoming: any): any;\n  expiresAt?(meta: any, input: any): number;\n  useIncoming?(\n    existingMeta: any,\n    incomingMeta: any,\n    existing: any,\n    incoming: any,\n  ): boolean;\n  indexes?: any;\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface UnvisitFunction {\n  (input: any, schema: any): [any, boolean, boolean];\n  og?: UnvisitFunction;\n  setLocal?: (entity: any) => void;\n}\ninterface NormalizedIndex {\n  readonly [entityKey: string]: {\n    readonly [indexName: string]: {\n      readonly [lookup: string]: string;\n    };\n  };\n}\ninterface EntityTable {\n  [entityKey: string]:\n    | {\n        [pk: string]: unknown;\n      }\n    | undefined;\n}\n\ndeclare type AbstractInstanceType<T> = T extends {\n  prototype: infer U;\n}\n  ? U\n  : never;\ndeclare type DenormalizeObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? Denormalize$1<S[K]> : S[K];\n};\ndeclare type DenormalizeNullableObject<S extends Record<string, any>> = {\n  [K in keyof S]: S[K] extends Schema ? DenormalizeNullable$1<S[K]> : S[K];\n};\ninterface NestedSchemaClass<T = any> {\n  schema: Record<string, Schema>;\n  prototype: T;\n}\ninterface RecordClass<T = any> extends NestedSchemaClass<T> {\n  fromJS: (...args: any) => AbstractInstanceType<T>;\n}\ndeclare type DenormalizeNullableNestedSchema<S extends NestedSchemaClass> =\n  keyof S['schema'] extends never\n    ? S['prototype']\n    : string extends keyof S['schema']\n    ? S['prototype']\n    : S['prototype'];\ndeclare type DenormalizeReturnType<T> = T extends (\n  input: any,\n  unvisit: any,\n) => [infer R, any, any]\n  ? R\n  : never;\ndeclare type Denormalize$1<S> = S extends EntityInterface<infer U>\n  ? U\n  : S extends RecordClass\n  ? AbstractInstanceType<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['denormalize']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[]\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeObject<S>\n  : S;\ndeclare type DenormalizeNullable$1<S> = S extends EntityInterface<any>\n  ? DenormalizeNullableNestedSchema<S> | undefined\n  : S extends RecordClass\n  ? DenormalizeNullableNestedSchema<S>\n  : S extends SchemaClass\n  ? DenormalizeReturnType<S['_denormalizeNullable']>\n  : S extends Serializable<infer T>\n  ? T\n  : S extends Array<infer F>\n  ? Denormalize$1<F>[] | undefined\n  : S extends {\n      [K: string]: any;\n    }\n  ? DenormalizeNullableObject<S>\n  : S;\n\ninterface NetworkError extends Error {\n  status: number;\n  response?: Response;\n}\ninterface UnknownError extends Error {\n  status?: unknown;\n  response?: unknown;\n}\ndeclare type ErrorTypes$1 = NetworkError | UnknownError;\n\n/** What the function's promise resolves to */\ndeclare type ResolveType<E extends (...args: any) => any> =\n  ReturnType<E> extends Promise<infer R> ? R : never;\n/** Fallback to schema if fetch function isn't defined */\ndeclare type InferReturn<\n  F extends FetchFunction,\n  S extends Schema | undefined,\n> = S extends undefined\n  ? ReturnType<F>\n  : ReturnType<F> extends unknown\n  ? Promise<Denormalize$1<S>>\n  : ReturnType<F>;\n\ndeclare type ExpiryStatusInterface = 1 | 2 | 3;\n\ninterface SnapshotInterface {\n  getResponse: <\n    E extends Pick<EndpointInterface, 'key' | 'schema' | 'invalidIfStale'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => {\n    data: any;\n    expiryStatus: ExpiryStatusInterface;\n    expiresAt: number;\n  };\n  getError: <\n    E extends Pick<EndpointInterface, 'key'>,\n    Args extends readonly [...Parameters<E['key']>],\n  >(\n    endpoint: E,\n    ...args: Args\n  ) => ErrorTypes$1 | undefined;\n  readonly fetchedAt: number;\n}\n\n/** Defines a networking endpoint */\ninterface EndpointInterface<\n  F extends FetchFunction = FetchFunction,\n  S extends Schema | undefined = Schema | undefined,\n  M extends true | undefined = true | undefined,\n> extends EndpointExtraOptions<F> {\n  (...args: Parameters<F>): InferReturn<F, S>;\n  key(...args: Parameters<F>): string;\n  readonly sideEffect?: M;\n  readonly schema?: S;\n}\ninterface EndpointExtraOptions<F extends FetchFunction = FetchFunction> {\n  /** Default data expiry length, will fall back to NetworkManager default if not defined */\n  readonly dataExpiryLength?: number;\n  /** Default error expiry length, will fall back to NetworkManager default if not defined */\n  readonly errorExpiryLength?: number;\n  /** Poll with at least this frequency in miliseconds */\n  readonly pollFrequency?: number;\n  /** Marks cached resources as invalid if they are stale */\n  readonly invalidIfStale?: boolean;\n  /** Enables optimistic updates for this request - uses return value as assumed network response\n   * @deprecated use https://resthooks.io/docs/api/Endpoint#getoptimisticresponse instead\n   */\n  optimisticUpdate?(...args: Parameters<F>): ResolveType<F>;\n  /** Enables optimistic updates for this request - uses return value as assumed network response */\n  getOptimisticResponse?(\n    snap: SnapshotInterface,\n    ...args: Parameters<F>\n  ): ResolveType<F>;\n  /** Determines whether to throw or fallback to */\n  errorPolicy?(error: any): 'hard' | 'soft' | undefined;\n  /** User-land extra data to send */\n  readonly extra?: any;\n}\n\ndeclare type FetchFunction<A extends readonly any[] = any, R = any> = (\n  ...args: A\n) => Promise<R>;\n\n/** This file exists to keep compatibility with SchemaDetail, and SchemaList type hacks\n * Support can be dropped once @rest-hooks/rest@5 support is dropped\n */\n\ndeclare type Denormalize<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? Denormalize$1<S>\n    : Denormalize$1<Extract<S, EntityInterface[]>>\n  : Denormalize$1<Extract<S, EntityInterface>>;\ndeclare type DenormalizeNullable<S> = Extract<S, EntityInterface> extends never\n  ? Extract<S, EntityInterface[]> extends never\n    ? DenormalizeNullable$1<S>\n    : DenormalizeNullable$1<Extract<S, EntityInterface[]>>\n  : DenormalizeNullable$1<Extract<S, EntityInterface>>;\n\n/**\n * Ensure an endpoint is available.\n * Suspends until it is.\n *\n * `useSuspense` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useSuspense\n * @throws {Promise} If data is not yet available.\n * @throws {NetworkError} If fetch fails.\n */\ndeclare function useSuspense<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): Args extends [null]\n  ? E['schema'] extends Exclude<Schema, null>\n    ? DenormalizeNullable<E['schema']>\n    : undefined\n  : E['schema'] extends Exclude<Schema, null>\n  ? Denormalize<E['schema']>\n  : ResolveType<E>;\n\n/**\n * Access a response if it is available.\n *\n * `useCache` guarantees referential equality globally.\n * @see https://resthooks.io/docs/api/useCache\n */\ndeclare function useCache<\n  E extends Pick<\n    EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n    'key' | 'schema' | 'invalidIfStale'\n  >,\n  Args extends readonly [...Parameters<E['key']>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends undefined\n  ? E extends (...args: any) => any\n    ? ResolveType<E> | undefined\n    : any\n  : DenormalizeNullable<E['schema']>;\n\ndeclare type ErrorTypes = NetworkError | UnknownError;\ndeclare type UseErrorReturn<P> = P extends [null]\n  ? undefined\n  : ErrorTypes | undefined;\n/**\n * Get any errors for a given request\n * @see https://resthooks.io/docs/api/useError\n */\ndeclare function useError<\n  E extends Pick<EndpointInterface, 'key'>,\n  Args extends readonly [...Parameters<E['key']>] | readonly [null],\n>(endpoint: E, ...args: Args): UseErrorReturn<Args>;\n\n/**\n * Request a resource if it is not in cache.\n * @see https://resthooks.io/docs/api/useFetch\n */\ndeclare function useFetch<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(endpoint: E, ...args: Args): ReturnType<E> | undefined;\n\n/**\n * Keeps a resource fresh by subscribing to updates.\n * @see https://resthooks.io/docs/api/useSubscription\n */\ndeclare function useSubscription<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(endpoint: E, ...args: Args): void;\n\ndeclare type CondNull<P, A, B> = P extends null ? A : B;\ndeclare type StatefulReturn<S extends Schema | undefined, P> = CondNull<\n  P,\n  {\n    data: DenormalizeNullable<S>;\n    loading: false;\n    error: undefined;\n  },\n  | {\n      data: Denormalize<S>;\n      loading: false;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: true;\n      error: undefined;\n    }\n  | {\n      data: DenormalizeNullable<S>;\n      loading: false;\n      error: ErrorTypes$1;\n    }\n>;\n/**\n * Use async date with { data, loading, error } (DLE)\n * @see https://resthooks.io/docs/api/useDLE\n */\ndeclare function useDLE<\n  E extends EndpointInterface<FetchFunction, Schema | undefined, undefined>,\n  Args extends readonly [...Parameters<E>] | readonly [null],\n>(\n  endpoint: E,\n  ...args: Args\n): E['schema'] extends undefined\n  ? {\n      data: E extends (...args: any) => any ? ResolveType<E> | undefined : any;\n      loading: boolean;\n      error: ErrorTypes$1 | undefined;\n    }\n  : StatefulReturn<E['schema'], Args[0]>;\n\n/**\n * Imperative control of Rest Hooks store\n * @see https://resthooks.io/docs/api/useController\n */\ndeclare function useController(): Controller;\n\ndeclare const StateContext: Context<State$1<unknown>>;\ndeclare const DispatchContext: Context<(value: ActionTypes) => Promise<void>>;\ndeclare const DenormalizeCacheContext: Context<DenormalizeCache>;\ndeclare const ControllerContext: Context<Controller>;\ninterface Store<S> {\n  subscribe(listener: () => void): () => void;\n  dispatch: React.Dispatch<ActionTypes>;\n  getState(): S;\n  uninitialized?: boolean;\n}\ndeclare const StoreContext: Context<Store<State$1<unknown>>>;\n\ndeclare const useCacheState: () => State$1<unknown>;\n//# sourceMappingURL=useCacheState.d.ts.map\n\ndeclare const createFetch: typeof legacyActions.createFetch;\ndeclare const createReceive: typeof legacyActions.createReceive;\ndeclare const createReceiveError: typeof legacyActions.createReceiveError;\ndeclare const initialState: _rest_hooks_core.State<unknown>;\ndeclare const DELETED: symbol;\ndeclare const inferResults: typeof __INTERNAL__.inferResults;\n\ndeclare const internal_d_createFetch: typeof createFetch;\ndeclare const internal_d_createReceive: typeof createReceive;\ndeclare const internal_d_createReceiveError: typeof createReceiveError;\ndeclare const internal_d_initialState: typeof initialState;\ndeclare const internal_d_DELETED: typeof DELETED;\ndeclare const internal_d_inferResults: typeof inferResults;\ndeclare const internal_d_createReducer: typeof createReducer;\ndeclare const internal_d_applyManager: typeof applyManager;\ndeclare const internal_d_useCacheState: typeof useCacheState;\ndeclare namespace internal_d {\n  export {\n    internal_d_createFetch as createFetch,\n    internal_d_createReceive as createReceive,\n    internal_d_createReceiveError as createReceiveError,\n    internal_d_initialState as initialState,\n    internal_d_DELETED as DELETED,\n    internal_d_inferResults as inferResults,\n    internal_d_createReducer as createReducer,\n    internal_d_applyManager as applyManager,\n    internal_d_useCacheState as useCacheState,\n  };\n}\n\n/** Turns a dispatch function into one that resolves once its been commited */\ndeclare function usePromisifiedDispatch<R extends React$1.Reducer<any, any>>(\n  dispatch: React$1.Dispatch<React$1.ReducerAction<R>>,\n  state: React$1.ReducerState<R>,\n): (action: React$1.ReducerAction<R>) => Promise<void>;\n\nexport {\n  _default as AsyncBoundary,\n  _default$1 as BackupBoundary,\n  CacheProvider,\n  ControllerContext,\n  DenormalizeCacheContext,\n  DispatchContext,\n  NetworkErrorBoundary,\n  StateContext,\n  Store,\n  StoreContext,\n  internal_d as __INTERNAL__,\n  useCache,\n  useController,\n  useDLE,\n  useError,\n  useFetch,\n  usePromisifiedDispatch,\n  useSubscription,\n  useSuspense,\n};\n"}}]);